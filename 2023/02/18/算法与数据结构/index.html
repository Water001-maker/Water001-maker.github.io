<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>算法与数据结构 | 幻想家的秘密基地</title><meta name="author" content="Xue_Water"><meta name="copyright" content="Xue_Water"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="算法与数据结构概述数据结构和算法的重要性  算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高速计算 一般来讲 程序会使用了内存计算框架(比如Spark)和缓存技术(比如Redis等)来优化程序，再深入的思考一下，这些计算框架和缓存技术，它的核 心功能是哪个部分呢? 拿实际工作经历来说, 在Unix下开发服务器程序，功能是要支持上千万人同时在线，在上线前，做内测，一切OK，可上线后，服务">
<meta property="og:type" content="article">
<meta property="og:title" content="算法与数据结构">
<meta property="og:url" content="https://water001-maker.github.io/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="幻想家的秘密基地">
<meta property="og:description" content="算法与数据结构概述数据结构和算法的重要性  算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高速计算 一般来讲 程序会使用了内存计算框架(比如Spark)和缓存技术(比如Redis等)来优化程序，再深入的思考一下，这些计算框架和缓存技术，它的核 心功能是哪个部分呢? 拿实际工作经历来说, 在Unix下开发服务器程序，功能是要支持上千万人同时在线，在上线前，做内测，一切OK，可上线后，服务">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://water001-maker.github.io/img/cover5.jpg">
<meta property="article:published_time" content="2023-02-17T16:00:00.000Z">
<meta property="article:modified_time" content="2023-02-18T09:24:16.460Z">
<meta property="article:author" content="Xue_Water">
<meta property="article:tag" content="算法与数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://water001-maker.github.io/img/cover5.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://water001-maker.github.io/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法与数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-18 17:24:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover5.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="幻想家的秘密基地"><span class="site-name">幻想家的秘密基地</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法与数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-17T16:00:00.000Z" title="发表于 2023-02-18 00:00:00">2023-02-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-18T09:24:16.460Z" title="更新于 2023-02-18 17:24:16">2023-02-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">80k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>317分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法与数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>数据结构和算法的重要性</strong></p>
<ol>
<li><strong>算法是程序的灵魂</strong>，优秀的程序可以在海量数据计算时，依然保持高速计算</li>
<li>一般来讲 程序会使用了内存计算框架(比如Spark)和缓存技术(比如Redis等)来优化程序，再深入的思考一下，这些计算框架和缓存技术，它的核 心功能是哪个部分呢?</li>
<li>拿实际工作经历来说, 在Unix下开发服务器程序，功能是要支持上千万人同时在线，在上线前，做内测，一切OK，可上线后，服务器就支撑不住了,公司的CTO对代码进行优化，再次上线，坚如磐石。你就能感受到程序是有灵魂的，就是算法。</li>
<li>目前程序员面试的门槛越来越高，<strong>很多一线IT公司</strong>(大厂),都会有<strong>数据结构和算法面试题</strong>(负责的告诉你，肯定有的)</li>
<li>如果你不想永远都是代码工人，那就花时间来研究下数据结构和算法</li>
</ol>
<p><strong>数据结构和算法的关系</strong></p>
<ol>
<li>数据data结构(structure)是一门<strong>研究组织数据方式</strong>的学科，有了编程语言也就有了数据结构学好数据结构可以编写出更加漂亮，更加有效率的代码。</li>
<li>要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决.</li>
<li><strong>程序&#x3D;数据结构+算法</strong></li>
<li><strong>数据结构是算法的基础</strong>，换言之，想要学好算法，需要把数据结构学到位。</li>
</ol>
<h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><ol>
<li>线性结构作为最常用的数据结构，其特点是<strong>数据元素之间存在一对一</strong>的线性关系。</li>
<li>线性结构有两种不同的存储结构，即**顺序存储结构(数组)<strong>和</strong>链式存储结构(链表)**。<ul>
<li>顺序存储的线性表称为顺序表，顺序表中的<strong>存储元素是连续</strong>的。</li>
<li>链式存储的线性表称为链表，链表中的<strong>存储元素不一定是连续的</strong>，元素节点中存放数据元素以及相邻元素的地址信息。</li>
</ul>
</li>
<li>线性结构常见的有：<strong>数组、队列、链表和栈</strong></li>
</ol>
<h2 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h2><p>非线性结构包括：二维数组，多维数组，广义表，<strong>树结构</strong>，<strong>图结构</strong></p>
<h1 id="稀疏数组和队列"><a href="#稀疏数组和队列" class="headerlink" title="稀疏数组和队列"></a>稀疏数组和队列</h1><h2 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方法是：</p>
<ol>
<li><strong>记录数组一共有几行几列，有多少个不同的值</strong></li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中。从而<strong>缩小程序的规模</strong></li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211207224323105.png" alt="image-20211207224323105"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol>
<li>使用稀疏数组，用于保留二维数组（棋盘、地图……）</li>
<li>把稀疏数组存盘，并且可以重新恢复原来的二维数组</li>
</ol>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211207225716880.png" alt="image-20211207225716880"></p>
<p><strong>二维数组转稀疏数组</strong></p>
<ol>
<li>遍历原始的二维数组，得到有效数据的个数sum</li>
<li>根据sum就可以建立稀疏数组sparseArr int [sum+1] [3]</li>
<li>将二维数组的有效数据存入到稀疏数组</li>
</ol>
<p><strong>稀疏数组转二维数组</strong></p>
<ol>
<li><p>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 &#x3D; int [11] [11]</p>
</li>
<li><p>在读取稀疏数组后几行的数据，并赋给 原始的二维数组即可.</p>
</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;E:\\Program\\AlgorithmStudy\\src\\com\\algorithm\\_1_1sparsearray\\sparseArray.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个原始的二维数组 11*11</span></span><br><span class="line">        <span class="comment">//0表示没有棋子 1表示黑子 2表示白子</span></span><br><span class="line">        <span class="type">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//输出原始的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始的二维数组：&quot;</span>);</span><br><span class="line">        <span class="comment">/*foreach方式遍历数组</span></span><br><span class="line"><span class="comment">        for(数据类型 变量名:数组名)</span></span><br><span class="line"><span class="comment">        &#123;&#125;</span></span><br><span class="line"><span class="comment">        首先遍历chessArr1[],得到的都是一些地址值，然后再次遍历chessArr1[][]，这才能得到所存储的值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] arr : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data : arr) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将二维数组转稀疏数组</span></span><br><span class="line">        <span class="comment">//1.先遍历二维数组得到非0数据的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessArr1[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组中非零元素的个数：&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建对应的稀疏数组</span></span><br><span class="line">        <span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="comment">//遍历二维数组，将非0的值放入稀疏数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//计数器用于记录第几个非0数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出稀疏数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;得到的稀疏数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, sparseArr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入IO流</span></span><br><span class="line">        System.out.println(<span class="string">&quot;保存稀疏数组到本地&quot;</span>);</span><br><span class="line">        <span class="comment">//保存到本地</span></span><br><span class="line">        SaveToLocal(fileName, sparseArr);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;正在读取本地稀疏数组文件&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] readArray = ReadByLocal(fileName);</span><br><span class="line">        printArray(readArray);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取到的稀疏数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;读取到的稀疏数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; readArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, readArray[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将稀疏数组==&gt;恢复成 原始数组</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"><span class="comment">        2.在读取稀疏数组后几行的数据，并赋值原始数据即可</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[readArray[<span class="number">0</span>][<span class="number">0</span>]][readArray[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr2[readArray[i][<span class="number">0</span>]][readArray[i][<span class="number">1</span>]] = readArray[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出恢复后的二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] arr : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data : arr) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将稀疏数组保存到本地</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SaveToLocal</span><span class="params">(String fileName, <span class="type">int</span>[][] sparseArray)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//输出流</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(fileName), <span class="literal">false</span>));</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">//拼接字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : sparseArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : row) &#123;</span><br><span class="line">                sb.append(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bw.write(sb.toString());</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取本地稀疏数组文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] ReadByLocal(String fileName) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//定义行列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; readList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//文件</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(fileName))));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将读取到的String转换为int数组存数在ArrayList中</span></span><br><span class="line">            <span class="type">int</span>[] array = Arrays.stream(line.split(<span class="string">&quot;\\t&quot;</span>)).mapToInt(Integer::parseInt).toArray();</span><br><span class="line">            System.out.println(<span class="string">&quot;读取到的稀疏数组:&quot;</span> + Arrays.toString(array));</span><br><span class="line">            <span class="comment">//用List保存</span></span><br><span class="line">            readList.add(array);</span><br><span class="line">            <span class="comment">//列</span></span><br><span class="line">            col = array.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//行</span></span><br><span class="line">        row = readList.size();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ArrayList内部一维数组转化为二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] readArray = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; readArray.length; i++) &#123;</span><br><span class="line">            readArray[i] = readList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208130652891.png" alt="image-20211208130652891"></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208130801446.png" alt="image-20211208130801446"></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>队列是一个<strong>有序列表</strong>，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</p>
</li>
<li><p>遵循<strong>先入先出</strong>的原则。即：<strong>先存入队列的数据，要先取出</strong>。<strong>后存入的要后取出</strong></p>
</li>
<li><p>示意图: (使用数组模拟队列示意图)</p>
<ul>
<li>rear表示队尾</li>
<li>front表示队首</li>
<li>存入时从队尾加入数据，取出时从队首取出数据</li>
</ul>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208132539487.png" alt="image-20211208132539487"></p>
</li>
</ol>
<h3 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h3><p>利用数组模拟队列</p>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中<strong>maxSize是该队列的最大容量</strong>。</p>
<p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量<strong>front及rear分别记录队列前后端的下标</strong>，<strong>front会随着数据输出而改变</strong>，而<strong>rear则是随着数据输入而改变</strong>，如图所示：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208131212948.png" alt="image-20211208131212948"></p>
<ul>
<li>当我们将数据存入队列时称为”addQueue”，addQueue的处理需要有两个步骤：<ol>
<li>将尾指针往后移：rear+1，当front&#x3D;&#x3D;rear[空]</li>
<li>若尾指针rear小于队列的最大下标maxSize-1, 则将数据存入rear所指的数组元素中，否则无法存入数据。（**rear&#x3D;&#x3D;maxSize-1[队列满]**）</li>
</ol>
</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试,创建一个队列</span></span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>; <span class="comment">//接受用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;show(s):显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit(e):退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;add(a):添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;get(g):从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;head(h):查看队列头的数据&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入一个数据&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:<span class="comment">//取出数据</span></span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span>queue.getQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;取出数据是&quot;</span>+res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:<span class="comment">//查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span>queue.headQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列头的数据是&quot;</span>+res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:<span class="comment">//退出</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//该数据用于存放数据,模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span> &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;<span class="comment">//指向队列首,分析出front是指向队列头的前一个位置</span></span><br><span class="line">        rear = -<span class="number">1</span>;<span class="comment">//指向队列尾，指向队列尾的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，不能加入数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;<span class="comment">//让rear后移</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出队列，获取队列的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;<span class="comment">//font后移</span></span><br><span class="line">        System.out.println(<span class="string">&quot;已取出&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列空，没有数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列元素为：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;arr[&quot;</span>+i+<span class="string">&quot;]=&quot;</span>+arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据，注意不是取数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，没有数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在问题</p>
<ol>
<li>目前的队列使用一次就不能能再使用了</li>
<li>解决方案：将此队列改进为环形队列</li>
</ol>
<h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><p>对前面的数组模拟队列的优化，充分利用数组.。因此将数组看做是一个环形的。（通过取模的方式来实现即可）</p>
<h4 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h4><ol>
<li>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定，这个在做判断队列满的时候需要注意(rear+1)%maxSize&#x3D;&#x3D;front[满]</li>
<li>rear&#x3D;front[空]</li>
</ol>
<p><strong>思路调整</strong></p>
<ol>
<li><p>front 变量的含义做一个调整：front 就指向队列的第一个元素，也就是说 arr[front] 就是队列的第一个元素 front 的初始值 &#x3D; 0</p>
</li>
<li><p>rear变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置。因为希望空出一个空间做为约定。rear 的初始值 &#x3D; 0</p>
</li>
<li><p>队列满时的条件：<strong>（rear+1）% maxSize&#x3D;&#x3D;front</strong>【满】</p>
</li>
<li><p>队列为空的条件： <strong>rear &#x3D;&#x3D; front</strong>【空】</p>
</li>
<li><p>当我们这样分析， 队列中有效的数据的个数  <strong>&#x3D;&#x3D;(rear + maxSize - front) % maxSize&#x3D;&#x3D;</strong> </p>
</li>
<li><p>我们就可以在原来的队列上修改得到，一个环形队列</p>
</li>
</ol>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleArrayQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试环形队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;测试数组模拟环形队列的案例~~~&quot;</span>);</span><br><span class="line">        <span class="type">CircleArray</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleArray</span>(<span class="number">4</span>);<span class="comment">//设置4，但是阵列存放数据最大为3,其中一个只是预留空间</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//接受用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit):退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get):从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head):查看队列头的数据&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入一个数据&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:<span class="comment">//取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> queue.getQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;取出数据是&quot;</span> + res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:<span class="comment">//查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> queue.headQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列头的数据是&quot;</span> + res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:<span class="comment">//退出</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//front指向数组索引为0的第一个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//rear指向最后一个数据的后一个位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//该数据用于存放数据,模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircleArray</span><span class="params">(<span class="type">int</span> arrMaxSize)</span> &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，不能加入数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接将数据加入</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        <span class="comment">//将rear后移这里必须考虑取余</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出队列，获取队列的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否是空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里需要分析front是指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">//1.先把front对应的值保存到一个临时变量中</span></span><br><span class="line">        <span class="comment">//2.将front后移，考虑取余</span></span><br><span class="line">        <span class="comment">//3.将临时变量返回</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列空，没有数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i &lt; front + size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arr[&quot;</span> + (i % maxSize) + <span class="string">&quot;]=&quot;</span> + arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求出当前阵列有效数组的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据，注意不是取数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，没有数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>链表是有序的列表，但是它在内存中是存储如下</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208184127950.png" alt="image-20211208184127950"></p>
<p>小结上图:</p>
<ol>
<li>链表是以节点的方式来存储，是<strong>链式存储</strong>。</li>
<li>每个节点包含 data 域， next 域：指向下一个节点。</li>
<li>如图：发现<strong>链表的各个节点不一定是连续存储</strong>。</li>
<li>链表分<strong>带头节点的链表</strong>和<strong>没有头节点的链表</strong>，根据实际的需求来确定。</li>
</ol>
<ul>
<li><strong>单链表(带头结点) 逻辑结构示意图如下</strong></li>
</ul>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208184147853.png" alt="image-20211208184147853"></p>
<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>使用带 head 头的单向链表实现——水浒英雄排行榜管理完成对英雄人物的增删改查操作， 注: 删除和修改</p>
<h3 id="实例1-1"><a href="#实例1-1" class="headerlink" title="实例1"></a>实例1</h3><h4 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h4><p>1、第一种方法在添加英雄时，<strong>直接添加到链表的尾部</strong>思路分析示意图：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208191751625.png" alt="image-20211208191751625"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">//1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">//2.将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">    <span class="comment">//因为head节点不能动,因此我们需要一个辅助变量temp</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//找到链表的最后   1</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有找到，将temp后移</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当退出循环时，temp就指向了链表的最后</span></span><br><span class="line">    <span class="comment">//将最后的这个节点的next 指向新的节点     2</span></span><br><span class="line">    temp.next = heroNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、第二种方式在添加英雄时，<strong>根据排名</strong>将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) 思路的分析示意图：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208193312599.png" alt="image-20211208193312599"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">//在内存中将数据排序</span></span><br><span class="line"><span class="comment">//(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="comment">//要将新添加的heroNode存储到temp.next的位置，所以要和原先的temp.next作比较。将heroNode.next指向原先的temp.next.no，再将temp.next指向新的heroNode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">    <span class="comment">//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line">    <span class="comment">//因为单链表，找到的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;<span class="comment">//说明temp已经在链表的最后</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">//位置找到，就在temp的后面</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode的编号已然存在</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;<span class="comment">//后移，遍历当前链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断flag的值</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;<span class="comment">//不能添加，说明编号存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;准备插入的英雄的编号&quot;</span>+heroNode.no+<span class="string">&quot;已经存在了,不能加入&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//插入到链表中，temp的后面（不能反！！！）</span></span><br><span class="line">        <span class="comment">//将heroNode.next指向原先的temp.next</span></span><br><span class="line">        heroNode.next = temp.next;</span><br><span class="line">        <span class="comment">//temp.next指向新的heroNode</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、修改节点功能</p>
<p>思路:</p>
<ol>
<li><p>先找到该节点，通过遍历</p>
</li>
<li><p>&#96;&#96;&#96;<br>temp.name &#x3D; newHeroNode.name;<br>temp.nickname&#x3D; newHeroNode.nickname;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">//修改节点的信息，根据no编号来修改，即no编号不能改</span><br><span class="line">//说明</span><br><span class="line">//1.根据newHeroNode的no来修改即可</span><br><span class="line">public void update(HeroNode newHeroNode) &#123;</span><br><span class="line">    //判断是否为空</span><br><span class="line">    if (head.next == null) &#123;//链表的有效节点并不包括头指针，头指针通常用head定义，他只是指向第一个有效结点；无论链表是否为空，头指针都不为空；头指针并不存放有效数据！</span><br><span class="line">        System.out.println(&quot;链表为空&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //找到需要修改的节点，根据no编号</span><br><span class="line">    //先定义一个辅助变量</span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    boolean flag = false;//表示是否找到节点</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (temp == null) &#123;</span><br><span class="line">            break;//已经遍历完链表</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp.no == newHeroNode.no) &#123;</span><br><span class="line">            //找到</span><br><span class="line">            flag = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    //根据flag是否找到要修改的节点</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        temp.name = newHeroNode.name;</span><br><span class="line">        temp.nickname = newHeroNode.nickname;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.printf(&quot;没有找到编号%d的节点，不能修改\n&quot;, newHeroNode.no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>4、删除节点</p>
<p>思路分析的示意图:</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208193404692.png" alt="image-20211208193404692"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">//1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">//2.说明我们在比较时，是temp.next.no和需要删除的节点的no的比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标志是否找到待删除节点的</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">            <span class="comment">//找到的待删除节点的前一个节点temp</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;<span class="comment">//temp后移，遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断flag</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;<span class="comment">//找到</span></span><br><span class="line">        <span class="comment">//可以删除</span></span><br><span class="line">        <span class="comment">//让当前的下一个节点指向当前的下一个的下一个</span></span><br><span class="line">        temp.next = temp.next.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;要删除的%d 节点不存在\n&quot;</span>, no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedListDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进项测试</span></span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">        <span class="comment">//加入</span></span><br><span class="line">        <span class="comment">//singleLinkedList.add(hero1);</span></span><br><span class="line">        <span class="comment">//singleLinkedList.add(hero4);</span></span><br><span class="line">        <span class="comment">//singleLinkedList.add(hero3);</span></span><br><span class="line">        <span class="comment">// singleLinkedList.add(hero2);</span></span><br><span class="line">        <span class="comment">//加入按照编号的顺序</span></span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        <span class="comment">//显示一把</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        <span class="comment">//测试修改节点的代码</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;冲冲&quot;</span>, <span class="string">&quot;豹豹头&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的链表情况：&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        <span class="comment">//删除一个节点</span></span><br><span class="line">        singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">        singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">        singleLinkedList.del(<span class="number">2</span>);</span><br><span class="line">        singleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的链表情况：&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点,头节点不能动,不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向链表</span></span><br><span class="line">    <span class="comment">//思路，当不考虑编号顺序时</span></span><br><span class="line">    <span class="comment">//1.找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">//2.将最后这个节点的next指向新的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动,因此我们需要一个辅助变量temp</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后   1</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后的这个节点的next 指向新的节点     2</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">    <span class="comment">//在内存中将数据排序</span></span><br><span class="line">    <span class="comment">//(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line">    <span class="comment">//要将新添加的heroNode存储到temp.next的位置，所以要和原先的temp.next作比较。将heroNode.next指向原先的temp.next.no，再将temp.next指向新的heroNode</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">//因为单链表，找到的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;<span class="comment">//说明temp已经在链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">//位置找到，就在temp的后面</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode的编号已然存在</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//后移，遍历当前链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;<span class="comment">//不能添加，说明编号存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;准备插入的英雄的编号&quot;</span>+heroNode.no+<span class="string">&quot;已经存在了,不能加入&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入到链表中，temp的后面（不能反！！！）</span></span><br><span class="line">            <span class="comment">//将heroNode.next指向原先的temp.next</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            <span class="comment">//temp.next指向新的heroNode</span></span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点的信息，根据no编号来修改，即no编号不能改</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1.根据newHeroNode的no来修改即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;<span class="comment">//链表的有效节点并不包括头指针，头指针通常用head定义，他只是指向第一个有效结点；无论链表是否为空，头指针都不为空；头指针并不存放有效数据！</span></span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到需要修改的节点，根据no编号</span></span><br><span class="line">        <span class="comment">//先定义一个辅助变量</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//表示是否找到节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历完链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号%d的节点，不能修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">    <span class="comment">//2.说明我们在比较时，是temp.next.no和需要删除的节点的no的比较</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标志是否找到待删除节点的</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//找到的待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//temp后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;<span class="comment">//找到</span></span><br><span class="line">            <span class="comment">//可以删除</span></span><br><span class="line">            <span class="comment">//让当前的下一个节点指向当前的下一个的下一个</span></span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的%d 节点不存在\n&quot;</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表[遍历]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移，一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode，每个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;<span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">public</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方法，我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试1"><a href="#面试1" class="headerlink" title="面试1"></a>面试1</h3><p>&#x3D;&#x3D;求单链表中有效节点的个数&#x3D;&#x3D;</p>
<p><strong>具体实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求单链表中有效节点的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head  链表的头结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  返回的就是有效结点的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">heroNode</span> <span class="operator">=</span> head.next;<span class="comment">//没有统计头结点</span></span><br><span class="line">    <span class="keyword">while</span> (heroNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        heroNode = heroNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line"></span><br><span class="line">    singleLinkedList.addByOrder(hero1);</span><br><span class="line">    singleLinkedList.addByOrder(hero2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;有效节点的个数：&quot;</span>+getLength(singleLinkedList.getHead()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208213647363.png" alt="image-20211208213647363"></p>
<h3 id="面试2"><a href="#面试2" class="headerlink" title="面试2"></a>面试2</h3><p>&#x3D;&#x3D;查找单链表中的倒数第 k 个结点&#x3D;&#x3D;</p>
<p><strong>具体实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找单链表中的倒数第k个结点</span></span><br><span class="line"><span class="comment"> * 思路</span></span><br><span class="line"><span class="comment"> * 1. 编写一个方法，接收 head 节点，同时接收一个 index</span></span><br><span class="line"><span class="comment"> * 2. index 表示是倒数第 index 个节点</span></span><br><span class="line"><span class="comment"> * 3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment"> * 4. 得到 size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line"><span class="comment"> * 5. 如果找到了，则返回该节点，否则返回 null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//第一个遍历得到链表的长度(节点个数)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">    <span class="comment">//判断如果链表为空，返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//index 的校验，确定index符合范围</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二次遍历 size-index 位置，就是我们倒数的第 K 个节点</span></span><br><span class="line">    <span class="comment">//定义一个辅助变量</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">heroNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">        heroNode = heroNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> heroNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line"></span><br><span class="line">    singleLinkedList.addByOrder(hero1);</span><br><span class="line">    singleLinkedList.addByOrder(hero2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;倒数第1个节点：&quot;</span> +findLastIndexNode(singleLinkedList.getHead(),<span class="number">1</span>) );</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208215721405.png" alt="image-20211208215721405"></p>
<h3 id="面试3"><a href="#面试3" class="headerlink" title="面试3"></a>面试3</h3><p>&#x3D;&#x3D;单链表的反转【腾讯面试题，有点难度】&#x3D;&#x3D;</p>
<p><strong>思路:</strong> </p>
<p>1、 先定义一个节点 reverseHead &#x3D; new HeroNode();</p>
<p>2.、从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端.</p>
<p>3、原来的链表的head.next &#x3D; reverseHead.next</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208230720001.png" alt="image-20211208230720001"></p>
<p><strong>具体实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将单链表反转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversetList</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;<span class="comment">//用于遍历原先链表的</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//指向当前节点的下一个节点。</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//创建的新链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表 reverseHead 的最前端</span></span><br><span class="line">    <span class="comment">//动脑筋</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = cur.next;<span class="comment">//暂时保存cur当前节点的下一个节点，因为要留给下一次循环使用</span></span><br><span class="line">        cur.next = reverseHead.next;<span class="comment">//将当前结点的下一个节点指向新链表的最前端，即新链表的头结点的下一个节点</span></span><br><span class="line">        reverseHead.next = cur;<span class="comment">//再将新链表头结点的下一个节点指向cur，也就是当前链表</span></span><br><span class="line">        cur = next;<span class="comment">//cur后移，下一个循环使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将 head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">    head.next = reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;原本的链表&quot;);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;反转的链表&quot;);</span><br><span class="line">        reversetList(singleLinkedList.getHead());</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211208235530352.png" alt="image-20211208235530352"></p>
<h3 id="面试4"><a href="#面试4" class="headerlink" title="面试4"></a>面试4</h3><p>&#x3D;&#x3D;从尾到头打印单链表&#x3D;&#x3D;</p>
<p><strong>思路</strong></p>
<p>1.、上面的题的要求就是逆序打印单链表.</p>
<p>2、方式1： 先将单链表进行反转操作，然后再遍历即可，这样的做的问题是会破坏原来的单链表的结构，不建议</p>
<p>3、**方式2：可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果.<br>举例演示栈的使用 Stack **</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211209000108713.png" alt="image-20211209000108713"></p>
<p><strong>具体实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式2：</span></span><br><span class="line"><span class="comment">//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//空链表，不能打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建要给一个栈，将各个节点压入栈</span></span><br><span class="line">    Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;HeroNode&gt;();</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="comment">//将链表的所有节点压入栈</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.next; <span class="comment">//cur后移，这样就可以压入下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将栈中的节点进行打印,pop 出栈</span></span><br><span class="line">    <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(stack.pop()); <span class="comment">//stack的特点是先进后出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原本的链表&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反向输出&quot;</span>);</span><br><span class="line">        reversePrint(singleLinkedList.getHead());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211209001355649.png" alt="image-20211209001355649"></p>
<h3 id="面试5"><a href="#面试5" class="headerlink" title="面试5"></a>面试5</h3><p>合并两个有序的单链表，合并之后的链表依然有序</p>
<p><strong>具体实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">merge</span><span class="params">(HeroNode head1, HeroNode head2)</span> &#123;</span><br><span class="line">    <span class="comment">//创建的新链表</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个辅助的指针，帮助我们遍历原来的链表 reverseHead</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseHead;</span><br><span class="line">    <span class="comment">//定义一个辅助的指针，帮助我们遍历原来的链表1</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">l1</span> <span class="operator">=</span> head1.next;</span><br><span class="line">    <span class="comment">//定义一个辅助的指针，帮助我们遍历原来的链表2</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">l2</span> <span class="operator">=</span> head2.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过循环，比较两个链表值的大小，将其中较小的节点添加到新链表的结尾</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l2.no &gt; l1.no) &#123;</span><br><span class="line">            cur.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1.no &gt; l2.no) &#123;</span><br><span class="line">            cur.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当其中一个遍历完了之后，就将另一个剩余的节点全部添加到新链表的结尾</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        cur.next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        cur.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;老五&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;老六&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">7</span>, <span class="string">&quot;老七&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>, <span class="string">&quot;老八&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero9</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">9</span>, <span class="string">&quot;老九&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        singleLinkedList1.addByOrder(hero3);</span><br><span class="line">        singleLinkedList1.addByOrder(hero1);</span><br><span class="line">        singleLinkedList1.addByOrder(hero7);</span><br><span class="line">        singleLinkedList1.addByOrder(hero5);</span><br><span class="line">        singleLinkedList1.addByOrder(hero9);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        singleLinkedList2.addByOrder(hero2);</span><br><span class="line">        singleLinkedList2.addByOrder(hero6);</span><br><span class="line">        singleLinkedList2.addByOrder(hero8);</span><br><span class="line">        singleLinkedList2.addByOrder(hero4);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;链表1：&quot;</span>);</span><br><span class="line">        singleLinkedList1.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;链表2：&quot;</span>);</span><br><span class="line">        singleLinkedList2.list();</span><br><span class="line"></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">merge</span> <span class="operator">=</span> merge(singleLinkedList1.getHead(), singleLinkedList2.getHead());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;合并后：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (merge !=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(merge);</span><br><span class="line">            merge = merge.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211209122051254.png" alt="image-20211209122051254"></p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><strong>管理单向链表的缺点分析</strong>:</p>
<ol>
<li>单向链表，<strong>查找的方向只能是一个方向</strong>，而双向链表可以向前或者向后查找。</li>
<li>单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到 temp，temp是待删除节点的前一个节点(认真体会)。</li>
<li>分析了双向链表如何完成遍历，添加，修改和删除的思路</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211209141508844.png" alt="image-20211209141508844"></p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>使用带 head 头的双向链表实现——水浒英雄排行榜</p>
<h4 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h4><p><strong>双向链表的遍历，添加，修改，删除的操作思路</strong></p>
<ol>
<li>遍历 方和 单链表一样，只是可以向前，也可以向后查找</li>
<li>添加 (默认添加到双向链表的最后)<ol>
<li>先找到双向链表的最后这个节点</li>
<li>temp.next &#x3D; newHeroNode</li>
<li>newHeroNode.pre &#x3D; temp;</li>
</ol>
</li>
<li>修改 思路和 原来的单向链表一样.</li>
<li>删除<ol>
<li>因为是双向链表，因此，我们可以实现自我删除某个节点</li>
<li>直接找到要删除的这个节点，比如temp</li>
<li>temp.pre.next &#x3D; temp.next</li>
<li>temp.next.pre &#x3D; temp.pre;</li>
</ol>
</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;双向链表的测试&quot;</span>);</span><br><span class="line">        <span class="comment">// 先创建节点</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个双向链表</span></span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">doubleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">        doubleLinkedList.add(hero1);</span><br><span class="line">        doubleLinkedList.add(hero2);</span><br><span class="line">        doubleLinkedList.add(hero3);</span><br><span class="line">        doubleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.Forwardlist();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;双向链表的反向输出&quot;</span>);</span><br><span class="line">        doubleLinkedList.Rsvsrselist();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">4</span>, <span class="string">&quot;公孙胜&quot;</span>, <span class="string">&quot;入云龙&quot;</span>);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的链表情况&quot;</span>);</span><br><span class="line">        doubleLinkedList.Forwardlist();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的链表情况&quot;</span>);</span><br><span class="line">        doubleLinkedList.Forwardlist();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个双向链表的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode2</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回头节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历双向链表的方法</span></span><br><span class="line">    <span class="comment">// 显示链表[遍历]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Forwardlist</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出节点的信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反向遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Rsvsrselist</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp1</span> <span class="operator">=</span> head;</span><br><span class="line">        HeroNode2 temp2;</span><br><span class="line">        <span class="comment">//遍历到链表的尾节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                temp2 = temp1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp1 = temp1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从尾到头开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp2.pre == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出节点的信息</span></span><br><span class="line">            System.out.println(temp2);</span><br><span class="line">            <span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">            temp2 = temp2.pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 添加一个节点到双向链表的最后.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode2 heroNode)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;<span class="comment">//</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到最后, 将将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//形成一个双向链表</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">    <span class="comment">//在内存中将数据排序</span></span><br><span class="line">    <span class="comment">//(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line">    <span class="comment">//要将新添加的heroNode存储到temp.next的位置，所以要和原先的temp.next作比较。将heroNode.next指向原先的temp.next.no，再将temp.next指向新的heroNode</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode2 heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">//因为单链表，找到的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;<span class="comment">//说明temp已经在链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">//位置找到，就在temp的后面</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode的编号已然存在</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//后移，遍历当前链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;<span class="comment">//不能添加，说明编号存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;准备插入的英雄的编号&quot;</span> + heroNode.no + <span class="string">&quot;已经存在了,不能加入&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入需要四步</span></span><br><span class="line">            <span class="comment">//插入的节点在链表的中间</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                heroNode.next = temp.next;</span><br><span class="line">                temp.next.pre = heroNode;</span><br><span class="line">                heroNode.pre = temp;</span><br><span class="line">                temp.next = heroNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在链表末端</span></span><br><span class="line">                heroNode.pre = temp;</span><br><span class="line">                temp.next = heroNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span></span><br><span class="line">    <span class="comment">// 只是 节点类型改成 HeroNode2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode2 newHeroNode)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要修改的节点, 根据no编号</span></span><br><span class="line">        <span class="comment">// 定义一个辅助变量</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 已经遍历完链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">// 找到</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据flag 判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有找到</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号%d的节点，不能修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从双向链表中删除一个节点</span></span><br><span class="line">    <span class="comment">//1.对于双向链表，我们可以直接找到要删除的这个节点</span></span><br><span class="line">    <span class="comment">//2.找到后，自我删除即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;<span class="comment">// 空链表</span></span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空，无法删除&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next; <span class="comment">// 辅助变量(指针)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123; <span class="comment">// 已经到链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                <span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next; <span class="comment">// temp后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断flag</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 找到</span></span><br><span class="line">            <span class="comment">// 可以删除</span></span><br><span class="line">            <span class="comment">// temp.next = temp.next.next;[单向链表]</span></span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="comment">// 这里我们的代码有问题?</span></span><br><span class="line">            <span class="comment">// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的&quot;</span> + no + <span class="string">&quot;节点不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode ， 每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next; <span class="comment">//指向下一个节点，默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre; <span class="comment">//指向前一个节点，默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode2</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方法，我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><strong>Josephu问题</strong></p>
<p>设编号为1，2,…n的n个人围坐一圈，约定编号为k (1&lt;&#x3D;k&lt;&#x3D;n) 的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<p><strong>提示</strong></p>
<p>用一个不带头结点的<strong>循环链表</strong>来处理Josephu问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211209214812167.png" alt="image-20211209214812167"></p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><h4 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211209220539194.png" alt="image-20211209220539194"></p>
<p>约瑟夫问题——小孩出圈的思路分析图</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211209220626919.png" alt="image-20211209220626919"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Josepfu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试一把构建环形链表，和遍历是否成功</span></span><br><span class="line">        <span class="type">CircleSingleLinkedList</span> <span class="variable">circleSingleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleSingleLinkedList</span>();</span><br><span class="line">        circleSingleLinkedList.addBoy(<span class="number">5</span>);<span class="comment">//加入5个小孩节点</span></span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line">        <span class="comment">//测试一把小孩出圈是否正确</span></span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个环形的单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleSingleLinkedList</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//添加小孩节点，构建一个环形链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span>&#123;</span><br><span class="line">        <span class="comment">//nums做一个数据校验</span></span><br><span class="line">        <span class="keyword">if</span>(nums &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num的值不正确&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//辅助指针，帮助构建环形链表</span></span><br><span class="line">        <span class="comment">//使用for来创建我们的环形链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums;i++)&#123;</span><br><span class="line">            <span class="comment">//根据编号，创建小孩节点</span></span><br><span class="line">            <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line">            <span class="comment">//如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);<span class="comment">//构成环</span></span><br><span class="line">                curBoy = first;<span class="comment">//让curBoy指向第一个小孩</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curBoy.setNext(boy);<span class="comment">//最后一个跟新节点相连</span></span><br><span class="line">                boy.setNext(first);<span class="comment">//跟头相连</span></span><br><span class="line">                curBoy = boy;<span class="comment">//curBoy后移</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo</span></span><br><span class="line"><span class="comment">     * 表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNum</span></span><br><span class="line"><span class="comment">     * 表示数几下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * 表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNo, <span class="type">int</span> countNum,<span class="type">int</span> nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先对数据进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数输入有误， 请重新输入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建要给辅助指针,帮助完成小孩出圈</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="comment">// 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.getNext() == first) &#123; <span class="comment">// 说明 helper 指向最后小孩节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小孩报数前，先让 first 和 helper 移动 k - 1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; startNo - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当小孩报数时，让 first 和 helper 指针同时 的移动 m - 1 次, 然后出圈</span></span><br><span class="line">        <span class="comment">//这里是一个循环操作，知道圈中只有一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(helper == first) &#123; <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//让 first 和 helper 指针同时 的移动 countNum - 1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这时 first 指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩%d 出圈\n&quot;</span>, first.getNo());</span><br><span class="line">            <span class="comment">//这时将 first 指向的小孩节点出圈</span></span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first); <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号%d \n&quot;</span>, first.getNo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前的环形链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有任何小孩&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩的编号 %d \n&quot;</span>, curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">//说明已经遍历完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext();<span class="comment">// curBoy后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个Boy类,表示一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next;<span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li><strong>栈的英文为(stack)</strong></li>
</ol>
<ol start="2">
<li><strong>栈是一个&#x3D;&#x3D;先入后出&#x3D;&#x3D;(FILO-First In Last Out)的有序列表。</strong></li>
<li><strong>栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为&#x3D;&#x3D;变化的一端，称为栈顶(Top)&#x3D;&#x3D;，&#x3D;&#x3D;另一端为固定的一端， 称为栈底(Bottom)&#x3D;&#x3D;。</strong></li>
<li><strong>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈项，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。</strong></li>
<li><strong>图解方式说明出栈(pop)和入栈(push)的概念。</strong></li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211209234749954.png" alt="image-20211209234749954"></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211209234814682.png" alt="image-20211209234814682"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。</li>
<li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li>
<li>表达式的转换【中缀表达式转后缀表达式】与求值（实际解决）。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先（depth一first）搜索法。</li>
</ol>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>用数组模拟栈的使用</p>
<p>由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。</p>
<h3 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211210000656796.png" alt="image-20211210000656796"></p>
<p>实现栈的思路分析：</p>
<ol>
<li>使用数组来模拟栈。</li>
<li>定义一个top来表示栈顶，初始化为-1。</li>
<li><strong>入栈</strong>的操作，当有数据加入到栈时，top++；stack[top] &#x3D; data；</li>
<li><strong>出栈</strong>的操作，int value &#x3D; stack[top]；top–，return value</li>
</ol>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>数组实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//数组，模拟栈，用来存放数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//栈顶元素，初始时指向栈地的上一位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  top == maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">//先判断是否栈满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈已满，不能再放数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top ++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空，没有数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈,遍历时从栈底开始遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[&quot;</span>+i+<span class="string">&quot;]=&quot;</span>+stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>队列实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DListStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">top</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>); <span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize; <span class="comment">//最大长度</span></span><br><span class="line">    <span class="keyword">private</span> Node tail; <span class="comment">//指向栈底</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DListStack</span><span class="params">(<span class="type">int</span> maxsize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxsize;</span><br><span class="line">        tail = top;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxsize; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);<span class="comment">//规定0表示没有值</span></span><br><span class="line">            tail.next = tmp;</span><br><span class="line">            tmp.prev = tail;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (top.no == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tail == top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历打印</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> top;</span><br><span class="line">        <span class="keyword">while</span> (tmp.no != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(tmp.no);</span><br><span class="line">            tmp = tmp.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈已满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top = top.next;</span><br><span class="line">        top.no = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈已空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> top.no;</span><br><span class="line">        top = top.prev;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + no;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayStack</span> <span class="variable">arrayStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">DListStack</span> <span class="variable">dListStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DListStack</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;show：表示显示栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit：表示退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;push：表示入栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;pop：表示出栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你的选择&quot;</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    <span class="comment">//arrayStack.list();</span></span><br><span class="line">                    dListStack.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">                        scanner.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    <span class="comment">//arrayStack.push(value);</span></span><br><span class="line">                    dListStack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//int res = arrayStack.pop();</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dListStack.pop();</span><br><span class="line">                        System.out.println(<span class="string">&quot;出栈的元素是&quot;</span> + res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="综合计算器（中缀）"><a href="#综合计算器（中缀）" class="headerlink" title="综合计算器（中缀）"></a>综合计算器（中缀）</h2><p>使用栈完成表达式的计算</p>
<p>中缀表达式 ： 或中缀记法）是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例：3 + 4），中缀表达式是人们常用的算术表示方法。</p>
<h3 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h3><ol>
<li><p>通过一个index值（索引），来遍历我们的表达式；</p>
</li>
<li><p>如果我们<strong>发现是一个数字</strong>，就直接入数栈；</p>
</li>
<li><p>如果发现<strong>扫描到是一个符号</strong>，就分如下情况：</p>
<ol>
<li><p>如果发现当前的符号栈为空，就直接入栈</p>
</li>
<li><p>如果符号栈有操作符，就进行比较</p>
</li>
</ol>
<ul>
<li><p><strong>如果当前的操作符的优先级小于或者等于栈中的操作符</strong>，就需要从数栈中pop出两个数，在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，</p>
</li>
<li><p><strong>如果当前的操作符的优先级大于栈中的操作符</strong>，就直接入符号栈.</p>
</li>
</ul>
</li>
<li><p><strong>当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行</strong>；</p>
</li>
<li><p><strong>最后在数栈只有一个数字，就是表达式的结果。</strong></p>
</li>
<li><p>补充：当运算式中有多位数时，先判断具体数字是多少，再判断数字</p>
</li>
</ol>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;70+2*6-4&quot;</span>; <span class="comment">//8</span></span><br><span class="line">        <span class="comment">//创建两个栈，数栈，操作符栈</span></span><br><span class="line">        <span class="type">NumStack</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumStack</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">NumStack</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumStack</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//定义相关变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于扫描</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//第一个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//第二个数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//接收操作符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//保存结果</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//保存每次扫描的操作符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keepNum</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//循环扫描计算式</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断ch是什么（符号/数字），然后做响应的处理</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isOper(ch)) &#123;<span class="comment">//如果是运算符</span></span><br><span class="line">                <span class="keyword">if</span> (!operStack.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//与符号栈栈顶元素比较，如果优先级 &lt; = 栈顶元素优先级，就从数栈里面弹出两个数，再从符号栈里弹出一个符号运算，</span></span><br><span class="line">                    <span class="comment">// 运算，后将结果压入数栈</span></span><br><span class="line">                    <span class="keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = operStack.cal(num1, num2, oper);</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        <span class="comment">//然后将当前操作符入栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//当前操作符优先级&gt;栈顶操作符优先级，直接入栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//符号栈为null，直接入栈</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//接收数字时，可能接收到多位数，因此不能发现是一个数字就入栈，因为可能是多位数</span></span><br><span class="line">                <span class="comment">//在处理数时，需要向expression的表达式的index后再看一位，如果是符号才入栈</span></span><br><span class="line">                <span class="comment">//因此我们需要定义一个变量，字符串，用于拼接</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理多位数</span></span><br><span class="line">                keepNum += ch;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断下一位是不是数字，，如果是数字，就继续扫描，如果是运算符就入栈</span></span><br><span class="line">                <span class="comment">//注意看后一位，不是index++</span></span><br><span class="line">                <span class="keyword">if</span> (index + <span class="number">1</span> == expression.length()) &#123;</span><br><span class="line">                    <span class="comment">//如果是最后一位，直接如数栈</span></span><br><span class="line">                    numStack.push(ch - <span class="number">48</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (operStack.isOper(expression.substring(index + <span class="number">1</span>, index + <span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">                        <span class="comment">//如果最后一位是运算符，则入栈 keepNum=&quot;1&quot;或者”123“</span></span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        <span class="comment">//清空keepNum</span></span><br><span class="line">                        keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             <span class="comment">/*   //如果是数字，直接入栈</span></span><br><span class="line"><span class="comment">                numStack.push(ch-48);//字符转数字*/</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让index+1，并判断是否扫描到expression的结尾</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= expression.length()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//扫描完毕，跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果符号栈为空，则计算到最后结果，数栈中只有一个数栈【结果】</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = numStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">        res = numStack.pop();</span><br><span class="line">        System.out.printf(<span class="string">&quot;表达式%s = %d&quot;</span>, expression, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//数组，模拟栈，用来存放数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//栈顶元素，初始时指向栈地的上一位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取栈顶元素，但不pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//先判断是否栈满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈已满，不能再放数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空，没有数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈,遍历时从栈底开始遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级，优先级由程序员来确定，优先级使用数字表示</span></span><br><span class="line">    <span class="comment">//数字越大，优先级越高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">int</span> oper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//辨别运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOper</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val == <span class="string">&#x27;+&#x27;</span> || val == <span class="string">&#x27;-&#x27;</span> || val == <span class="string">&#x27;*&#x27;</span> || val == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">int</span> oper)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//用来存放结果</span></span><br><span class="line">        <span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res = num2 - num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前缀、中缀、后缀表达式"><a href="#前缀、中缀、后缀表达式" class="headerlink" title="前缀、中缀、后缀表达式"></a>前缀、中缀、后缀表达式</h2><h3 id="前缀表达式（波兰表达式）"><a href="#前缀表达式（波兰表达式）" class="headerlink" title="前缀表达式（波兰表达式）"></a>前缀表达式（波兰表达式）</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><ol>
<li>前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前</li>
<li>举例说明：(3+4)X5-6 对应的前缀表达式就是 - X + 3 4 5 6</li>
</ol>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>前缀表达式的计算机求值</strong></p>
<p>丛右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈项的两个数，用运算符对它们做相应的计算(栈顶元素和次顶元素)，并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p>
<p>例如：(3+4)X 5-6对应的前缀表达式就是 - X + 3 4 5 6，针对前缀表达式求值步骤如下：</p>
<ol>
<li>从右至左扫描，将6、5、4、3压入堆栈；</li>
<li>遇到+运算符，因此弹出3和4 (3为栈项元素，4为次顶元素)，计算出3+4的值，得7，再将7入栈；</li>
<li>接下来是X运算符，因此弹出7和5，计算出7X5&#x3D;35，将35入栈；</li>
<li>最后是 - 运算符，计算出35-6的值，即29， 由此得出最终结果。</li>
</ol>
<h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><ol>
<li>中缀表达式就是常见的运算表达式，如(3+4)X5-6；</li>
<li>中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作（前面我们讲的案例就能看的这个问题），因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作（一般转成后缀表达式）。</li>
</ol>
<h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><ol>
<li>后缀表达式又称逆波兰表达式与前缀表达式相似，只是运算符位于操作数之后；</li>
<li>中举例说明：(3+4)X5-6对应的后缀表达式就是3 4 + 5 X 6 -</li>
</ol>
<p><strong>后缀表达式的计算机求值</strong></p>
<p>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈项的两个数，用运算符对它们做相应的计算（次项元素和栈项元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p>
<p>例如：(3+4)X5-6对应的前缀表达式就是 3 4 + 5 X 6 -，针对后缀表达式求值步骤如下：</p>
<ol>
<li>从左至右扫描，将3和4压入堆栈；</li>
<li>遇到+运算符， 因此弹出4和3 (4为栈项元素，3为次顶元素)，计算出3+4的值，得7，再将7入栈；</li>
<li>将5入栈；</li>
<li>接下来是X运算符，因此弹出5和7，计算出7X5&#x3D;35，将35入栈； </li>
<li>将6入栈；</li>
<li>最后是 - 运算符，计算出35-6的值，即29，由此得出最终结果。</li>
</ol>
<h2 id="逆波兰计算器"><a href="#逆波兰计算器" class="headerlink" title="逆波兰计算器"></a>逆波兰计算器</h2><p>我们完成-一个逆波兰计算器，要求完成如下任务：</p>
<ol>
<li>输入一个逆波兰表达式，使用栈(Stack),计算其结果</li>
<li>支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。</li>
<li>思路分析</li>
<li>代码完成</li>
</ol>
<h3 id="思路分析-8"><a href="#思路分析-8" class="headerlink" title="思路分析"></a>思路分析</h3><p>详见后缀表达式</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//(3+4)×5-6   --&gt;    3 4 + 5 × 6 -</span></span><br><span class="line">        <span class="comment">//将逆波兰表达式的数字和符号用空格分开</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffExpression</span> <span class="operator">=</span> <span class="string">&quot;3 4 + 5 x 6 -&quot;</span>;</span><br><span class="line">        <span class="comment">//String suffExpression = &quot;4 5 x 8 - 60 + 8 2 / +&quot;;//4*5-8+60+8/2</span></span><br><span class="line">        <span class="comment">//将逆波兰表达式存放在ArrayList中</span></span><br><span class="line">        List&lt;String&gt; lst = getListString(suffExpression);</span><br><span class="line">        System.out.println(lst);</span><br><span class="line">        <span class="comment">//计算逆波兰表达式</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculate(lst);</span><br><span class="line">        System.out.println(<span class="string">&quot;逆波兰表达式的结果为:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式存放在ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String suffixExpression)</span> &#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        String[] arr = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String item : arr) &#123;</span><br><span class="line">            lst.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对逆波兰表达式的计算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; lst)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个栈</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String lst1 : lst) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lst1.matches(<span class="string">&quot;\\d+&quot;</span>))<span class="comment">//利用正则表达式来取值，匹配的是多位数</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(lst1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//弹出两个数进行运算</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (lst1.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lst1.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lst1.equals(<span class="string">&quot;x&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lst1.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1/ num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//res入栈</span></span><br><span class="line">                stack.push(<span class="string">&quot;&quot;</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中缀表达式转换为后缀表达式"><a href="#中缀表达式转换为后缀表达式" class="headerlink" title="中缀表达式转换为后缀表达式"></a>中缀表达式转换为后缀表达式</h2><p><strong>后缀表达式适合计算机式进行运算</strong>，但是却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将中缀表达式转成后缀表达式。</p>
<h3 id="思路分析-9"><a href="#思路分析-9" class="headerlink" title="思路分析"></a>思路分析</h3><ol>
<li>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</li>
<li>从左至右扫描中缀表达式；</li>
<li>遇到操作数时，将其压s2；</li>
<li>遇到运算符时，比较其与s1栈顶运算符的优先级：<ol>
<li>如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入s1；</li>
<li>否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</li>
</ol>
</li>
<li>遇到括号时：<ol>
<li>如果是左括号“(”，则直接压入s1；</li>
<li>如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃；</li>
</ol>
</li>
<li>重复步骤2至5，直到表达式的最右边；</li>
<li>将s1中剩余的运算符依次弹出并压入s2；</li>
<li>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式；</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211210201315199.png" alt="image-20211210201315199"></p>
<h3 id="核心方法实现"><a href="#核心方法实现" class="headerlink" title="核心方法实现"></a>核心方法实现</h3><p><strong>将中缀表达式转成对应的list</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">toInfixExpressionList</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个list，存放中缀表达式对应的内容</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//相当于一个指针，用于遍历中缀表达式字符串</span></span><br><span class="line">    String string;<span class="comment">//用于多位数拼接</span></span><br><span class="line">    <span class="type">char</span> c;<span class="comment">//每遍历到一个字符，就放到c中</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//如果是一个非数字，就需要加入到ls中</span></span><br><span class="line">        <span class="keyword">if</span> ((c = s.charAt(i)) &lt; <span class="number">48</span> || (c = s.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;&quot;</span> + c);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是一个数字，需要考虑多位数的问题</span></span><br><span class="line">            string = <span class="string">&quot;&quot;</span>;<span class="comment">//将string置空</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt; <span class="number">48</span> &amp;&amp; (c = s.charAt(i)) &lt; <span class="number">57</span>) &#123;</span><br><span class="line">                string += c;<span class="comment">//拼接</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; s.length());</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将得到的中缀表达式对应的list转换为对应的后缀表达式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">ParseSuffixExpressionList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    <span class="comment">//定义两个栈</span></span><br><span class="line">    <span class="comment">//定义一个栈用来装符号</span></span><br><span class="line">    Stack&lt;String&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();<span class="comment">//符号栈</span></span><br><span class="line">    <span class="comment">//因为在整个过程中，s2没有pop操作，并且在最终需要逆序输出，所以直接用List来代替</span></span><br><span class="line">    <span class="comment">//再定义一个List，用来存储中间结果</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">stack2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//存储中间结果的List</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历list</span></span><br><span class="line">    <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">        <span class="comment">//如果是一个数字，加入S2</span></span><br><span class="line">        <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">            stack2.add(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果是左括号“(”，则直接压入s1</span></span><br><span class="line">            stack1.push(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">            <span class="keyword">while</span> (!stack1.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            stack1.pop();<span class="comment">//将“（”弹出</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当item的优先级小于等于s1栈顶的运算符，将s1栈顶的元素运算符弹出并压到s2中，在此转到（4,1）与s1中新的栈顶运算符相比较</span></span><br><span class="line">            <span class="comment">//问题：我们缺少一个比较优先级高低的方法</span></span><br><span class="line">            <span class="comment">//Operation：用于比较运算符优先级高低</span></span><br><span class="line">            <span class="keyword">while</span> (stack1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(stack1.peek()) &gt;= Operation.getValue(item)) &#123;</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//还需要将item压入栈</span></span><br><span class="line">            stack1.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将s1中剩余的运算符一次弹出并加入到s2</span></span><br><span class="line">    <span class="keyword">while</span> (stack1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        stack2.add(stack1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编写一个Operation类，可以返回一个运算符对应的优先级</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SUB</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MUL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DIV</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String operation)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;x&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;不存在该运算符&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将中缀表达式转成对应的list</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;(3+4)x5-6&quot;</span>;</span><br><span class="line">    List&lt;String&gt; infisExpressionList = toInfixExpressionList(expression);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; parseSuffixExpressionList = ParseSuffixExpressionList(infisExpressionList);</span><br><span class="line"></span><br><span class="line">    System.out.println(parseSuffixExpressionList);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculate(parseSuffixExpressionList);</span><br><span class="line">    System.out.println(<span class="string">&quot;结果为:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将中缀表达式转成对应的list</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;(3+4)x5-6&quot;</span>;</span><br><span class="line">        List&lt;String&gt; infisExpressionList = toInfixExpressionList(expression);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; parseSuffixExpressionList = ParseSuffixExpressionList(infisExpressionList);</span><br><span class="line"></span><br><span class="line">        System.out.println(parseSuffixExpressionList);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculate(parseSuffixExpressionList);</span><br><span class="line">        System.out.println(<span class="string">&quot;逆波兰表达式的结果为:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//(3+4)×5-6   --&gt;    3 4 + 5 × 6 -</span></span><br><span class="line">        <span class="comment">//将逆波兰表达式的数字和符号用空格分开</span></span><br><span class="line">        <span class="comment">//String suffExpression = &quot;3 4 + 5 x 6 -&quot;;</span></span><br><span class="line">        <span class="comment">//String suffExpression = &quot;4 5 x 8 - 60 + 8 2 / +&quot;;//4*5-8+60+8/2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将逆波兰表达式存放在ArrayList中</span></span><br><span class="line">        <span class="comment">//List&lt;String&gt; lst = getListString(suffExpression);</span></span><br><span class="line">        <span class="comment">//System.out.println(lst);</span></span><br><span class="line">        <span class="comment">//计算逆波兰表达式</span></span><br><span class="line">        <span class="comment">//int result = calculate(parseSuffixExpressionList);</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;逆波兰表达式的结果为:&quot; + result);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将得到的中缀表达式对应的list转换为对应的后缀表达式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">ParseSuffixExpressionList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//定义两个栈</span></span><br><span class="line">        <span class="comment">//定义一个栈用来装符号</span></span><br><span class="line">        Stack&lt;String&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();<span class="comment">//符号栈</span></span><br><span class="line">        <span class="comment">//因为在整个过程中，s2没有pop操作，并且在最终需要逆序输出，所以直接用List来代替</span></span><br><span class="line">        <span class="comment">//再定义一个List，用来存储中间结果</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">stack2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//存储中间结果的List</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历list</span></span><br><span class="line">        <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">            <span class="comment">//如果是一个数字，加入S2</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">                stack2.add(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果是左括号“(”，则直接压入s1</span></span><br><span class="line">                stack1.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">                <span class="keyword">while</span> (!stack1.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                    stack2.add(stack1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                stack1.pop();<span class="comment">//将“（”弹出</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当item的优先级小于等于s1栈顶的运算符，将s1栈顶的元素运算符弹出并压到s2中，在此转到（4,1）与s1中新的栈顶运算符相比较</span></span><br><span class="line">                <span class="comment">//问题：我们缺少一个比较优先级高低的方法</span></span><br><span class="line">                <span class="comment">//Operation：用于比较运算符优先级高低</span></span><br><span class="line">                <span class="keyword">while</span> (stack1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(stack1.peek()) &gt;= Operation.getValue(item)) &#123;</span><br><span class="line">                    stack2.add(stack1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//还需要将item压入栈</span></span><br><span class="line">                stack1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1中剩余的运算符一次弹出并加入到s2</span></span><br><span class="line">        <span class="keyword">while</span> (stack1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            stack2.add(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将中缀表达式转成对应的list</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">toInfixExpressionList</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个list，存放中缀表达式对应的内容</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//相当于一个指针，用于遍历中缀表达式字符串</span></span><br><span class="line">        String string;<span class="comment">//用于多位数拼接</span></span><br><span class="line">        <span class="type">char</span> c;<span class="comment">//每遍历到一个字符，就放到c中</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//如果是一个非数字，就需要加入到ls中</span></span><br><span class="line">            <span class="keyword">if</span> ((c = s.charAt(i)) &lt; <span class="number">48</span> || (c = s.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;&quot;</span> + c);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是一个数字，需要考虑多位数的问题</span></span><br><span class="line">                string = <span class="string">&quot;&quot;</span>;<span class="comment">//将string置空</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt; <span class="number">48</span> &amp;&amp; (c = s.charAt(i)) &lt; <span class="number">57</span>) &#123;</span><br><span class="line">                    string += c;<span class="comment">//拼接</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; s.length());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对逆波兰表达式的计算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; lst)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个栈</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String lst1 : lst) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lst1.matches(<span class="string">&quot;\\d+&quot;</span>))<span class="comment">//利用正则表达式来取值，匹配的是多位数</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(lst1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//弹出两个数进行运算</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (lst1.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lst1.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lst1.equals(<span class="string">&quot;x&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lst1.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//res入栈</span></span><br><span class="line">                stack.push(<span class="string">&quot;&quot;</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个Operation类，可以返回一个运算符对应的优先级</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SUB</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MUL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DIV</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String operation)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;x&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;不存在该运算符&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归就是方法自己调用自己，每次调用时传入不同的变量，<strong>递归有助于编程者解决复杂的问题</strong>，同时可以让代码变得简洁。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211210214042841.png" alt="image-20211210214042841"></p>
<p><strong>递归调用规则：</strong></p>
<ol>
<li><p>**当程序执行到一个方法时，就会开辟一个独立的空间(栈)**。</p>
</li>
<li><p><strong>每个空间的数据(局部变量)，是独立的。</strong></p>
</li>
</ol>
<p><strong>递归能解决什么样的问题</strong></p>
<ol>
<li>各种数学问题如:8 皇后问题，汉诺塔,阶乘问题，迷宫问题，球和篮子的问题(google编程大赛)。</li>
<li>各 种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等。</li>
<li>将用栈解决的问题转换为用归代码，比较简洁。</li>
</ol>
<p><strong>递归需要遵守的重要规则</strong></p>
<ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）；</li>
<li>方法的局部变量是独立的，不会相互影响，比如n变量；</li>
<li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据；</li>
<li>递归必须向退出递归的条件逼近， 否则就是无限递归，出现栈溢出（StackOverflowError），死龟了:)</li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ol>
<h2 id="迷宫回溯"><a href="#迷宫回溯" class="headerlink" title="迷宫回溯"></a>迷宫回溯</h2><ol>
<li>小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右的顺序相关</li>
<li>再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化</li>
<li>测试回溯现象</li>
<li><strong>思考: 如何求出最短路径?</strong><ul>
<li>采取不同策略，将结果用list集合存起来，然后将不同策略算出的不同结果进行比较。</li>
</ul>
</li>
</ol>
<h3 id="思路分析-10"><a href="#思路分析-10" class="headerlink" title="思路分析"></a>思路分析</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211211000004332.png" alt="image-20211211000004332"></p>
<ol>
<li>map 表示地图；</li>
<li>i,j 表示从地图的哪个位置开始出发 (1,1)；</li>
<li>如果小球能到 map[6][5] 位置，则说明通路找到；</li>
<li>约定： 当map[i][j] 为 0 表示该点没有走过； 当为 1 表示墙  ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通；</li>
<li>在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯；</li>
</ol>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiGong</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先创建一个二维数组，模拟迷宫地图。</span></span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">// 使用 1 表示墙。</span></span><br><span class="line">        <span class="comment">// 第一行和最后一行全部置为 1 。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一列和最后一列全部置为 1 。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置挡板, 用 1 表示。</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出地图。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;地图的情况~~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用递归回溯给小球找路。</span></span><br><span class="line">        setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 输出新的地图, 小球走过，并标识过的递归。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;迷宫问题路径地图的情况~~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路。</span></span><br><span class="line">    <span class="comment">//说明：</span></span><br><span class="line">    <span class="comment">//1. map 表示地图</span></span><br><span class="line">    <span class="comment">//2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line">    <span class="comment">//3. 如果小球能到 map[6][5] 位置，则说明通路找到</span></span><br><span class="line">    <span class="comment">//4. 约定： 当map[i][j] 为 0 表示该点没有走过； 当为 1 表示墙  ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通。</span></span><br><span class="line">    <span class="comment">//5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下右上左</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i   从哪个位置开始找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到通路，就返回true, 否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay</span><span class="params">(<span class="type">int</span>[][] map, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;   <span class="comment">// 通路已经找到，返回true。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;   <span class="comment">// 如果当前这个点还没有走过, 按照策略 下-&gt;右-&gt;上-&gt;左 走。</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>;  <span class="comment">// 假定该点是可以走通。</span></span><br><span class="line">                <span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j)) &#123;    <span class="comment">// 向下走。</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j + <span class="number">1</span>)) &#123; <span class="comment">// 向右走。</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>, j)) &#123; <span class="comment">// 向上走。</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>)) &#123; <span class="comment">// 向左走。</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 说明该点是走不通，是死路。</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上-&gt;右-&gt;下-&gt;左 的策略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到通路，就返回true, 否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay2</span><span class="params">(<span class="type">int</span>[][] map, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123; <span class="comment">// 通路已找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123; <span class="comment">// 如果当前这个点还没有走过</span></span><br><span class="line">                <span class="comment">// 按照策略 上-&gt;右-&gt;下-&gt;左</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>; <span class="comment">// 假定该点是可以走通.</span></span><br><span class="line">                <span class="keyword">if</span> (setWay2(map, i - <span class="number">1</span>, j)) &#123;        <span class="comment">// 向上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j + <span class="number">1</span>)) &#123; <span class="comment">// 向右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i + <span class="number">1</span>, j)) &#123; <span class="comment">// 向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j - <span class="number">1</span>)) &#123; <span class="comment">// 向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 说明该点是走不通，是死路</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211210235853548.png" alt="image-20211210235853548"></p>
<h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：<strong>任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法</strong>。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211211000353208.png" alt="image-20211211000353208"></p>
<h3 id="思路分析-11"><a href="#思路分析-11" class="headerlink" title="思路分析"></a>思路分析</h3><ol>
<li>第一个皇后先放第一行第一列</li>
<li>第二个皇后放在第二行第一列、然后判断是否发生冲突。 如果有冲突，就把它放在第二列、第三列、依次把所有列都放完，找到一个合适的位置</li>
<li>继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置。这就算是找到了一个正确解</li>
<li>当得到一个正确解时，就继续改变皇后的位置（即：除第一个皇后外的每一个皇后，把在每一个位置上的所有情况全部运行一遍），继续回溯。直到将第一个皇后，在第一列上时，所有出现的正确解，全部得到</li>
<li>然后从头重新开始，将第一个皇后放在第二列，后面继续循环执行 1,2,3,4的步骤</li>
</ol>
<p>说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题。</p>
<p>arr[8]&#x3D;{0,4,7,5,2,6,1,3}&#x2F;&#x2F;对应arr下标，表示第i+1个皇后在第i+1行的a[i]列</p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EightQueue</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个max：表示共有多少个皇后</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义数组array, 保存皇后放置位置的结果</span></span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[max];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">judgeCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//运行</span></span><br><span class="line">        <span class="type">EightQueue</span> <span class="variable">queue8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EightQueue</span>();</span><br><span class="line">        queue8.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;一共有&quot;</span> + count + <span class="string">&quot;解法&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;一共判断冲突的次数&quot;</span> + judgeCount + <span class="string">&quot;次&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个方法，放置第n个皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 表示第几个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == max) &#123;  <span class="comment">//n = 8 时，证明8个皇后都放好位置</span></span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">//先把当前这个皇后 n , 放到该行的第1列</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (judge(n)) &#123; <span class="comment">// 不冲突</span></span><br><span class="line">                <span class="comment">//接着放下一个皇后,即开始递归</span></span><br><span class="line">                check(n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        judgeCount++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; n; a++) &#123;</span><br><span class="line">            <span class="comment">//说明</span></span><br><span class="line">            <span class="comment">//array[i] == array[n]  判断第n个皇后是否和前面的皇后在同一列</span></span><br><span class="line">            <span class="comment">//Math.abs(n-i) == Math.abs(array[n] - array[i]) 判断第n个皇后是否和第a个皇后在同一斜线</span></span><br><span class="line">            <span class="comment">//横坐标相减是否等于纵坐标相减</span></span><br><span class="line">            <span class="comment">//一维数组， 判断是否在同一行, 没有必要</span></span><br><span class="line">            <span class="keyword">if</span> (array[a] == array[n] || Math.abs(n - a) == Math.abs(array[n] - array[a])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 4 7 5 2 6 1 3 </span><br><span class="line">0 5 7 2 6 3 1 4 </span><br><span class="line">0 6 3 5 7 1 4 2 </span><br><span class="line">0 6 4 7 1 3 5 2 </span><br><span class="line">1 3 5 7 2 0 6 4 </span><br><span class="line">1 4 6 0 2 7 5 3 </span><br><span class="line">1 4 6 3 0 7 5 2 </span><br><span class="line">1 5 0 6 3 7 2 4 </span><br><span class="line">1 5 7 2 0 3 6 4 </span><br><span class="line">1 6 2 5 7 4 0 3 </span><br><span class="line">1 6 4 7 0 3 5 2 </span><br><span class="line">1 7 5 0 2 4 6 3 </span><br><span class="line">2 0 6 4 7 1 3 5 </span><br><span class="line">2 4 1 7 0 6 3 5 </span><br><span class="line">2 4 1 7 5 3 6 0 </span><br><span class="line">2 4 6 0 3 1 7 5 </span><br><span class="line">2 4 7 3 0 6 1 5 </span><br><span class="line">2 5 1 4 7 0 6 3 </span><br><span class="line">2 5 1 6 0 3 7 4 </span><br><span class="line">2 5 1 6 4 0 7 3 </span><br><span class="line">2 5 3 0 7 4 6 1 </span><br><span class="line">2 5 3 1 7 4 6 0 </span><br><span class="line">2 5 7 0 3 6 4 1 </span><br><span class="line">2 5 7 0 4 6 1 3 </span><br><span class="line">2 5 7 1 3 0 6 4 </span><br><span class="line">2 6 1 7 4 0 3 5 </span><br><span class="line">2 6 1 7 5 3 0 4 </span><br><span class="line">2 7 3 6 0 5 1 4 </span><br><span class="line">3 0 4 7 1 6 2 5 </span><br><span class="line">3 0 4 7 5 2 6 1 </span><br><span class="line">3 1 4 7 5 0 2 6 </span><br><span class="line">3 1 6 2 5 7 0 4 </span><br><span class="line">3 1 6 2 5 7 4 0 </span><br><span class="line">3 1 6 4 0 7 5 2 </span><br><span class="line">3 1 7 4 6 0 2 5 </span><br><span class="line">3 1 7 5 0 2 4 6 </span><br><span class="line">3 5 0 4 1 7 2 6 </span><br><span class="line">3 5 7 1 6 0 2 4 </span><br><span class="line">3 5 7 2 0 6 4 1 </span><br><span class="line">3 6 0 7 4 1 5 2 </span><br><span class="line">3 6 2 7 1 4 0 5 </span><br><span class="line">3 6 4 1 5 0 2 7 </span><br><span class="line">3 6 4 2 0 5 7 1 </span><br><span class="line">3 7 0 2 5 1 6 4 </span><br><span class="line">3 7 0 4 6 1 5 2 </span><br><span class="line">3 7 4 2 0 6 1 5 </span><br><span class="line">4 0 3 5 7 1 6 2 </span><br><span class="line">4 0 7 3 1 6 2 5 </span><br><span class="line">4 0 7 5 2 6 1 3 </span><br><span class="line">4 1 3 5 7 2 0 6 </span><br><span class="line">4 1 3 6 2 7 5 0 </span><br><span class="line">4 1 5 0 6 3 7 2 </span><br><span class="line">4 1 7 0 3 6 2 5 </span><br><span class="line">4 2 0 5 7 1 3 6 </span><br><span class="line">4 2 0 6 1 7 5 3 </span><br><span class="line">4 2 7 3 6 0 5 1 </span><br><span class="line">4 6 0 2 7 5 3 1 </span><br><span class="line">4 6 0 3 1 7 5 2 </span><br><span class="line">4 6 1 3 7 0 2 5 </span><br><span class="line">4 6 1 5 2 0 3 7 </span><br><span class="line">4 6 1 5 2 0 7 3 </span><br><span class="line">4 6 3 0 2 7 5 1 </span><br><span class="line">4 7 3 0 2 5 1 6 </span><br><span class="line">4 7 3 0 6 1 5 2 </span><br><span class="line">5 0 4 1 7 2 6 3 </span><br><span class="line">5 1 6 0 2 4 7 3 </span><br><span class="line">5 1 6 0 3 7 4 2 </span><br><span class="line">5 2 0 6 4 7 1 3 </span><br><span class="line">5 2 0 7 3 1 6 4 </span><br><span class="line">5 2 0 7 4 1 3 6 </span><br><span class="line">5 2 4 6 0 3 1 7 </span><br><span class="line">5 2 4 7 0 3 1 6 </span><br><span class="line">5 2 6 1 3 7 0 4 </span><br><span class="line">5 2 6 1 7 4 0 3 </span><br><span class="line">5 2 6 3 0 7 1 4 </span><br><span class="line">5 3 0 4 7 1 6 2 </span><br><span class="line">5 3 1 7 4 6 0 2 </span><br><span class="line">5 3 6 0 2 4 1 7 </span><br><span class="line">5 3 6 0 7 1 4 2 </span><br><span class="line">5 7 1 3 0 6 4 2 </span><br><span class="line">6 0 2 7 5 3 1 4 </span><br><span class="line">6 1 3 0 7 4 2 5 </span><br><span class="line">6 1 5 2 0 3 7 4 </span><br><span class="line">6 2 0 5 7 4 1 3 </span><br><span class="line">6 2 7 1 4 0 5 3 </span><br><span class="line">6 3 1 4 7 0 2 5 </span><br><span class="line">6 3 1 7 5 0 2 4 </span><br><span class="line">6 4 2 0 5 7 1 3 </span><br><span class="line">7 1 3 0 6 4 2 5 </span><br><span class="line">7 1 4 2 0 6 3 5 </span><br><span class="line">7 2 0 5 1 4 6 3 </span><br><span class="line">7 3 0 2 5 1 6 4 </span><br><span class="line">一共有92解法</span><br><span class="line"></span><br><span class="line">一共判断冲突的次数15720次</span><br></pre></td></tr></table></figure>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序也称排序算法(Sort Algorithm)， 排序是将一组数据，依指定的顺序进行排列的过程。</p>
<p><strong>排序的分类</strong></p>
<ol>
<li><p>内部排序：</p>
<ul>
<li>指将需要处理的所有数据都加载到<strong>内部存储器（内存）</strong>中进行排序。</li>
</ul>
</li>
<li><p>外部排序法：</p>
<ul>
<li><strong>数据量过大</strong>，无法全部加载到内存中，需要借助外部存储进行排序。</li>
</ul>
</li>
<li><p>常见的排序算法分类</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211212130931507.png" alt="image-20211212130931507"></p>
</li>
</ol>
<h2 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h2><p>度量一个程序(算法)执行时间的两种方法</p>
<ol>
<li>事后统计的方法<ul>
<li>这种方法可行，但是有两个问题: <ul>
<li>一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；</li>
<li>二是所得时间的统计量依赖于计算机的硬件、软件等环境因素,这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</li>
</ul>
</li>
</ul>
</li>
<li>事前估算的方法<ul>
<li>通过分析某个算法的时间复杂度来判断哪个算法更优。</li>
</ul>
</li>
</ol>
<h3 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h3><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。<strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为T(n)。</p>
<p><strong>举例说明</strong></p>
<p>计算1-100所有数字之和，我们设计两种算法：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211212132705753.png" alt="image-20211212132705753"></p>
<p><strong>特点</strong></p>
<p>随着n的增大，可以忽略常数项、忽略低次项、忽略系数</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol>
<li>一般情况下，<strong>算法中的基本操作语句的重复执行次数是问题规模n的某个函数</strong>，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) &#x2F;f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。 记作T(n)&#x3D; 0(f(n))，称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</li>
<li>T(n)不同，但时间复杂度可能相同。如: T(n)&#x3D;n<sup>2</sup>+7n+6与T(n)&#x3D;3n<sup>2</sup>+2n+2它们的T(n)不同，但时间复杂度相同，都为0(n<sup>2</sup>)。</li>
<li>计算时间复杂度的方法:<ul>
<li>用常数1代替运行时间中的所有加法常数T(n)&#x3D;n<sup>2</sup>+7n+6 &#x3D;&gt;T(n)&#x3D;n<sup>2</sup>+7n+1</li>
<li>修改后的运行次数函数中，只保留最高阶项T(n)&#x3D;n<sup>2</sup>+7n+1&#x3D;&gt;T(n)&#x3D;n2<sup>2</sup></li>
<li>去除最高阶项的系数T(n)&#x3D;n<sup>2</sup>&#x3D;&gt; T(n)&#x3D; n<sup>2</sup> &#x3D;&gt; O(n<sup>2</sup>)</li>
</ul>
</li>
</ol>
<p><strong>平均时间复杂度和最坏时间复杂度</strong></p>
<ol>
<li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</li>
<li>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</li>
<li>平均时间复杂度和最坏时间复杂度是否一致，和算法有关。</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211212135106225.png" alt="image-20211212135106225"></p>
<p><strong>常见的时间复杂度</strong></p>
<p>常数阶O(1)</p>
<p>对数阶O(log<sub>2</sub>n)</p>
<p>线性阶O(n)</p>
<p>线性对数阶0(nlog<sub>2</sub>n)</p>
<p>平方阶O(n<sup>2</sup>)</p>
<p>立方阶O(n<sup>3</sup>)</p>
<p>k次方阶O(n<sup>k</sup>)</p>
<p>指数阶0(2<sup>n</sup>)</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211212141133300.png" alt="image-20211212141133300"></p>
<ul>
<li><p>常见的算法时间复杂度由小到大依次为: O(1)&lt;O(log<sub>2</sub>n)&lt;O(n) &lt;O(nlog<sub>2</sub>n)&lt;O(n<sup>2</sup>)&lt;O(n<sup>3</sup>)&lt; O(n<sup>k</sup>) &lt;O(2<sup>n</sup>)， 随着问题规模n的不断增大， 上述时间复杂度不断增大，算法的执行效率越低</p>
</li>
<li><p>从图中可见，我们应该尽可能避免使用指数阶的算法</p>
</li>
</ul>
<h3 id="时间复杂度举例"><a href="#时间复杂度举例" class="headerlink" title="时间复杂度举例"></a>时间复杂度举例</h3><h4 id="常数阶O-1"><a href="#常数阶O-1" class="headerlink" title="常数阶O(1)"></a>常数阶O(1)</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211212141705536.png" alt="image-20211212141705536"></p>
<h4 id="对数阶O-log2n"><a href="#对数阶O-log2n" class="headerlink" title="对数阶O(log2n)"></a>对数阶O(log<sub>2</sub>n)</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211212142108281.png" alt="image-20211212142108281"></p>
<h4 id="线性阶O-n"><a href="#线性阶O-n" class="headerlink" title="线性阶O(n)"></a>线性阶O(n)</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211212142141613.png" alt="image-20211212142141613"></p>
<h4 id="线性对数阶0-nlog2n"><a href="#线性对数阶0-nlog2n" class="headerlink" title="线性对数阶0(nlog2n)"></a>线性对数阶0(nlog<sub>2</sub>n)</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211212142008959.png" alt="image-20211212142008959"></p>
<h4 id="平方阶O-n2"><a href="#平方阶O-n2" class="headerlink" title="平方阶O(n2)"></a>平方阶O(n<sup>2</sup>)</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211212142312809.png" alt="image-20211212142312809"></p>
<h4 id="立方阶O-n3-、k次方阶O-nk"><a href="#立方阶O-n3-、k次方阶O-nk" class="headerlink" title="立方阶O(n3)、k次方阶O(nk)"></a>立方阶O(n<sup>3</sup>)、k次方阶O(n<sup>k</sup>)</h4><p>说明:参考上面的O(n<sup>2</sup>)去理解就好了，O(n<sup>3</sup>)相当于三层n循环，其它的类似</p>
<h4 id="指数阶0-2n"><a href="#指数阶0-2n" class="headerlink" title="指数阶0(2n)"></a>指数阶0(2<sup>n</sup>)</h4><h3 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h3><ol>
<li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是间题规模n的函数。</li>
<li>空间复杂度(Space Complexity)是对一个 算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。</li>
<li>在做算法分析时，<strong>主要讨论的是时间复杂度</strong>。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。</li>
</ol>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h3><p>通过对待排序序列从前向后（从下标较小的元素开始）,<strong>依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部</strong>，就象水底下的气泡一样逐渐向上冒。</p>
<p>因为排序的过程中，各元素不断接近自己的位置，<strong>如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换</strong>。从而减少不必要的比较。</p>
<h3 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h3><ol>
<li>一共进行 数组的大小-1 次的循环</li>
<li>每一趟排序的次数在逐渐的减少</li>
<li>如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。</li>
</ol>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序      时间复杂度为O(n^2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//临时变量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标识变量 表示没发生交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;<span class="comment">//i表示当前是第i+1趟排序</span></span><br><span class="line">        <span class="comment">//第i+1趟排序就是把第i+1大的数放在倒数第i+1的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//在一趟排序中一次交换也没发生 则说明数组已经有序 break即可</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;<span class="comment">//重置flag 进行下一次标识</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="排序思想-1"><a href="#排序思想-1" class="headerlink" title="排序思想"></a>排序思想</h3><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p>
<p>第一次从arr[0] 到arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]到arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]到arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]到arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。</p>
<h3 id="排序规则-1"><a href="#排序规则-1" class="headerlink" title="排序规则"></a>排序规则</h3><ol>
<li>选择排序一共有 数组大小 -1 次的排序</li>
<li>每1轮排序，又是一个循环，循环的规则<ol>
<li>先假定当前这个数是最小数</li>
<li>然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标</li>
<li>当遍历到数组的最后时，就得到本轮最小数和下标</li>
<li>交换</li>
</ol>
</li>
</ol>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序      时间复杂度为O(n^2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;<span class="comment">//第一轮默认最小值下标是0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[i];<span class="comment">//第一轮默认最小值为第一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; arr[j]) &#123;       <span class="comment">//如果按从大到小排序则改成min &lt; arr[j]即可</span></span><br><span class="line">                min = arr[j];<span class="comment">//重置最小值</span></span><br><span class="line">                minIndex = j;<span class="comment">//重置最小值下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换  优化：如果最小值没变化就不必交换</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            arr[minIndex] = arr[i]; <span class="comment">//arr[0]=101-&gt;arr[3]=101</span></span><br><span class="line">            arr[i] = min;<span class="comment">//arr[0]=101-&gt;arr[0]=1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="排序思想-2"><a href="#排序思想-2" class="headerlink" title="排序思想"></a>排序思想</h3><p>把n个待排序的元素看成为一个有序表和一个无序表，<strong>开始时有序表中只包含一个元素，无序表中包含有n-1个元素，</strong>排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211216145845379.png" alt="image-20211216145845379"></p>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//待插入的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;<span class="comment">//开始操作无序表</span></span><br><span class="line">            insertVal = arr[i];<span class="comment">//待插入的数</span></span><br><span class="line">            insertIndex = i - <span class="number">1</span>;<span class="comment">//带插入位置的索引 插入到前一位 所以-1（有序表的下标）</span></span><br><span class="line">            <span class="comment">//说明：1、insertIndex &gt;= 0 保证在给insertIndex找插入位置时不越界</span></span><br><span class="line">            <span class="comment">//     2、insertVal &lt; arr[insertIndex] 说明还没找到插入位置</span></span><br><span class="line">            <span class="comment">//     3、需要将arr[insertIndex]后移</span></span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;<span class="comment">//退出循环时 表示已经找到要插入的位置</span></span><br><span class="line">            <span class="keyword">if</span> (insertIndex + <span class="number">1</span> != i) &#123;<span class="comment">//优化：如果找的的要插入位置就是其本身所在位置 则无需再赋值</span></span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// System.out.println(&quot;第&quot; + i + &quot;轮插入排序后：&quot; + Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="排序思想-3"><a href="#排序思想-3" class="headerlink" title="排序思想"></a>排序思想</h3><p>希尔排序也是一种插入排序，他是简单插入排序经过改进后的一个更高效的版本，也被称为<strong>缩小增量排序</strong>。</p>
<p>希尔排序是把记录<strong>按下标的一定增量分组</strong>，对<strong>每组使用直接插入排序算法排序</strong>；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止<br>思路分析：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211212225301053.png" alt="image-20211212225301053"></p>
<h3 id="代码实现——交换法"><a href="#代码实现——交换法" class="headerlink" title="代码实现——交换法"></a>代码实现——交换法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序-----交换法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//增量gap  逐渐缩小增量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历各组中所有的元素，共gap组，每一组有2^n/2^n+1个元素.步长为gap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                <span class="comment">//a[j]表示要和a[i]比较的那个数字，例如：10个数字时。i=5,j=0,下面就是a[0]和a[5]比较</span></span><br><span class="line">                <span class="comment">//如果当前元素大于加上步长后的那个元素交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + gap];</span><br><span class="line">                    arr[j + gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//System.out.println(&quot;第&quot; + (++count) + &quot;轮希尔排序的后：&quot; + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码实现——位移法（改进，引入了插入排序）"><a href="#代码实现——位移法（改进，引入了插入排序）" class="headerlink" title="代码实现——位移法（改进，引入了插入排序）"></a>代码实现——位移法（改进，引入了插入排序）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序-----移位法（对交换法进行优化  速度快了）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//从第gap个元素开始 逐个对其所在组进行直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//直接插入排序</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;<span class="comment">//保存待插入位置的下标 类似insertIndex</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];<span class="comment">//保存要插入的数据 类似insertVal</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">                    <span class="comment">//移动</span></span><br><span class="line">                    arr[j] = arr[j - gap];</span><br><span class="line">                    j -= gap;<span class="comment">//步长为gap</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//退出while循环后就表示找到了插入的位置</span></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="排序思想-4"><a href="#排序思想-4" class="headerlink" title="排序思想"></a>排序思想</h3><p>快速排序（Quicksort）是对<strong>冒泡排序的一种改进</strong>。基本思想是：通过一趟排序将要排序的数据分割成<strong>独立的两部分</strong>，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<strong>递归</strong>进行，以此达到整个数据变成有序序列。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211213000009658.png" alt="image-20211213000009658"></p>
<h3 id="排序规则-2"><a href="#排序规则-2" class="headerlink" title="排序规则"></a>排序规则</h3><ol>
<li>选定Pivot中心轴</li>
<li>将大于Pivot的数字放在Pivot的右边</li>
<li>将小于Pivot的数字放在Pivot的左边</li>
<li>分别对左右子序列重复前三步操作</li>
</ol>
<h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;<span class="comment">//左下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;<span class="comment">//右下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(left + right) / <span class="number">2</span>];<span class="comment">//中缀</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于交换的临时变量</span></span><br><span class="line">    <span class="comment">//while循环的目的是让比prvot值小的放到左边，比prvot值大的放到右边</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//l和r交替移动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在pivot的左边一直找，找到大于等于pivot的值，才退出（左边的数字要确保小于pivot）</span></span><br><span class="line">        <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在pivot的右边一直找，找到小于等于pivot的值，才退出（右边的数字要确保大于pivot）</span></span><br><span class="line">        <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果l &gt;= r，说明pivot左右两边的值已经被划分开</span></span><br><span class="line">        <span class="comment">//左边的都是小于pivot的值，右边的都是大于pivot的值</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在满足l &gt;= r之前，就继续进行左右交换</span></span><br><span class="line">        temp = arr[l];</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        arr[r] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当左右两边中，任意一边有值等于pivot时，确保另一边继续进行，直到循环结束</span></span><br><span class="line">        <span class="comment">//如果交换完后，发现arr[l] == pivot，就对r进行--操作（前移一步）</span></span><br><span class="line">        <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果交换完后，发现arr[r] == pivot，就对l进行++操作（后移一步）</span></span><br><span class="line">        <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果l==r，必须l++，r--，否则会栈溢出（当l==r时，相当于两个数都指向pivot，所以一直在原值交换）</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        l += <span class="number">1</span>;</span><br><span class="line">        r -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左递归</span></span><br><span class="line">    <span class="keyword">if</span>(left&lt;r)&#123;</span><br><span class="line">        quickSort2(arr,left,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右递归</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;right)&#123;</span><br><span class="line">        quickSort2(arr,l,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="comment">//将数组中的第0个数字 设置为基准数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        <span class="comment">//记录需要排序的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//右边的数比基准数大 则向左移动right指针</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="comment">//退出此while循环说明当前arr[right]&lt;pivot</span></span><br><span class="line">            arr[left] = arr[right];<span class="comment">//用right位的数覆盖left位的数</span></span><br><span class="line">            <span class="comment">//左边的数比基准数小 则向右移动low指针</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="comment">//退出此while循环说明当前arr[left]&gt;pivot</span></span><br><span class="line">            arr[right] = arr[left];<span class="comment">//用left位的数覆盖right位的数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//left和right指针相遇时 将基准数赋给此下标处</span></span><br><span class="line">        arr[left] = pivot;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;第一次快速排序后的数组为：&quot; + Arrays.toString(arr));</span></span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="comment">//处理所有比基准数小的数字</span></span><br><span class="line">        quickSort(arr, start, left);</span><br><span class="line">        <span class="comment">//处理所有比基准数大的数字</span></span><br><span class="line">        quickSort(arr, left + <span class="number">1</span>, end);<span class="comment">//因为left是基准数，所以需要从+1项开始递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="排序思想-5"><a href="#排序思想-5" class="headerlink" title="排序思想"></a>排序思想</h3><p>归并排序（MERGE-SORT）是利用<strong>归并的思想</strong>实现的排序方法，该算法采用经典的<strong>分治（divide-and-conquer）策略</strong>（分治法将问题&#x3D;&#x3D;<strong>分</strong>&#x3D;&#x3D;(divide)成一些小的问题然后递归求解，而&#x3D;&#x3D;<strong>治</strong>&#x3D;&#x3D;(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211213004254111.png" alt="image-20211213004254111"></p>
<p><strong>说明</strong></p>
<p>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现(也可采用迭代的方式去实现)。分阶段可以理解为就是递归拆分子序列的过程。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211213004320936.png" alt="image-20211213004320936"></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211213004345110.png" alt="image-20211213004345110"></p>
<h3 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//向左递归分解</span></span><br><span class="line">            mergeSort(arr, <span class="number">0</span>, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归分解</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merge(arr, left, right, mid, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   需要排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid   中间索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp  做中转的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> mid, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;<span class="comment">//初始化i，左边有序序列的初始索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;<span class="comment">//初始化k，右边有序序列的初始索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指向temp数组的当前索引</span></span><br><span class="line">    <span class="comment">//1、先把左右两边数组按照规则填充到temp数组</span></span><br><span class="line">    <span class="comment">// 直到左右两边的有序序列有一边处理完毕</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//若左边序列的当前元素&lt;=右边序列的当前元素</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;<span class="comment">//将左边的填充到temp中</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t+=<span class="number">1</span>;</span><br><span class="line">            i+=<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//将右边的填充到temp中</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t+=<span class="number">1</span>;</span><br><span class="line">            j+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//两种情况退出当前while循环</span></span><br><span class="line">    <span class="comment">//2、把有剩余元素的一边的数据依次全部填充到temp</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;<span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp中</span></span><br><span class="line">        temp[t] = arr[i];</span><br><span class="line">        t+=<span class="number">1</span>;</span><br><span class="line">        i+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;<span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp中</span></span><br><span class="line">        temp[t] = arr[j];</span><br><span class="line">        t+=<span class="number">1</span>;</span><br><span class="line">        j+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、将temp数组的元素拷贝到arr </span></span><br><span class="line">    <span class="comment">//注意：并不是每次都拷贝所有</span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tempLeft</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">while</span> (tempLeft &lt;= right) &#123;<span class="comment">//根据合并的次数，每一次的都是不一样的。</span></span><br><span class="line">        <span class="comment">//第一轮 0,1  2,3  4,5 6，7 第二轮 0,3  4,7  第三轮  0,7       </span></span><br><span class="line">        arr[tempLeft] = temp[t];</span><br><span class="line">        t+=<span class="number">1</span>;</span><br><span class="line">        tempLeft+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="排序思想-6"><a href="#排序思想-6" class="headerlink" title="排序思想"></a>排序思想</h3><p>基数排序（radix sort）属于“<strong>分配式排序</strong>”（distribution sort），又称“<strong>桶子法</strong>”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的<strong>元素分配</strong>至某些“桶”中，达到排序的作用，<strong>是桶排序的扩展</strong>。</p>
<p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法。</p>
<p>基本思想：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，<strong>从最低位开始，依次进行一次排序</strong>。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<p>举例图示：将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211213191920934.png" alt="image-20211213191920934"></p>
<h3 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.datastructures.tree.heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//对该数组进行升序排列</span></span><br><span class="line">        <span class="comment">//int[] arr = &#123;4, 6, 8, 5, 9,0,-1,22,-88&#125;;</span></span><br><span class="line">        <span class="comment">//heapSort(arr);</span></span><br><span class="line">        <span class="comment">//测试堆排序的速度   随机给80000个数  ---</span></span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">800000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">800000</span>;i++)&#123;</span><br><span class="line">            arr[i]=(<span class="type">int</span>)(Math.random()*<span class="number">800000</span>);<span class="comment">//[0,800000)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是：&quot;</span>+date1Str);</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(date2);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的时间是：&quot;</span>+date2Str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法实现堆排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1)将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// System.out.println(&quot;调整后的堆为：&quot; + Arrays.toString(arr));</span></span><br><span class="line">        <span class="comment">//2)将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;</span></span><br><span class="line">        <span class="comment">//3)重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];<span class="comment">//调整好的堆 最大值肯定在数组的第一位</span></span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// System.out.println(&quot;堆排序的结果：&quot; + Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个数组（二叉树）调整成一个大顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：将以i为父节点的树 调整成大顶堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i      i表示非叶子节点在数组中的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 对length个数据进行调整  没调整一次length-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];<span class="comment">//保存当前元素的值</span></span><br><span class="line">        <span class="comment">//调整</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;<span class="comment">//左子节点的值小于右子节点的值</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; temp) &#123;</span><br><span class="line">                <span class="comment">//把两者中较大的值赋给当前节点arr[i]</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;<span class="comment">//i指向k继续循环比较</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//for循环结束后 以i为父节点的树的最大值已经放在了最顶部</span></span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp的值放在调整后的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="基数排序的说明"><a href="#基数排序的说明" class="headerlink" title="基数排序的说明"></a>基数排序的说明</h3><ol>
<li>基数排序是对<strong>传统桶排序的扩展，速度很快</strong>.</li>
<li>基数排序是经典的<strong>空间换时间</strong>的方式，<strong>占用内存很大</strong>, 当对海量数据排序时，容易造成 OutOfMemoryError 。</li>
<li>基数排序是稳定的。<ul>
<li>注：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的<strong>相对次序保持不变</strong>，即在原序列中，r[i]&#x3D;r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</li>
</ul>
</li>
<li>有负数的数组，一般不用基数排序来进行排序</li>
</ol>
<h2 id="总结和对比"><a href="#总结和对比" class="headerlink" title="总结和对比"></a>总结和对比</h2><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214110818446.png" alt="image-20211214110818446"></p>
<ul>
<li>稳定：如果a原本在b前面，而a&#x3D;b,排序之后a仍然在b的前面;</li>
<li>不稳定：如果a原本在b的前面，而a&#x3D;b, 排序之后a可能会出现在b的后面;</li>
<li>内排序：所有排序操作都在内存中完成;</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行;</li>
<li>时间复杂度：一个算法执行所耗费的时间。</li>
<li>空间复杂度:运行完一个程序所需内存的大小。</li>
<li>n：数据规模</li>
<li>k：“桶”的个数</li>
<li>In-place：不占用额外内存</li>
<li>Out-place：占用额外内存</li>
</ul>
<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><p>在java中，我们常用的查找有四种：</p>
<ul>
<li>顺序(线性)查找</li>
<li>二分查找&#x2F;折半查找</li>
<li>插值查找</li>
<li>斐波那契杏找</li>
</ul>
<h2 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h2><h3 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeqSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">11</span>, -<span class="number">1</span>, <span class="number">34</span>, <span class="number">89</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> seqSearch(arr, <span class="number">11</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到数字的第一个位置是&quot;</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有一个查找项</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">seqSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//线性查找是逐一比对，发现有相同值，就返回下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有多个相同的查找项</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">seqSearch2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == value) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer index : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您要找的数据在数组中的下标为：&quot;</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="思路分析-12"><a href="#思路分析-12" class="headerlink" title="思路分析"></a>思路分析</h3><ol>
<li>首先确定该数组的中间的下标 mid &#x3D; (left + right) &#x2F; 2</li>
<li>然后让需要查找的数 findVal 和 arr[mid] 比较<ol>
<li>findVal &gt; arr[mid]，说明你要查找的数在mid 的右边, 因此需要递归的向右查找</li>
<li>findVal &lt; arr[mid]，说明你要查找的数在mid 的左边, 因此需要递归的向左查找</li>
<li>findVal &#x3D;&#x3D; arr[mid] 说明找到，就返回</li>
</ol>
</li>
</ol>
<ul>
<li>什么时候我们需要结束递归.<ul>
<li>找到就结束递归 </li>
<li>递归完整个数组，仍然没有找到findVal ，也需要结束递归  当 left &gt; right 就需要退出</li>
</ul>
</li>
</ul>
<h3 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到数字的第一个位置是&quot;</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> findVal)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123; <span class="comment">//在端点的时候就是left==right</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多个相同值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> findVal)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123; <span class="comment">//递归结束条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch2(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch2(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//有相同值</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	1、当查找到mid索引值后 向左右两边扫描看是否有多个相同查找值</span></span><br><span class="line"><span class="comment">            2、向mid索引值的左边扫描，若存在满足findVal的值则将其加入集合中</span></span><br><span class="line"><span class="comment">            3、向mid索引值的右边扫描，若存在满足findVal的值则将其加入集合中</span></span><br><span class="line"><span class="comment">            4、不要忘了把mid索引处的数据也加入集合中  最后返回集合即可*/</span></span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; <span class="number">0</span> || arr[temp] != findVal) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                    temp--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(mid);</span><br><span class="line">            temp = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; arr.length - <span class="number">1</span> || arr[temp] != findVal) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><h3 id="思路分析-13"><a href="#思路分析-13" class="headerlink" title="思路分析"></a>思路分析</h3><ol>
<li><p>插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。</p>
</li>
<li><p>将折半查找中的求mid索引的公式,low表示左边索引left,high表示右边索引right。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214120022075.png" alt="image-20211214120022075"></p>
</li>
<li><p>int midIndex &#x3D; low + (high - low) * (key - arr[low])&#x2F;(arr[high]-arr[low]) ;&#x2F;* 插值 索引 *&#x2F;</p>
</li>
<li><p>举例说明插值查找算法1-100的数组</p>
<ul>
<li><p>数组  arr &#x3D; [1, 2, 3, ……., 100]</p>
</li>
<li><p>假如我们需要查找的值  1 </p>
</li>
<li><p>使用二分查找的话，我们需要多次递归，才能找到 1</p>
</li>
<li><p>使用插值查找算法</p>
<ul>
<li>&#x3D;&#x3D;<strong>int mid &#x3D; left + (right – left) * (findVal – arr[left]) &#x2F; (arr[right] – arr[left])</strong>&#x3D;&#x3D;</li>
<li>int mid &#x3D; 0 + (99 - 0) * (1 - 1)&#x2F; (100 - 1) &#x3D; 0 + 99 * 0 &#x2F; 99 &#x3D; 0</li>
</ul>
</li>
<li><p>比如我们查找的值 100</p>
<ul>
<li>int mid &#x3D; 0 + (99 - 0) * (100 - 1) &#x2F; (100 - 1) &#x3D; 0 + 99 * 99 &#x2F; 99 &#x3D; 0 + 99 &#x3D; 99</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="代码实现-15"><a href="#代码实现-15" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertValueSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">/* int[] arr = new int[100];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 100; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = i + 1;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>,<span class="number">1000</span>,<span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> insertValSearch(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, <span class="number">1234</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插值查找  要求数组有序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">insertValSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> findVal)</span> &#123;</span><br><span class="line">        <span class="comment">//findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1] 必须有 防止mid越界</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left])  ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> insertValSearch(arr, mid + <span class="number">1</span>, right, findVal);<span class="comment">//向右递归</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> insertValSearch(arr, left, mid - <span class="number">1</span>, findVal);<span class="comment">//向左递归</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>对于<strong>数据量较大</strong>，关键字<strong>分布比较均匀</strong>的查找表来说，采用<strong>插值查找，速度较快</strong>.</li>
<li>关键字<strong>分布不均匀</strong>的情况下，该方法不一定比折半查找要好。</li>
</ol>
<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>黄金分割点是指把一条<strong>线段</strong>分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是<strong>0.618</strong>。由于按此比例设计的造型十分美丽，因此称为<strong>黄金分割</strong>，也称为<strong>中外比</strong>。这是一个神奇的数字，会带来意向不大的效果。</li>
<li><strong>斐波那契数列</strong>{1,1,2,3,5,8,13,21,34,55}发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618。</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>斐波那契查找</strong>原理与前两种相似，仅仅改变了中间结点(mid) 的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid&#x3D;low+F(k-1)-1(F代表斐波那契数列)，如下图所示</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214123746482.png" alt="image-20211214123746482"></p>
<p>对F(k-1)-1的理解：</p>
<ol>
<li>由斐波那契数列 F[k]&#x3D;F[k-1]+F[k-2]的性质，可以得到**(F[k]-1) &#x3D; (F[k-1]-1) + (F[k-2]-1) +1**。<ul>
<li>该式说明:只要顺序表的长度为<strong>F[k]-1</strong>,则可以将该表分成长度为<strong>F[k-1]-1</strong>和<strong>F[k-2]-1</strong>的两段，即如上图所示。从而中间位置为<strong>mid&#x3D;low+F(k-1)-1</strong></li>
</ul>
</li>
<li>类似的，每一子段也可以用相同的方式分割</li>
<li>但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到顺序表长度增加后，新增的位置(从n+1到F[k}-1位置)，都赋为n位置的值即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(n&gt;fib(k)-<span class="number">1</span>)</span><br><span class="line">k++;</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-16"><a href="#代码实现-16" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FibonacciSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxSzie</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> fibSearch(arr, <span class="number">1234</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;您要找的数据的下标是：&quot;</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得斐波那契数列</span></span><br><span class="line">    <span class="comment">//非递归方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] fib() &#123;</span><br><span class="line">        <span class="type">int</span>[] fib = <span class="keyword">new</span> <span class="title class_">int</span>[maxSzie];</span><br><span class="line">        fib[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; maxSzie; i++) &#123;</span><br><span class="line">            fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="type">int</span> fib[] = fib();<span class="comment">//获取到斐波那契数列</span></span><br><span class="line">        <span class="comment">//获取到斐波那契额分割数值的下标</span></span><br><span class="line">        <span class="keyword">while</span> (arr.length &gt; fib[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(k);//k=5 表示fib[5]-1=8-1=7  7&gt;6</span></span><br><span class="line">        <span class="comment">//退出循环时说明已经找到斐波那契分割的数值即fib[k]  fib[k]的值表示 要使用此方法所需的 元素的个数</span></span><br><span class="line">        <span class="comment">//因为fib[k]可能大于arr的长度，所以这里需要构建一个新数组补齐所需的元素</span></span><br><span class="line">        <span class="comment">// copyOf(oringinal, int newlength) oringinal:原数组  newlength:复制数组的长度</span></span><br><span class="line">        <span class="type">int</span>[] temp = Arrays.copyOf(arr, fib[k]);<span class="comment">//不足的地方自动填充0</span></span><br><span class="line">        <span class="comment">/*for(int x=0;x&lt;temp.length;x++) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;temp=&quot; + temp[x]);//[1, 8, 10, 89, 1000, 1234,0,0]</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//此方法实际应该在不足的地方填充arr的最后一个数据的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high + <span class="number">1</span>; i &lt; fib[k]; i++) &#123;</span><br><span class="line">            temp[i] = arr[high];<span class="comment">////[1, 8, 10, 89, 1000, 1234,1234,1234]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始查找（非递归）</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = low + fib[k - <span class="number">1</span>] - <span class="number">1</span>;<span class="comment">//前半段</span></span><br><span class="line">            <span class="keyword">if</span> (value &lt; temp[mid]) &#123;<span class="comment">//向数组左边查找</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//fib[k]=fib[k-1]+fib[k-2] 因为要找的值小于temp[mid] 所以去fib[k-1]这部分继续找</span></span><br><span class="line">                <span class="comment">//所以k-- 即 下次循环mid=low+fib[k-1-1]-1</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; temp[mid]) &#123;<span class="comment">//向数组右边查找</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//fib[k]=fib[k-1]+fib[k-2] 因为要找的值大于于temp[mid] 所以去fib[k-2]这部分继续找</span></span><br><span class="line">                <span class="comment">//所以k-=2 即 下次循环mid=low+fib[k-2-1]-1</span></span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到的话需要确定返回的下标</span></span><br><span class="line">                <span class="keyword">if</span> (mid &lt;= high) <span class="keyword">return</span> mid;<span class="comment">//在右边</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> high;<span class="comment">//因为temp填充过，所以mid会大于high</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h2><p>散列表(Hash table，也叫哈希表)，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数,存放记录的数组叫做散列表。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214144131687.png" alt="image-20211214144131687"></p>
<p><strong>散列表</strong>(Hash table，也叫哈希表)，是根据关键码值(Key value)而直接进行访问的<strong>数据结构</strong>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<strong>散列函数</strong>，存放记录的<strong>数组</strong>叫做<strong>散列表</strong>。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214144546900.png" alt="image-20211214144546900"></p>
<p>+++</p>
<p>有一个公司，当有新的员工来报道时，要求将该员工的信息加入(id,性别,年龄,住址……)，当输入该员工的id时，要求查找到该员工的所有信息。</p>
<p>要求：不使用数据库，尽量节省内存，速度越快越好&#x3D;&gt;哈希表(散列)</p>
<h2 id="思路分析-14"><a href="#思路分析-14" class="headerlink" title="思路分析"></a>思路分析</h2><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214153026969.png" alt="image-20211214153026969"></p>
<h2 id="代码实现-17"><a href="#代码实现-17" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>方法类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HashTab</span> <span class="variable">hashTable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTab</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;add: 添加雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;list: 显示雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;find: 查找雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;del: 删除雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit: 退出系统&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入相关指令：&quot;</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入id：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入姓名：&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(id, name);</span><br><span class="line">                    hashTable.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                    hashTable.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;find&quot;</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入员工id：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    hashTable.findEmpById(no);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;del&quot;</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入员工id：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">no1</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    hashTable.deleteEmpById(no1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**HashTab **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建HashTab，管理多条链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTab</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;<span class="comment">//表示有多少条链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器。创建size条链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashTab</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="comment">//初始化empLinkedList</span></span><br><span class="line">        <span class="built_in">this</span>.empLinkedList = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>[size];</span><br><span class="line">        <span class="comment">//要初始化hashTab中的每一个链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedList[i] = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写散列函数，使用一个简单的取模法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashFun</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        <span class="comment">//根据员工id，得到该员工应该添加到哪条链表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNo</span> <span class="operator">=</span> hashFun(emp.id);</span><br><span class="line">        <span class="comment">//将emp添加到对应的链表中</span></span><br><span class="line">        empLinkedList[empLinkedListNo].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedList[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNo</span> <span class="operator">=</span> hashFun(id);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> empLinkedList[empLinkedListNo].findEmpById(id);</span><br><span class="line">        <span class="keyword">if</span> (emp == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + empLinkedListNo + <span class="string">&quot;条链表中，id为&quot;</span> + emp.id + <span class="string">&quot;雇员的信息&quot;</span> + emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteEmpById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNo</span> <span class="operator">=</span> hashFun(id);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> empLinkedList[empLinkedListNo].deleteById(id);</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + empLinkedListNo + <span class="string">&quot;条链表中的雇员的信息已删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>EmpLinkedList</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建EmpLinkedList，表示链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Emp head;<span class="comment">//头结点，默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有序添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;<span class="comment">//如果头结点为空，直接加入</span></span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是第一个就在链表中添加</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;<span class="comment">//辅助指针</span></span><br><span class="line">        <span class="keyword">if</span> (curEmp.id &gt; emp.id) &#123;<span class="comment">//输入的值小于现在的头结点，则和头结点互换</span></span><br><span class="line">            emp.next = head;</span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="literal">null</span>) &#123;<span class="comment">//到达链表末尾</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next.id &gt; emp.id) &#123;<span class="comment">//下一个比输入的大</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;<span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        emp.next = curEmp.next;</span><br><span class="line">        curEmp.next = emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历全部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + no + <span class="string">&quot;条链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + no + <span class="string">&quot;条链表:&quot;</span>);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;<span class="comment">//辅助指针</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(curEmp);</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="literal">null</span>) &#123;<span class="comment">//说明指到了最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.id == id) &#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="literal">null</span>) &#123;<span class="comment">//到最后都没找到，返回null</span></span><br><span class="line">                curEmp = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;<span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curEmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.id == id) &#123;<span class="comment">//如果删除的为头结点</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="literal">null</span>) &#123;<span class="comment">//没找到找到</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next.id == id) &#123;<span class="comment">//找到了</span></span><br><span class="line">                <span class="keyword">if</span> (curEmp.next.next == <span class="literal">null</span>) &#123;<span class="comment">//如果需要删除的是当前链表的尾节点</span></span><br><span class="line">                    curEmp.next = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是链表中间</span></span><br><span class="line">                    curEmp.next = curEmp.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;<span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Emp</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 雇员类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Emp next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Emp&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h1><h2 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h2><h3 id="数组存储方式的分析"><a href="#数组存储方式的分析" class="headerlink" title="数组存储方式的分析"></a><strong>数组存储方式的分析</strong></h3><p><strong>优点</strong>：通过<strong>下标方式访问元素</strong>，速度快。对于有序数组，还可使用<strong>二分查找</strong>提高检索速度。</p>
<p><strong>缺点</strong>：如果要检索具体某个值，或者<strong>插入值(按一定顺序)会整体移动</strong>， 效率较低</p>
<p>操作示意图：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214195730478.png" alt="image-20211214195730478"></p>
<h4 id="ArrayList集合的扩容"><a href="#ArrayList集合的扩容" class="headerlink" title="ArrayList集合的扩容"></a>ArrayList集合的扩容</h4><p>ArrayList底层仍然是数组扩容，利用grow方式进行扩容</p>
<ol>
<li><strong>ArrayList中维护了一个Object类型的数组elementData。 [debug看源码]</strong></li>
<li><strong>当创建对象时，如果使用的是无参构造器，则初始elementData容量为0 (jdk7 是10)</strong></li>
<li><strong>如果使用的是指定容量capacity的构造器，则初始elementData容量为 capacity。</strong></li>
<li><strong>当添加元素时：先判断是否需要扩容，如果需要扩容，则调用grow方法，否则直接添加元素到合适位置</strong></li>
<li><strong>如果使用的是无参构造器，如果第一次添加， 需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍。</strong></li>
<li><strong>如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍。</strong></li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214200100339.png" alt="image-20211214200100339"></p>
<h3 id="链式存储方式的分析"><a href="#链式存储方式的分析" class="headerlink" title="链式存储方式的分析"></a><strong>链式存储方式的分析</strong></h3><p><strong>优点</strong>：在一定程度上对数组存储方式有优化(比如：<strong>插入</strong>一个数值节点,只需要将插入节点，链接到链表中即可，<strong>删除</strong>效率也很好)。</p>
<p><strong>缺点</strong>：在进行<strong>检索时</strong>，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)</p>
<p>操作示意图：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214200324337.png" alt="image-20211214200324337"></p>
<h3 id="树存储方式的分析"><a href="#树存储方式的分析" class="headerlink" title="树存储方式的分析"></a><strong>树存储方式的分析</strong></h3><p>能提高数据<strong>存储，读取</strong>的效率，比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</p>
<p>案例: [7, 3, 10, 1, 5, 9, 12]</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214201704387.png" alt="image-20211214201704387"></p>
<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214203504732.png" alt="image-20211214203504732"></p>
<ol>
<li>树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。</li>
<li>二叉树的子节点分为左节点和右节点。</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214203620268.png" alt="image-20211214203620268"></p>
<ol>
<li>如果该二叉树的所有叶子节点都在最后一层，并且结点总数&#x3D; 2^n -1 , n 为层数，则我们称为满二叉树。</li>
<li>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214202636963.png" alt="image-20211214202636963"></p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>前序遍历：<strong>先输出父节点</strong>，再遍历左子树和右子树</p>
<p>中序遍历：先遍历左子树，<strong>再输出父节点</strong>，再遍历右子树</p>
<p>后序遍历：先遍历左子树，再遍历右子树，<strong>最后输出父节点</strong></p>
<p><strong>小结：</strong>看输出父节点的顺序，就确定是前序，中序还是后序</p>
<h5 id="思路分析-15"><a href="#思路分析-15" class="headerlink" title="思路分析"></a>思路分析</h5><p>分析二叉树的前序，中序，后序的遍历步骤</p>
<ul>
<li>创建一颗二叉树</li>
<li>前序遍历（中、左、右）<ol>
<li>先输出当前节点（初始的时候是root节点）；</li>
<li>如果左子节点不为空，则递归继续前序遍历；</li>
<li>如果右子节点不为空，则递归继续前序遍历。</li>
</ol>
</li>
<li>中序遍历（左、中、右）<ol>
<li>如果当前节点的左子节点不为空，则递归中序遍历；</li>
<li>输出当前节点；</li>
<li>如果当前节点的右子节点不为空，则递归中序遍历。</li>
</ol>
</li>
<li>后序遍历（左、右、中）<ol>
<li>如果当前节点的左子节点不为空，则递归后序遍历；</li>
<li>如果当前节点的右子节点不为空，则递归后序遍历；</li>
<li>输出当前节点。</li>
</ol>
</li>
</ul>
<h5 id="核心代码实现"><a href="#核心代码实现" class="headerlink" title="核心代码实现"></a>核心代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//先输出当前节点，不用判断是否为空，因为都进来了肯定不为空</span></span><br><span class="line">    System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点，不能写root，后面无法递归，第一次this=root</span></span><br><span class="line">    <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左递归结束后，返回到root，递归向右子树进行遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//先递归，向左子树中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出当前节点：父节点</span></span><br><span class="line">    System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//递归，向右子树中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//先递归，向左子树后序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归，向右子树后序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出当前父节点</span></span><br><span class="line">    System.out.println(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的查找"><a href="#二叉树的查找" class="headerlink" title="二叉树的查找"></a>二叉树的查找</h4><ol>
<li>请编写前序查找，中序查找和后序查找的方法。</li>
<li>并分别使用三种查找方式，查找 heroNO &#x3D; 5 的节点</li>
<li>并分析各种查找方式，分别比较了多少次</li>
</ol>
<h5 id="思路分析-16"><a href="#思路分析-16" class="headerlink" title="思路分析"></a>思路分析</h5><p>使用前序、中序、后序的方式来查询指定的节点</p>
<ul>
<li>前序查找思路<ol>
<li>先判断当前id是否等于要查找的id</li>
<li>如果是相等，则返回当前节点</li>
<li>如果不等，则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找</li>
<li>如果左递归前序查找，找到了，则返回；否则继续判断，当前节点的右子节点是否为空，如果不为空，则继续向右递归前序查找</li>
</ol>
</li>
<li>中序查找思路<ol>
<li>先判断当前节点的左子节点是否为空，如果不为空，则递归中序查找</li>
<li>如果如果找到，就返回，如果没有找到，就和当前节点进行比较，如果是（找到）则返回当前节点，否则继续进行右递归的中序查找。</li>
<li>如果右递归中序查找，找到了就返回，找不到就返回null</li>
</ol>
</li>
<li>后序查找思路<ol>
<li>先判断当前的左子节点是否为空，如果不为空，则递归后序查找</li>
<li>如果找到就返回，如果没有找到就判断当前节点的右子节点是否为空，如果不为空，则右递归进行后序查找，如果找到，就返回</li>
<li>如果没有找到，就和当前节点进行比较，如果是（找到）就返回，否则返回null</li>
</ol>
</li>
</ul>
<h5 id="核心代码实现-1"><a href="#核心代码实现-1" class="headerlink" title="核心代码实现"></a>核心代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历查找的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> no 英雄的编号（id)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 找到返回该英雄node，没找到返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进入前序遍历查找的方式&quot;</span>);</span><br><span class="line">    <span class="comment">//比较当前节点是不是</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是，判断左子节点是否为空，不为空就左递归;</span></span><br><span class="line">    <span class="comment">//如果左递归找到，节点，则返回</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//返回的值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        resNode = <span class="built_in">this</span>.left.preOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">//这个说明左子树我们已经找到了</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左递归没有找到的话，需要继续判断</span></span><br><span class="line">    <span class="comment">//判断当前节点的右子节点是否为空，如果不为空，则继续向右递归查找，找到返回，没有返回null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        resNode = <span class="built_in">this</span>.right.preOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode;<span class="comment">//不管找没找到，就可以直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历查找</span></span><br><span class="line"><span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">    <span class="comment">//先判断当前节点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        resNode = <span class="built_in">this</span>.left.infixOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">//这个表示左节点找到</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;进入中序遍历查找&quot;</span>);</span><br><span class="line">    <span class="comment">//如果没有找到，就和当前节点比较，如果是，则返回当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;<span class="comment">//说明找到，并返回了当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有找到，就向右继续递归中序查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        resNode = <span class="built_in">this</span>.right.infixOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode;<span class="comment">//不管是否为空，直接返回即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历查找</span></span><br><span class="line"><span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">    <span class="comment">//判断当前节点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        resNode = <span class="built_in">this</span>.left.postOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断</span></span><br><span class="line">    <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resNode;<span class="comment">//说明找到</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左子树没有找到，则向右子树进行后序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        resNode = <span class="built_in">this</span>.right.postOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;进入后序查找&quot;</span>);<span class="comment">//查看遍历的次数，得写在比较语句(this.no==no)的前面，不能写在前面</span></span><br><span class="line">    <span class="comment">//如果左右子树都没有找到，就比较当前节点是不是</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的删除"><a href="#二叉树的删除" class="headerlink" title="二叉树的删除"></a>二叉树的删除</h4><ol>
<li>如果删除的节点是叶子节点，则删除该节点</li>
<li>如果删除的节点是非叶子节点，则删除该子树.</li>
<li>测试，删除掉 5号叶子节点 和 3号子树.</li>
</ol>
<h5 id="思路分析-17"><a href="#思路分析-17" class="headerlink" title="思路分析"></a>思路分析</h5><ol>
<li><strong>如果删除的节点是叶子节点，则删除该节点</strong></li>
<li><strong>如果删除的节点是非叶子节点，则删除该子树</strong></li>
</ol>
<p>+++</p>
<ol>
<li><strong>考虑如果树是空树root，如果只有一个root节点，则等价将二叉树置空。</strong></li>
<li><strong>因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否是需要删除的节点；而不是去判断当前这个节点是不是需要删除的节点。</strong>（也就是说，如果指针指向5号，就删除不了5号，只能删除其左右子节点，找不到5号的父节点）</li>
<li>如果当前节点的<strong>左子节点</strong>不为空，并且左子节点的编号就是要删除的节点，那么就直接，将this.left&#x3D;null，直接置空即可。并且就返回（结束递归删除）</li>
<li>如果当前节点的<strong>右子节点</strong>不为空，并且右子节点就是要删除的节点，那么直接将右边置空即可，this.right&#x3D;null，并且就返回（结束递归删除）</li>
<li>如果第2步和第3步，都没有删除节点，那么我们就需要向左子树进行递归删除。（当然也得判断左子树是否为null空）</li>
<li>如果第4步也没有删除节点，则应当向右子树进行递归删除。</li>
</ol>
<h5 id="核心代码实现-2"><a href="#核心代码实现-2" class="headerlink" title="核心代码实现"></a>核心代码实现</h5><p>调用方法：考虑如果树是空树root，如果只有一个root节点，则等价将二叉树置空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除节点的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">    <span class="comment">//首先判断root是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果只有一个root节点，这里需要立即判断root是不是要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.getNo() == no) &#123;</span><br><span class="line">            root = <span class="literal">null</span>;<span class="comment">//恰好是根节点，直接置空即可</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果root不是，则就递归删除</span></span><br><span class="line">            root.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空树，不能删除~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码：2、3、4、5、6</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归删除节点</span></span><br><span class="line"><span class="comment">//规定：1.如果是叶子节点则删除该节点，2如果删除的是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">    <span class="comment">//先判断左子节点是否为空，再判断是否是要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.no == no) &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左子节点不是，判断右子节点是否为空或者是否是要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.no == no) &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果前两个都没有，则需要先向左递归删除</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.left.delNode(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左递归没有结束的话，就进行右递归进行删除</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.right.delNode(no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先需要一个二叉树</span></span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="comment">//创建需要的节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;老大&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;老二&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;老三&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;老四&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;老五&quot;</span>);<span class="comment">//再加一个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明：先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">        root.setLeft(node2);<span class="comment">//root左边的节点挂上了node2，之前是root.left=node2;但是这个方法变成私有的了</span></span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        node3.setLeft(node5);<span class="comment">//</span></span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历&quot;</span>);<span class="comment">//先输出1宋江，2吴用，3卢俊义，4林冲，正好是顺序</span></span><br><span class="line">        binaryTree.preOrder();<span class="comment">//再加一个5，是12354</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();<span class="comment">//2,1,3,4；//再加一个5，是21534</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历&quot;</span>);<span class="comment">//此时需要注意</span></span><br><span class="line">        binaryTree.postOrder();<span class="comment">//2，4，3，1//再加一个5，是254311</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        <span class="comment">//前序查找遍历</span></span><br><span class="line">        <span class="comment">//前序遍历的次数4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历查找的方式~~&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> binaryTree.preOrderSearch(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//System.out.println(resNode);直接输出即可，毕竟都重写了toString，但是老师是按照下面写的</span></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;找到了，信息为id=%d name=%s\n&quot;</span>, resNode.getNo(), resNode.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到id=%d的英雄&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序查找遍历</span></span><br><span class="line">        <span class="comment">//中序遍历的次数3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历查找的方式~~&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode1</span> <span class="operator">=</span> binaryTree.infixOrderSearch(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (resNode1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;找到了，信息为id=%d name=%s&quot;</span>, resNode1.getNo(), resNode1.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到id=%d的英雄&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后序查找遍历</span></span><br><span class="line">        <span class="comment">//后序遍历的次数3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历查找的方式~~&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode2</span> <span class="operator">=</span> binaryTree.postOrderSearch(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (resNode2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;找到了，信息为id=%d name=%s&quot;</span>, resNode2.getNo(), resNode2.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到id=%d的英雄&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        <span class="comment">//测试，删除节点的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除前，前序遍历的操作&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        binaryTree.delNode(<span class="number">5</span>);<span class="comment">//1234</span></span><br><span class="line">        <span class="comment">//binaryTree.delNode(3);//12 删除子树，等价与把那棵子树全部干掉</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除后，前序遍历的操作&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();<span class="comment">//1234</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="comment">//只需要一个根节点即可</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历；真正的调用是从根节点来调的，就想前面所讲的哈希表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();<span class="comment">//谁调用指向谁preOrder()指向root</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序查找遍历</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//如果为空的话直接返回即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序查找遍历</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.postOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">//首先判断root是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果只有一个root节点，这里需要立即判断root是不是要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.getNo() == no) &#123;</span><br><span class="line">                root = <span class="literal">null</span>;<span class="comment">//恰好是根节点，直接置空即可</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果root不是，则就递归删除</span></span><br><span class="line">                root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空树，不能删除~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;<span class="comment">//英雄的编号</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//英雄的名字</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode left;<span class="comment">//指向左边的索引，默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right;<span class="comment">//指向右边的索引，默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要输出当前节点的内容，所以需要重写toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> + <span class="string">&quot;no=&quot;</span> + no + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先输出当前节点，不用判断是否为空，因为都进来了肯定不为空</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点，不能写root，后面无法递归，第一次this=root</span></span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左递归结束后，返回到root，递归向右子树进行遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先递归，向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前节点：父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归，向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先递归，向左子树后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归，向右子树后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历查找的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 英雄的编号（id)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 找到返回该英雄node，没找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入前序遍历查找的方式&quot;</span>);</span><br><span class="line">        <span class="comment">//比较当前节点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是，判断左子节点是否为空，不为空就左递归;</span></span><br><span class="line">        <span class="comment">//如果左递归找到，节点，则返回</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//返回的值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">//这个说明左子树我们已经找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归没有找到的话，需要继续判断</span></span><br><span class="line">        <span class="comment">//判断当前节点的右子节点是否为空，如果不为空，则继续向右递归查找，找到返回，没有返回null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;<span class="comment">//不管找没找到，就可以直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">//先判断当前节点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">//这个表示左节点找到</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入中序遍历查找&quot;</span>);</span><br><span class="line">        <span class="comment">//如果没有找到，就和当前节点比较，如果是，则返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;<span class="comment">//说明找到，并返回了当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有找到，就向右继续递归中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;<span class="comment">//不管是否为空，直接返回即可</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前节点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;<span class="comment">//说明找到</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左子树没有找到，则向右子树进行后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入后序查找&quot;</span>);<span class="comment">//查看遍历的次数，得写在比较语句(this.no==no)的前面，不能写在前面</span></span><br><span class="line">        <span class="comment">//如果左右子树都没有找到，就比较当前节点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归删除节点</span></span><br><span class="line">    <span class="comment">//规定：1.如果是叶子节点则删除该节点，2如果删除的是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">//先判断左子节点是否为空，再判断是否是要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.no == no) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左子节点不是，判断右子节点是否为空或者是否是要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.no == no) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果前两个都没有，则需要先向左递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归没有结束的话，就进行右递归进行删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h3><p>从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，看右面的示意图。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211214234221162.png" alt="image-20211214234221162"></p>
<ol>
<li>右图的二叉树的结点，要求以数组的方式来存放arr：[1,2,3,4,5,6,7]</li>
<li>要求在遍历数组arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历</li>
</ol>
<h4 id="思路分析-18"><a href="#思路分析-18" class="headerlink" title="思路分析"></a>思路分析</h4><p>顺序存储二叉树的特点：</p>
<ol>
<li>顺序二叉树通常只考虑完全二叉树</li>
<li>第n个元素的左子节点为 2*n+1<ul>
<li>注意：这个n指的是原数组的下标，数组是从0开始的</li>
<li>所以，这个也是从0开始的，这个计算的左子节点也是对应元素在数组中的下标。特别注意</li>
</ul>
</li>
<li>第n个元素的右子节点为 2*n+2</li>
<li>第n个元素的父节点为 (n-1)&#x2F;2</li>
<li>n：表示二叉树中的第几个元素（按0开始编号如图所示）</li>
</ol>
<h4 id="代码实现-18"><a href="#代码实现-18" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="comment">//创建一个ArrBinaryTree对象</span></span><br><span class="line">        <span class="type">ArrBinaryTree</span> <span class="variable">arrBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrBinaryTree</span>(arr);</span><br><span class="line">        <span class="comment">//arrBinaryTree.preOrder(0);//按照根节点，应该先传0进去即可，但是这样写比较麻烦，一般使用重载的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//前序操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历的操作&quot;</span>);</span><br><span class="line">        arrBinaryTree.preOrder();</span><br><span class="line">        <span class="comment">//中序操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历的操作&quot;</span>);</span><br><span class="line">        arrBinaryTree.midOrder();</span><br><span class="line">        <span class="comment">//后序操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历的操作&quot;</span>);</span><br><span class="line">        arrBinaryTree.postOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个ArrayBinaryTree，实现顺序存储二叉树的遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//存储数据节点的数组（就是存储二叉树节点的数组）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要一个构造器，待会把数组传给我即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrBinaryTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载前序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法完成顺序存储二叉树前序遍历操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 这个表示数组的下标，类似刚才分析的n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果数组为空，或者arr.length=0</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;<span class="comment">//arr=null，表示arr不指向任何对象，length=0表示指针指向一个长度为0的对象，判断null需要在前防止空指针异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，不能按照二叉树的前序进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行前序遍历</span></span><br><span class="line">        <span class="comment">//输出当前的这个元素</span></span><br><span class="line">        <span class="comment">//中间</span></span><br><span class="line">        System.out.println(arr[index]);<span class="comment">//0</span></span><br><span class="line">        <span class="comment">//先向左递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;<span class="comment">//加上这个判断是为了防止角标越界</span></span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后向右递归</span></span><br><span class="line">        <span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">2</span>);<span class="comment">//2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序方法的重载操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        midOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成顺序存储二叉树的中序操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//先判断数组是否为空或者长度为0</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，不能进行二叉树中序遍历操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先向左递归</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">2</span> * index + <span class="number">1</span>) &lt; arr.length) &#123;<span class="comment">//1</span></span><br><span class="line">            midOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中间</span></span><br><span class="line">        System.out.println(arr[index]);<span class="comment">//0</span></span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">2</span> * index + <span class="number">2</span>) &lt; arr.length) &#123;<span class="comment">//2</span></span><br><span class="line">            midOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序方法的重载操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        postOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成顺序存储二叉树的后序操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//先判断数组是否为空或者长度为0</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，不能进行二叉树后序遍历操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先向左递归</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">2</span> * index + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">2</span> * index + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">2</span>);<span class="comment">//2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中间</span></span><br><span class="line">        System.out.println(arr[index]);<span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211215165734067.png" alt="image-20211215165734067"></p>
<ol>
<li>当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 14, 6 }</li>
<li>但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.</li>
<li>如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点。怎么办?</li>
<li>解决方案——线索二叉树</li>
</ol>
<h4 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>n个结点的二叉链表中含有n+1  【公式 2n-(n-1)&#x3D;n+1】 个空指针域。利用二叉链表中的空指针域，存放指向<strong>该结点</strong>在<strong>某种遍历次序</strong>下的前驱和后继结点的指针（这种附加的指针称为”线索”）；</p>
</li>
<li><p>这种加上了线索的二叉链表称为<strong>线索链表</strong>，相应的二叉树称为<strong>线索二叉树(Threaded BinaryTree)<strong>。根据线索性质的不同，线索二叉树可分为</strong>前序线索二叉树、中序线索二叉树</strong>和<strong>后序线索二叉树</strong>三种；</p>
</li>
<li><p>一个结点的前一个结点，称为<strong>前驱</strong>结点；</p>
</li>
<li><p>一个结点的后一个结点，称为<strong>后继</strong>结点。</p>
</li>
</ol>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p>应用案例说明：将下面的二叉树，进行中序线索二叉树。</p>
<p>中序遍历的数列为 {8, 3, 10, 1, 14, 6}</p>
<p>前序遍历的数列为{1, 3, 8, 10, 6, 14}</p>
<p>后续遍历的数列为{8, 10, 3, 14, 6, 1}</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211215171333239.png" alt="image-20211215171333239"></p>
<h5 id="思路分析-19"><a href="#思路分析-19" class="headerlink" title="思路分析"></a>思路分析</h5><p><strong>当线索化二叉树后，Node节点的 属性 left 和 right ，有如下情况：</strong></p>
<ol>
<li>left 指向的是<strong>左子树</strong>，也可能是指向的<strong>前驱节点</strong>。<ul>
<li>比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点。</li>
</ul>
</li>
<li>right指向的是<strong>右子树</strong>，也可能是指向的<strong>后继节点</strong>。<ul>
<li>比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向的是后继节点。</li>
</ul>
</li>
</ol>
<h5 id="代码实现-19"><a href="#代码实现-19" class="headerlink" title="代码实现"></a>代码实现</h5><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211215181505318.png" alt="image-20211215181505318"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadeBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试一把中序线索化二叉树的功能</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>, <span class="string">&quot;marry&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line">        <span class="comment">//二叉树，后面我们要递归的创建，仙子啊简单处理手动创建</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试中序线索化</span></span><br><span class="line">        <span class="type">ThreadBinaryTree</span> <span class="variable">threadBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadBinaryTree</span>();</span><br><span class="line">        threadBinaryTree.setRoot(root);</span><br><span class="line">        threadBinaryTree.threadNodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试，找10这个节点，看其前驱或者后驱节点是否变成了3和1</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> node5.getLeft();</span><br><span class="line">        System.out.println(<span class="string">&quot;十号节点的前驱节点是&quot;</span> + leftNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;十号节点的后继节点是&quot;</span> + node5.getRight());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义ThreadBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadBinaryTree</span> &#123;</span><br><span class="line">    <span class="comment">//只需要一个根节点即可</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line">    <span class="comment">//为了实现线索化，需要创建要给指向当前节点的前驱节点的指针</span></span><br><span class="line">    <span class="comment">//在递归进行线索化时，pre总是保留前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载threadNodes</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadNodes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadeNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写对二叉树进行中序线索化的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 这个就是当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     * 跟着树走一遍就懂了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadeNodes</span><span class="params">(HeroNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//如果node==null，就不能进行线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中序线索化的步骤</span></span><br><span class="line">        <span class="comment">//一、先线索化左子树</span></span><br><span class="line">        threadeNodes(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二、线索化当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="comment">//以8节点来理解，8节点.left=null，8节点的.leftType=1</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让当前节点的左指针指向前驱节点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//修改当前节点的左指针类型,指向前驱节点</span></span><br><span class="line">            node.setLefType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理后继节点；后继节点处理需要返回递归上一层，8是上层的左节点。。</span></span><br><span class="line">        <span class="comment">//此时node指向3，而pre指向8</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让前驱节点的右指针指向当前节点</span></span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            <span class="comment">//修改前驱节点的右指针类型</span></span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//！！这句话尤其重要，每处理一个节点后，让当前节点是下一个节点的前驱节点</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三、索化右子树</span></span><br><span class="line">        threadeNodes(node.getRight());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历线索化二叉树"><a href="#遍历线索化二叉树" class="headerlink" title="遍历线索化二叉树"></a>遍历线索化二叉树</h5><p><strong>说明</strong></p>
<p>对前面的中序线索化的二叉树， 进行遍历</p>
<p><strong>分析</strong></p>
<p>因为线索化后，各个结点指向有变化，因此<strong>原来的遍历方式不能使用</strong>，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 <strong>遍历的次序应当和中序遍历保持一致</strong>。</p>
<p><strong>核心代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个变量，存储当前遍历的节点，root开始</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//先循环的找到leftType==1的节点，第一个找到的应该是8这个节点</span></span><br><span class="line">        <span class="comment">//后边随着遍历而变化，因为当left==1时，说明该节点是按照线索化</span></span><br><span class="line">        <span class="comment">//处理后的有效节点</span></span><br><span class="line">        <span class="keyword">while</span> (node.getLefType() == <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.getLeft();<span class="comment">//就一直找，直到找到node.getLeftType==1，的时候停下</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到之后，打印当前节点</span></span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="comment">//如果当前节点的右指针指向的是后继节点，就一直输出</span></span><br><span class="line">        <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//获取到当前节点的后继节点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//while循环结束，说明就找到不等于1的，替换遍历的节点</span></span><br><span class="line">        node = node.getRight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadeBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试一把中序线索化二叉树的功能</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>, <span class="string">&quot;marry&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line">        <span class="comment">//二叉树，后面我们要递归的创建，仙子啊简单处理手动创建</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试中序线索化</span></span><br><span class="line">        <span class="type">ThreadBinaryTree</span> <span class="variable">threadBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadBinaryTree</span>();</span><br><span class="line">        threadBinaryTree.setRoot(root);</span><br><span class="line">        threadBinaryTree.threadNodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线索化二叉树后，不能在使用原来的遍历方法了</span></span><br><span class="line">        <span class="comment">//threadBinaryTree.infixOrder();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用线索化的方式遍历线索化二叉树&quot;</span>);</span><br><span class="line">        threadBinaryTree.threadList();<span class="comment">//8.3.10.1.14.6</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211215191032770.png" alt="image-20211215191032770"></p>
<h5 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadeBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试一把中序线索化二叉树的功能</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>, <span class="string">&quot;marry&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line">        <span class="comment">//二叉树，后面我们要递归的创建，仙子啊简单处理手动创建</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试中序线索化</span></span><br><span class="line">        <span class="type">ThreadBinaryTree</span> <span class="variable">threadBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadBinaryTree</span>();</span><br><span class="line">        threadBinaryTree.setRoot(root);</span><br><span class="line">        threadBinaryTree.threadNodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试，找10这个节点，看其前驱或者后驱节点是否变成了3和1</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> node5.getLeft();</span><br><span class="line">        System.out.println(<span class="string">&quot;十号节点的前驱节点是&quot;</span> + leftNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;十号节点的后继节点是&quot;</span> + node5.getRight());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线索化二叉树后，不能在使用原来的遍历方法了</span></span><br><span class="line">        <span class="comment">//threadBinaryTree.infixOrder();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用线索化的方式遍历线索化二叉树&quot;</span>);</span><br><span class="line">        threadBinaryTree.threadList();<span class="comment">//8.3.10.1.14.6</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义ThreadBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadBinaryTree</span> &#123;</span><br><span class="line">    <span class="comment">//只需要一个根节点即可</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line">    <span class="comment">//为了实现线索化，需要创建要给指向当前节点的前驱节点的指针</span></span><br><span class="line">    <span class="comment">//在递归进行线索化时，pre总是保留前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载threadNodes</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadNodes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadeNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的节点，root开始</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先循环的找到leftType==1的节点，第一个找到的应该是8这个节点</span></span><br><span class="line">            <span class="comment">//后边随着遍历而变化，因为当left==1时，说明该节点是按照线索化</span></span><br><span class="line">            <span class="comment">//处理后的有效节点</span></span><br><span class="line">            <span class="keyword">while</span> (node.getLefType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();<span class="comment">//就一直找，直到找到node.getLeftType==1，的时候停下</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到之后，打印当前节点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//如果当前节点的右指针指向的是后继节点，就一直输出</span></span><br><span class="line">            <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//获取到当前节点的后继节点</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//while循环结束，说明就找到不等于1的，替换遍历的节点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写对二叉树进行中序线索化的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 这个就是当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadeNodes</span><span class="params">(HeroNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//如果node==null，就不能进行线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中序线索化的步骤</span></span><br><span class="line">        <span class="comment">//一、先线索化左子树</span></span><br><span class="line">        threadeNodes(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二、线索化当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="comment">//以8节点来理解，8节点.left=null，8节点的.leftType=1</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让当前节点的左指针指向前驱节点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//修改当前节点的左指针类型,指向前驱节点</span></span><br><span class="line">            node.setLefType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理后继节点；(在递归中在下一轮才处理)</span></span><br><span class="line">        <span class="comment">// 后继节点处理需要返回递归上一层，8是上层的左节点。。</span></span><br><span class="line">        <span class="comment">//此时node指向3，而pre指向8</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让前驱节点的右指针指向当前节点</span></span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            <span class="comment">//修改前驱节点的右指针类型</span></span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//！！这句话尤其重要，每处理一个节点后，让当前节点是下一个节点的前驱节点</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三、线索化右子树</span></span><br><span class="line">        threadeNodes(node.getRight());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历；真正的调用是从根节点来调的，就想前面所讲的哈希表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();<span class="comment">//谁调用指向谁preOrder()指向root</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序查找遍历</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//如果为空的话直接返回即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序查找遍历</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.postOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">//首先判断root是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果只有一个root节点，这里需要立即判断root是不是要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.getNo() == no) &#123;</span><br><span class="line">                root = <span class="literal">null</span>;<span class="comment">//恰好是根节点，直接置空即可</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果root不是，则就递归删除</span></span><br><span class="line">                root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空树，不能删除~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;<span class="comment">//英雄的编号</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//英雄的名字</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode left;<span class="comment">//指向左边的索引，默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right;<span class="comment">//指向右边的索引，默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1.如果leftType==0，表示指向左子树，如果为1则表示指向前驱节点</span></span><br><span class="line">    <span class="comment">//2.如果rightType==0，表示指向右子树，如果为1表示指向后继节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> lefType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLefType</span><span class="params">(<span class="type">int</span> lefType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lefType = lefType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLefType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lefType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要输出当前节点的内容，所以需要重写toString方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写，前序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先输出当前节点，不用判断是否为空，因为都进来了肯定不为空</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点，不能写root，后面无法递归，第一次this=root</span></span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左递归结束后，返回到root，递归向右子树进行遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先递归，向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前节点：父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归，向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先递归，向左子树后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归，向右子树后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 英雄的编号（id)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 找到返回该英雄node，没找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入前序遍历查找的方式&quot;</span>);</span><br><span class="line">        <span class="comment">//比较当前节点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是，判断左子节点是否为空，不为空就左递归;</span></span><br><span class="line">        <span class="comment">// 如果左递归找到，节点，则返回</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//假定我们找到的节点就是它，因为我们需要判断左递归找到要返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">//这个说明左子树我们已经找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归没有找到的话，需要继续判断</span></span><br><span class="line">        <span class="comment">//判断当前节点的右子节点是否为空，如果不为空，则继续向右递归查找，找到返回，没有返回null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;<span class="comment">//不管找没找到，就可以直接返回</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">//先判断当前节点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">//这个表示左节点找到</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;进入zhong序遍历查找&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有找到，就和当前节点比较，如果是，则返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;<span class="comment">//说明找到，并返回了当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有找到，就向右继续递归中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;<span class="comment">//不管是否为空，直接返回即可</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前节点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;<span class="comment">//说明找到</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左子树没有找到，则向右子树进行后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;进入后序查找&quot;</span>);<span class="comment">//查看遍历的次数，得写在比较语句(this.no==no)的前面，不能写在前面</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果左右子树都没有找到，就比较当前节点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归删除节点</span></span><br><span class="line">    <span class="comment">//规定：1.如果是叶子节点则删除该节点，2如果删除的是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">//先判断左子节点是否为空，再判断是否是要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.no == no) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左子节点不是，判断右子节点是否为空或者是否是要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.no == no) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果前两个都没有，则需要先向左递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.java != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归没有结束的话，就进行右递归进行删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作业：多种线索化"><a href="#作业：多种线索化" class="headerlink" title="作业：多种线索化"></a>作业：多种线索化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedTreeNode</span> <span class="variable">root</span> <span class="operator">=</span> getTree();</span><br><span class="line">        <span class="type">ThreadedTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedTree</span>(root);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//tree.midThreadedNodes(root);</span></span><br><span class="line">		<span class="comment">//tree.listMidThreadedNodes();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//tree.preThreadedNodes(root);</span></span><br><span class="line">		<span class="comment">//tree.listPreThreadedNodes();</span></span><br><span class="line"></span><br><span class="line">        tree.postThreadedNodes(root);</span><br><span class="line">        tree.listPostThreadedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadedTreeNode <span class="title function_">getTree</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ThreadedTreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedTreeNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ThreadedTreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedTreeNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ThreadedTreeNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedTreeNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ThreadedTreeNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedTreeNode</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">ThreadedTreeNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedTreeNode</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">ThreadedTreeNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedTreeNode</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="type">ThreadedTreeNode</span> <span class="variable">node7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedTreeNode</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        node1.setLeft(node2);</span><br><span class="line">        node1.setRight(node3);</span><br><span class="line"></span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line"></span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line">        node3.setRight(node7);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedTree</span>&#123;</span><br><span class="line">	<span class="comment">//当前树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> ThreadedTreeNode root;</span><br><span class="line">	<span class="comment">//当前树的上一个节点</span></span><br><span class="line">    <span class="keyword">private</span> ThreadedTreeNode pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadedTree</span><span class="params">(ThreadedTreeNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的线索化（前序）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  需要线索化的当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preThreadedNodes</span><span class="params">(ThreadedTreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//1.线索化当前节点</span></span><br><span class="line">		<span class="comment">//1.1线索化前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//1.2线索化后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">		<span class="comment">//2.线索化左节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            preThreadedNodes(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//3.线索化右节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            preThreadedNodes(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的线索化（中叙）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 需要线索化的当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midThreadedNodes</span><span class="params">(ThreadedTreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//1.线索化左节点</span></span><br><span class="line">        midThreadedNodes(node.getLeft());</span><br><span class="line">		<span class="comment">//2.线索化当前节点</span></span><br><span class="line">		<span class="comment">//2.1处理前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//2.2处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">		<span class="comment">//3.线索化右节点</span></span><br><span class="line">        midThreadedNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的线索化（后续）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  需要线索化的当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postThreadedNodes</span><span class="params">(ThreadedTreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//1.线索化左节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            postThreadedNodes(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//2.线索化右节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            postThreadedNodes(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//3.线索化当前节点</span></span><br><span class="line">		<span class="comment">//3.1处理前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//3.2处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历（线索化二叉树）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listPreThreadedNodes</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//定义一个临时变量，用于存储遍历的当前节点</span></span><br><span class="line">        <span class="type">ThreadedTreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(node.getVal());</span><br><span class="line">            <span class="keyword">while</span>(node.getLeftType() == <span class="number">0</span>)&#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">                System.out.println(node.getVal());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中叙遍历（线索化二叉树）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listMidThreadedNodes</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//定义一个临时变量，用于存储遍历的当前节点</span></span><br><span class="line">        <span class="type">ThreadedTreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="comment">//循环找到leftType==1的节点</span></span><br><span class="line">            <span class="keyword">while</span>(node.getLeftType() == <span class="number">0</span>)&#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//打印当前节点</span></span><br><span class="line">            System.out.println(node.getVal());</span><br><span class="line">			<span class="comment">//如果当前节点的右节点是后继节点，则继续向下遍历</span></span><br><span class="line">            <span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>)&#123;</span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node.getVal());</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//如果当前节点的右节点不是后继节点，则替换当前节点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历（和普通遍历一样，这样写很傻逼，但是就是简单，[苦涩]）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listPostThreadedNodes</span><span class="params">(ThreadedTreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.getLeft () != <span class="literal">null</span> &amp;&amp; node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            listPostThreadedNodes(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.getRight() != <span class="literal">null</span> &amp;&amp; node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            listPostThreadedNodes(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.getVal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedTreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer val;</span><br><span class="line">    <span class="keyword">private</span> ThreadedTreeNode left;</span><br><span class="line">    <span class="keyword">private</span> ThreadedTreeNode right;</span><br><span class="line">	<span class="comment">//type:0(未线索化)</span></span><br><span class="line">    <span class="comment">//type:1(线索化)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">leftType</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">rightType</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadedTreeNode</span><span class="params">(Integer val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;TreeNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;val=&quot;</span> + val +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线索化比较"><a href="#线索化比较" class="headerlink" title="线索化比较"></a>线索化比较</h5><ol>
<li><strong>前序线索化二叉树</strong><ul>
<li>遍历相对最容易理解，实现起来也比较简单。由于前序遍历的顺序是：根左右，所以从根节点开始，沿着左子树进行处理，当子节点的left指针类型是线索时，说明到了最左子节点，然后处理子节点的right指针指向的节点，可能是右子树，也可能是后继节点，无论是哪种类型继续按照上面的方式（先沿着左子树处理，找到子树的最左子节点，然后处理right指针指向），以此类推，直到节点的right指针为空，说明是最后一个，遍历完成。</li>
</ul>
</li>
<li><strong>中序线索化二叉树</strong><ul>
<li>中序遍历的顺序是：左根右，因此第一个节点一定是最左子节点，先找到最左子节点，依次沿着right指针指向进行处理（无论是指向子节点还是指向后继节点），直到节点的right指针为空，说明是最后一个，遍历完成。</li>
</ul>
</li>
<li><strong>后序线索化二叉树</strong><ul>
<li>最为复杂，通用的二叉树数节点存储结构不能够满足后序线索化，因此我们扩展了节点的数据结构，增加了父节点的指针。后序的遍历顺序是：左右根，先找到最左子节点，沿着right后继指针处理，当right不是后继指针时，并且上一个处理节点是当前节点的右节点，则处理当前节点的右子树，遍历终止条件是：当前节点是root节点，并且上一个处理的节点是root的right节点。</li>
</ul>
</li>
</ol>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>堆排序是利用<strong>堆这种数据结构</strong>而设计的一种排序算法，堆排序是一种<strong>选择排序</strong></p>
</li>
<li><p>堆是具有以下性质的<strong>完全二叉树</strong>：</p>
<ul>
<li><p>每个结点的值都<strong>大于或等于其左右孩子结点的值</strong>，称为<strong>大顶堆</strong></p>
<ul>
<li><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211215203104513.png" alt="image-20211215203104513"></p>
</li>
<li><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211215203118348.png" alt="image-20211215203118348"></p>
<p>大顶堆特点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arr[i] &gt;= arr[<span class="number">2</span>*i+<span class="number">1</span>] &amp;&amp; arr[i] &gt;= arr[<span class="number">2</span>*i+<span class="number">2</span>]  <span class="comment">// i 对应第几个节点，i从0开始编号</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>每个结点的值都<strong>小于或等于其左右孩子结点的值</strong>，称为<strong>小顶堆</strong></p>
<ul>
<li><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211215203135360-16767091939831.png" alt="image-20211215203135360"></p>
<p>小顶堆特点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arr[i] &lt;= arr[<span class="number">2</span>*i+<span class="number">1</span>] &amp;&amp; arr[i] &lt;= arr[<span class="number">2</span>*i+<span class="number">2</span>] <span class="comment">// i 对应第几个节点，i从0开始编号</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</strong></p>
</li>
<li><p>一般升序采用大顶堆，降序采用小顶堆。</p>
</li>
</ul>
<h4 id="排序思路"><a href="#排序思路" class="headerlink" title="排序思路"></a>排序思路</h4><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p>
<ol>
<li>.假设给定无序序列结构如下</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219204046674.png" alt="image-20211219204046674"> </p>
<ol start="2">
<li>.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，<strong>第一个非叶子结点 arr.length&#x2F;2-1&#x3D;5&#x2F;2-1&#x3D;1</strong>，也就是下面的6结点），从左至右，从下至上进行调整。</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219204147281.png" alt="image-20211219204147281"> </p>
<ol start="3">
<li>.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219204201784.png" alt="image-20211219204201784"> </p>
<ol start="4">
<li>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219204212472.png" alt="image-20211219204212472"> </p>
<p>此时，我们就将一个无序序列构造成了一个大顶堆。</p>
<p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p>
<ol>
<li>.将堆顶元素9和末尾元素4进行交换</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219204325333.png" alt="image-20211219204325333"></p>
<ol start="2">
<li>.重新调整结构，使其继续满足堆定义</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219204335755.png" alt="image-20211219204335755"> </p>
<ol start="3">
<li>.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219204355530.png" alt="image-20211219204355530"> </p>
<ol start="4">
<li>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219204406676.png" alt="image-20211219204406676"> </p>
<h4 id="排序规则-3"><a href="#排序规则-3" class="headerlink" title="排序规则"></a>排序规则</h4><ol>
<li><strong>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆，整个序列的最大值&#x2F;最小值就是堆顶的根节点。</strong></li>
<li><strong>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></li>
<li><strong>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素（然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。），反复执行调整+交换步骤，直到整个序列有序。</strong></li>
<li><strong>代码实现：升序</strong></li>
</ol>
<h4 id="代码实现-20"><a href="#代码实现-20" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//对该数组进行升序排列</span></span><br><span class="line">        <span class="comment">//int[] arr = &#123;4, 6, 8, 5, 9,0,-1,22,-88&#125;;</span></span><br><span class="line">        <span class="comment">//heapSort(arr);</span></span><br><span class="line">        <span class="comment">//测试堆排序的速度   随机给80000个数  ---</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">800000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">800000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">800000</span>);<span class="comment">//[0,800000)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是：&quot;</span> + date1Str);</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(date2);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的时间是：&quot;</span> + date2Str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法实现堆排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//分步完成</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存进大顶堆</span></span><br><span class="line">        <span class="comment">//1)将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// arr.length / 2 - 1分叶子节点个数,i表示非叶子节点的下标</span></span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;调整后的堆为：&quot; + Arrays.toString(arr));</span></span><br><span class="line">        <span class="comment">//2)将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;</span></span><br><span class="line">        <span class="comment">//3)重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];<span class="comment">//调整好的堆 最大值肯定在数组的第一位</span></span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;堆排序的结果：&quot; + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个数组（二叉树）调整成一个大顶堆</span></span><br><span class="line"><span class="comment">     * 功能：将以i为父节点的树 调整成大顶堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i      i表示非叶子节点在数组中的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 对length个数据进行调整  没调整一次length-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];<span class="comment">//保存当前元素的值</span></span><br><span class="line">        <span class="comment">//调整</span></span><br><span class="line">        <span class="comment">// k = i * 2 + 1是i节点的左子结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;<span class="comment">//k + 1 &lt; length为了提高效率  arr[k] &lt; arr[k + 1]左子节点的值小于右子节点的值</span></span><br><span class="line">                k++;<span class="comment">//k指向右子结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; temp) &#123;<span class="comment">//子结点大于当前值</span></span><br><span class="line">                arr[i] = arr[k]; <span class="comment">//把两者中较大的值赋给当前节点arr[i]</span></span><br><span class="line">                i = k;<span class="comment">//i指向k继续循环比较</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//for循环结束后 以i为父节点的树的最大值已经放在了最顶部</span></span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp的值放在调整后的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>普通的队列是一种先进先出的数据结构，元素在队列尾追加,而从队列头删除。在某些情况下，我们可能需要找出队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求,优先队列。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219183323285.png" alt="image-20211219183323285"></p>
<p>优先队列按照其作用不同,可以分为以下两种：</p>
<ul>
<li>最大优先队列：<ul>
<li>可以获取并删除队列中最大的值</li>
</ul>
</li>
<li>最小优先队列：<ul>
<li>可以获取并删除队列中最小的值</li>
</ul>
</li>
</ul>
<h4 id="最大优先队列（大顶堆实现）"><a href="#最大优先队列（大顶堆实现）" class="headerlink" title="最大优先队列（大顶堆实现）"></a>最大优先队列（大顶堆实现）</h4><p>我们前面学习堆的时候，堆中存放数据元素的数组要满足都满足如下特性:</p>
<ol>
<li><strong>最大的元素放在数组的索引1处。</strong></li>
<li><strong>每个结点的数据总是大于等于它的两个子结点的数据。</strong></li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219195903190.png" alt="image-20211219195903190"></p>
<p>我们之前学习过堆,而堆这种结构是可以方便的删除最大的值,所以,接下来我们可以基于堆区实现最大优先队列。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219185354845.png" alt="image-20211219185354845"></p>
<h5 id="代码实现-21"><a href="#代码实现-21" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPriorityQueue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储队中的元素</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储堆中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，获取队列中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity];</span><br><span class="line">        <span class="built_in">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆中索引处的元素是否小于索引j处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆中i索引和j索引处的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">tmp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往堆中植入一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        items[++N] = t;<span class="comment">//添加至队尾</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除堆中最大的元素，并返回这个最大元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>, N);<span class="comment">//将索引为1和索引为N的元素交换</span></span><br><span class="line">        N--;<span class="comment">//移除</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line">    <span class="comment">//将添加至队尾的结点，上浮至正确的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;<span class="comment">//通过while循环比较当前结点和父元素的</span></span><br><span class="line">            <span class="keyword">if</span> (less(k / <span class="number">2</span>, k)) &#123;<span class="comment">//k/2处的值小于k处的值</span></span><br><span class="line">                exch(k / <span class="number">2</span>, k);<span class="comment">//交换k/2处、k处的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            k = k / <span class="number">2</span>;<span class="comment">//k指向k/2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line">    <span class="comment">//删除时，将队尾的值移动至k=1处，该方法用于将此值下沉至正确的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;<span class="comment">//通过while循环比较当前结点和子结点中较大结点的值</span></span><br><span class="line">            <span class="type">int</span> max;<span class="comment">//索引，记录子节点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N) &#123;<span class="comment">//有右子结点，左右节点作比较</span></span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k, <span class="number">2</span> * k + <span class="number">1</span>)) &#123;<span class="comment">//左子结点的值小于右子结点的值</span></span><br><span class="line">                    max = <span class="number">2</span> * k + <span class="number">1</span>;<span class="comment">//max记录右子结点的值</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span> * k;<span class="comment">//max记录左子结点的值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//直接返回左子结点</span></span><br><span class="line">                max = <span class="number">2</span> * k;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!less(k, max)) &#123;<span class="comment">//比较大小，如果当前结点大于子结点中的较大值</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前结点小于子结点中的较大值</span></span><br><span class="line">            exch(k, max);<span class="comment">//交换</span></span><br><span class="line"></span><br><span class="line">            k = max;<span class="comment">//k指向max</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxPriorityQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建优先队列</span></span><br><span class="line">        MaxPriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">MaxPriorityQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往队列中存储元素</span></span><br><span class="line">        queue.insert(<span class="number">1</span>);</span><br><span class="line">        queue.insert(<span class="number">2</span>);</span><br><span class="line">        queue.insert(<span class="number">3</span>);</span><br><span class="line">        queue.insert(<span class="number">4</span>);</span><br><span class="line">        queue.insert(<span class="number">5</span>);</span><br><span class="line">        queue.insert(<span class="number">6</span>);</span><br><span class="line">        queue.insert(<span class="number">7</span>);</span><br><span class="line">        queue.insert(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过循环从队列中获取最大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> queue.delMax();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最小优先队列（小顶堆）"><a href="#最小优先队列（小顶堆）" class="headerlink" title="最小优先队列（小顶堆）"></a>最小优先队列（小顶堆）</h4><p>最小优先队列实现起来也比较简单,我们同样也可以基于堆来完成最小优先队列。</p>
<p>实我们之前实现的堆可以把它叫做最大堆,我们可以用相反的思想实现最小堆,让堆中存放数据元素的数组满足如下特性:</p>
<ol>
<li><strong>最小的元素放在数组的索引1处。</strong></li>
<li><strong>每个结点的数据总是小于等于它的两个子结点的数据。</strong></li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219204711628.png" alt="image-20211219204711628"></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219205149992.png" alt="image-20211219205149992"></p>
<h5 id="代码实现-22"><a href="#代码实现-22" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinPriorityQueue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">//存储队中的元素</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储堆中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，获取队列中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆中索引处的元素是否小于索引j处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆中i索引和j索引处的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">tmp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往堆中植入一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        items[++N] = t;<span class="comment">//添加至队尾</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除堆中最小的元素，并返回这个最小元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">min</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>, N);<span class="comment">//将索引为1和索引为N的元素交换</span></span><br><span class="line">        N--;<span class="comment">//移除</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line">    <span class="comment">//将添加至队尾的结点，上浮至正确的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;<span class="comment">//通过while循环比较当前结点和父元素的大小</span></span><br><span class="line">            <span class="keyword">if</span> (less(k, k / <span class="number">2</span>)) &#123;<span class="comment">//k/2处的值大于k处的值</span></span><br><span class="line">                exch(k, k / <span class="number">2</span>);<span class="comment">//交换k/2处、k处的值，把较小的值往前放</span></span><br><span class="line">            &#125;</span><br><span class="line">            k = k / <span class="number">2</span>;<span class="comment">//k指向k/2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line">    <span class="comment">//删除时，将队尾的值移动至k=1处，该方法用于将此值下沉至正确的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;<span class="comment">//通过while循环比较当前结点和子结点中较大结点的值</span></span><br><span class="line">            <span class="type">int</span> min;<span class="comment">//索引，记录子节点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N) &#123;<span class="comment">//有右子结点，左右节点作比较</span></span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k, <span class="number">2</span> * k + <span class="number">1</span>)) &#123;<span class="comment">//左子结点的值小于右子结点的值</span></span><br><span class="line">                    min = <span class="number">2</span> * k;<span class="comment">//max记录左子结点的值</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    min = <span class="number">2</span> * k + <span class="number">1</span>;<span class="comment">//max记录右子结点的值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//直接返回左子结点</span></span><br><span class="line">                min = <span class="number">2</span> * k;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (less(k, min)) &#123;<span class="comment">//比较大小，如果当前结点小于子结点中的较小值</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前结点大于子结点中的较小值</span></span><br><span class="line">            exch(k, min);<span class="comment">//交换</span></span><br><span class="line"></span><br><span class="line">            k = min;<span class="comment">//k指向min</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinPriorityQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建优先队列</span></span><br><span class="line">        MinPriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往队列中存储元素</span></span><br><span class="line">        queue.insert(<span class="number">1</span>);</span><br><span class="line">        queue.insert(<span class="number">2</span>);</span><br><span class="line">        queue.insert(<span class="number">3</span>);</span><br><span class="line">        queue.insert(<span class="number">4</span>);</span><br><span class="line">        queue.insert(<span class="number">5</span>);</span><br><span class="line">        queue.insert(<span class="number">6</span>);</span><br><span class="line">        queue.insert(<span class="number">7</span>);</span><br><span class="line">        queue.insert(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过循环从队列中获取最大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> queue.delMax();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="索引优先队列"><a href="#索引优先队列" class="headerlink" title="索引优先队列"></a>索引优先队列</h4><h5 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h5><p>在之前实现的最大优先队列和最小优先队列，他们<strong>可以分别快速访问到队列中最大元素和最小元素</strong>，但是他们有一个缺点，就是<strong>没有办法通过索引访问已存在于优先队列中的对象</strong>，并更新它们。为了实现这个目的，在优先队列的基础上，学习一种新的数据结构，索引优先队列。接下来我们以<strong>最小优先队列举列</strong>。</p>
<h5 id="思路分析-20"><a href="#思路分析-20" class="headerlink" title="思路分析"></a>思路分析</h5><p><strong>步骤一：</strong></p>
<p>存储数据时，给每一个数据元素关联一个整数，例如insert(int k,T t)，我们可以看做k是t关联的整数，那么我们的实现需要通过k这个值，快速获取到队列中t这个元素，此时有个k这个值需要具有唯一性。</p>
<p>最直观的想法就是我们可以用一个T[] items数组来保存数据元素，在insert(int k.T t)完成插入时，可以把k看做是items数组的索引，把t元素放到items数组的索引k处，这样我们再根据k获取元素t时就很方便了》，直接就可以拿到items[k]即可。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219211028260.png" alt="image-20211219211028260"></p>
<p><strong>步骤二：</strong></p>
<p>步骤一完成后的结果,虽然我们给每个元素关联了一个整数，组可以使用这个整数快速的获取到该元素，但是， items数组中的元素顺序是随机的,并环是堆有序的，所以，为了完成这个求，我们可以增加一个数组int]pq，来保存每个元素在items数组中的索引，pq数组需要堆有序，也就是说，pq[1 ]对应的数据元素items[pq[1]要小于等于pq[2]和pq[3]对应的数据元素items[pq[]]和items[pq[3]]。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219211235969.png" alt="image-20211219211235969"></p>
<p><strong>步骤三</strong><br>通过步骤二的分析,我们可以发现，实我们通过上浮和下沉做堆调整的时候，其实调整的是pg数组。如果需要对items中的元素进行修改，比如让items[0]&#x3D;”H”，那么很显然，我们需要对pg中的数据做堆调整，且是调整pg[9]中元素的位置。但现在就会遇到一个问题，我们修改的是items数组中0索引处的值，如何才能快速的知道需要挑中pg[9]中元素的位置呢？</p>
<p>最直观的想法就是遍历pq数组，让每一个元素和0做比较，如果当前元索是0，那么调整该索引处的元索即可，但是效率很低。</p>
<p>我们可以另外增加一个数组，int[] qp,用来存储pq的逆序。例如：</p>
<ul>
<li><p>在pq数组中：pq[1]&#x3D;6；</p>
</li>
<li><p>那么在qp数组中；把6作为索引，1作为值,结果是：qp[6]&#x3D;1；</p>
</li>
</ul>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219212317243.png" alt="image-20211219212317243"></p>
<p>当有了pq数组后，如果我们修改item[0]&#x3D;”H”，那么就可以想通过索引0，在qp数组中找到qp的索引：qp[0]&#x3D;9，那么直接调整pq[9]即可。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219214153244.png" alt="image-20211219214153244"></p>
<h5 id="代码实现-23"><a href="#代码实现-23" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexMinPriorityQueue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">//存储堆中的元素</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">//存储每个元素在items数组中的索引，pq数组需要堆有序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] pq;</span><br><span class="line">    <span class="comment">//保存qp的逆序，pq的值作为索引，pq的索引作为值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] qp;</span><br><span class="line">    <span class="comment">//记录堆中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IndexMinPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.pq = <span class="keyword">new</span> <span class="title class_">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.qp = <span class="keyword">new</span> <span class="title class_">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认情况下，队列中没有存储任何数据，让qp的元素都为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; qp.length; i++) &#123;</span><br><span class="line">            qp[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">inEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆中索引为i,j两处元素的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[pq[i]].compareTo(items[pq[j]]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆中元素值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">//交换pq中的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时，更新qp中的数据</span></span><br><span class="line">        qp[pq[i]] = i;</span><br><span class="line">        qp[pq[j]] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断k对应的元素是否存在</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> qp[k] != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小元素关联的索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往队列中插入一个元素，并关联索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i, T t)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断i是否已经被关联，如果已经被关联，不让插入</span></span><br><span class="line">        <span class="keyword">if</span> (contains(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素个数+1</span></span><br><span class="line">        N++;</span><br><span class="line">        <span class="comment">//把数据存储到items对应的i位置处</span></span><br><span class="line">        items[i] = t;</span><br><span class="line">        <span class="comment">//把i存储到pq中</span></span><br><span class="line">        pq[N] = i;</span><br><span class="line">        <span class="comment">//用qp来记录pq的i</span></span><br><span class="line">        qp[i] = N;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保持堆有序</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除队列中最小的元素，并返回该元素关联的索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> pq[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 交换pq</span></span><br><span class="line">        exch(<span class="number">1</span>, N);</span><br><span class="line">        <span class="comment">// 删除qp中对应的内容</span></span><br><span class="line">        qp[pq[N]] = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 删除pq最大索引处的内容</span></span><br><span class="line">        pq[N] = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 删除items中对应的内容</span></span><br><span class="line">        items[minIndex] = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 元素个数-1</span></span><br><span class="line">        N--;</span><br><span class="line">        <span class="comment">// 下沉调整</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除索引i关联的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//找出i在pq中的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> pq[i];</span><br><span class="line">        exch(k, N);</span><br><span class="line">        qp[pq[N]] = -<span class="number">1</span>;</span><br><span class="line">        pq[N] = -<span class="number">1</span>;</span><br><span class="line">        items[k] = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="comment">// 因为元素k是在数组中的中间，所以需要先下沉再上浮，或者先上浮再下沉</span></span><br><span class="line">        sink(k);</span><br><span class="line">        swim(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改索引i关联的元素为t</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeItem</span><span class="params">(<span class="type">int</span> i, T t)</span> &#123;</span><br><span class="line">        items[i] = t;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> qp[i];</span><br><span class="line">        sink(k);</span><br><span class="line">        swim(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮算法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(k, k / <span class="number">2</span>)) &#123;</span><br><span class="line">                exch(k, k / <span class="number">2</span>); <span class="comment">//这里面已经更新了pq[]和qp[]</span></span><br><span class="line">            &#125;</span><br><span class="line">            k = k / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉算法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">            <span class="type">int</span> min;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k, <span class="number">2</span> * k + <span class="number">1</span>)) &#123;</span><br><span class="line">                    min = <span class="number">2</span> * k;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    min = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min = <span class="number">2</span> * k;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//比较当前结点和较小值</span></span><br><span class="line">            <span class="keyword">if</span> (less(k, min)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(k, min);</span><br><span class="line">            k = min; <span class="comment">//把最小值赋值给当前结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexMinPriorityQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IndexMinPriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexMinPriorityQueue</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        queue.insert(<span class="number">0</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        queue.insert(<span class="number">1</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        queue.insert(<span class="number">2</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        queue.insert(<span class="number">3</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        queue.insert(<span class="number">4</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">        queue.insert(<span class="number">5</span>, <span class="string">&quot;F&quot;</span>);</span><br><span class="line">        queue.insert(<span class="number">6</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        queue.insert(<span class="number">7</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">        queue.insert(<span class="number">8</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line"></span><br><span class="line">        queue.changeItem(<span class="number">0</span>, <span class="string">&quot;S&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.inEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> queue.delMin();</span><br><span class="line">            System.out.println(index+ <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赫尔曼树"><a href="#赫尔曼树" class="headerlink" title="赫尔曼树"></a>赫尔曼树</h3><h4 id="概述-14"><a href="#概述-14" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>给定n个权值作为n个<strong>叶子结点</strong>，构造一棵二叉树，<strong>若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树</strong>，也称为<strong>哈夫曼树</strong>(Huffman Tree)，还有的书翻译为<strong>霍夫曼树</strong>。</p>
</li>
<li><p>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
</li>
</ol>
<h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><ol>
<li><strong>路径和路径长度</strong>：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</li>
<li><strong>结点的权及带权路径长度</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。<strong>结点的带权路径长度为</strong>：从根结点到该结点之间的路径长度与该结点的权的乘积</li>
<li><strong>树的带权路径长度</strong>：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ，权值越大的结点离根结点越近的二叉树才是最优二叉树。</li>
<li><strong>WPL最小的就是赫夫曼树</strong></li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211216141821681.png" alt="image-20211216141821681"></p>
<h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><p>给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树。</p>
<h5 id="构成赫夫曼树的四个步骤"><a href="#构成赫夫曼树的四个步骤" class="headerlink" title="构成赫夫曼树的四个步骤"></a>构成赫夫曼树的四个步骤</h5><ol>
<li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树。</li>
<li>取出根节点权值最小的两颗二叉树 </li>
<li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  </li>
<li>再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1、2、3、4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树。</li>
</ol>
<p> <strong>{13, 7, 8, 3, 29, 6, 1}&#x3D;&gt;{1,3,6,7,8,13,29}</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211216175130270.png" alt="image-20211216175130270"></p>
<h5 id="代码实现-24"><a href="#代码实现-24" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> creatHuffmanTree(arr);</span><br><span class="line"></span><br><span class="line">        preOrder(node);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个前序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空树&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建赫夫曼树的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">creatHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//第一步为了操作方便</span></span><br><span class="line">        <span class="comment">//1.遍历arr数组</span></span><br><span class="line">        <span class="comment">//2.将arr的每个元素构成一个Node</span></span><br><span class="line">        <span class="comment">//3.将Node放入到ArrayList中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;<span class="comment">//最终只剩下一个最大的结点</span></span><br><span class="line">            <span class="comment">//排序（从小到大）,必须让Node实现Comparable接口</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出根节点权值最小的两颗二叉树</span></span><br><span class="line">            <span class="comment">//1.取出权值最小的结点（二叉树）</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//2.取出权值第二小的结点（二叉树）</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//3.构建一颗新的二叉树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//4.从ArrayList删除处理过的二叉树</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//5.将parent加入到nodes</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回哈夫曼树的root结点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建结点类</span></span><br><span class="line"><span class="comment">//为了让Node对象持续排序Collections结合排序</span></span><br><span class="line"><span class="comment">//让Node实现Comparable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    <span class="type">int</span> value;<span class="comment">//结点权值</span></span><br><span class="line">    Node left;<span class="comment">//指向左子结点</span></span><br><span class="line">    Node right;<span class="comment">//指向右子结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="comment">//表示从小到大</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value - o.value;</span><br><span class="line">        <span class="comment">//return -(this.value - o.value);//表示从大到小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211216175313977.png" alt="image-20211216175313977"></p>
<h3 id="赫尔曼编码"><a href="#赫尔曼编码" class="headerlink" title="赫尔曼编码"></a>赫尔曼编码</h3><h3 id="二叉树排序"><a href="#二叉树排序" class="headerlink" title="二叉树排序"></a>二叉树排序</h3><p>给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加。</p>
<h4 id="概述-15"><a href="#概述-15" class="headerlink" title="概述"></a>概述</h4><p>二叉排序树：BST: (Binary Sort(Search) Tree)，对于二叉排序树的任何一个非叶子节点，<strong>要求左子节点的值比当前节点的值小</strong>，<strong>右子节点的值比当前节点的值大</strong>。</p>
<p><strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点</p>
<p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211216181043914.png" alt="image-20211216181043914"></p>
<h4 id="思路分析-21"><a href="#思路分析-21" class="headerlink" title="思路分析"></a>思路分析</h4><p><strong>创建</strong></p>
<p>左子节点的值比当前节点的值小<strong>，</strong>右子节点的值比当前节点的值大。</p>
<p><strong>删除</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211216194145225.png" alt="image-20211216194145225"></p>
<p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑：</p>
<ol>
<li>第一种情况：<strong>删除叶子节点</strong> （比如：2，5，9，12）<ol>
<li>需求先去找到要删除的结点  targetNode</li>
<li>找到 targetNode 的 父结点 parent </li>
<li>确定 targetNode 是 parent的左子结点 还是右子结点</li>
<li>根据前面的情况来对应删除<ul>
<li>左子结点 parent.left &#x3D; null</li>
<li>右子结点 parent.right &#x3D; null;</li>
</ul>
</li>
</ol>
</li>
<li>第二种情况：<strong>删除只有一颗子树的节点</strong> （比如 1）<ol>
<li>需求先去找到要删除的结点  targetNode</li>
<li>找到 targetNode 的 父结点 parent </li>
<li>确定 targetNode 的子结点是左子结点还是右子结点</li>
<li>确定 targetNode 是 parent 的左子结点还是右子结点</li>
<li>如果 targetNode 有左子结点<ol>
<li>如果 targetNode 是 parent 的左子结点<ul>
<li>parent.left &#x3D; targetNode.left;</li>
</ul>
</li>
<li>如果 targetNode 是 parent 的右子结点<ul>
<li>parent.right &#x3D; targetNode.left;</li>
</ul>
</li>
</ol>
</li>
<li>如果 targetNode 有右子结点<ol>
<li>如果 targetNode 是 parent 的左子结点<br>parent.left &#x3D; targetNode.right;</li>
<li>如果 targetNode 是 parent 的右子结点<br>parent.right &#x3D; targetNode.right</li>
</ol>
</li>
</ol>
</li>
<li>情况三：<strong>删除有两颗子树的节点</strong> （比如：7，3，10 ）<ol>
<li>需求先去找到要删除的结点  targetNode</li>
<li>找到 targetNode 的父结点 parent </li>
<li>从 targetNode 的右子树找到最小的结点</li>
<li>用一个临时变量 temp ，将最小结点的值保存 （temp&#x3D;11）</li>
<li>删除该最小结点</li>
<li>targetNode.value &#x3D; temp</li>
</ol>
</li>
</ol>
<h4 id="代码实现-25"><a href="#代码实现-25" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySortTreeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">BinarySortTree</span> <span class="variable">binarySortTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySortTree</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序输出</span></span><br><span class="line">        binarySortTree.infisOrder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试删除叶子节点</span></span><br><span class="line">        binarySortTree.delNode(<span class="number">2</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">5</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">9</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试删除节点后&quot;</span>);</span><br><span class="line">        binarySortTree.infisOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySortTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;<span class="comment">//根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找想要删除的结点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要结点的父节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：返回以node为根节点的二叉排序树的最小节点的值 并删除以node为根节点的二叉排序树的最小节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的当做二叉树根节点的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回以node为根节点的二叉排序树的最小节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delRightTreeMin</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">target</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="comment">//循环的查找左节点 直到找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;<span class="comment">//退出循环时说明找到了 target指向的就是最小值</span></span><br><span class="line">        <span class="comment">//删除该最小值节点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;<span class="comment">//将最小结点的值返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：返回以node为根节点的二叉排序树的最大节点的值 并删除以node为根节点的二叉排序树的最大节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的当做二叉树根节点的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回以node为根节点的二叉排序树的最大节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delLeftTreeMax</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">target</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="comment">//循环的查找右节点 直到找到最大值</span></span><br><span class="line">        <span class="keyword">while</span> (target.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            target = target.right;</span><br><span class="line">        &#125;<span class="comment">//退出循环时说明找到了 target指向的就是最大值节点</span></span><br><span class="line">        <span class="comment">//删除该最大值节点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;<span class="comment">//将最大结点的值返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.需要先找到要删除的节点 targetNode</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//直接结束即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当这个二叉排序树只有一个节点,而且这个节点就是要查找删除的节点，直接置空删除即可</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.去找targetNode的父节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">            <span class="comment">//情况一：如果删除的节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left == <span class="literal">null</span> &amp;&amp; targetNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode是父节点的左子节点还是右子节点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="literal">null</span> &amp;&amp; parent.left.value == value) &#123;<span class="comment">//是左子节点</span></span><br><span class="line">                    <span class="comment">//说明要删除的targetNode就是要删除的</span></span><br><span class="line">                    parent.left = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="literal">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是右子节点</span></span><br><span class="line">                    parent.right = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="literal">null</span> &amp;&amp; targetNode.right != <span class="literal">null</span>) &#123;<span class="comment">//这个是情况三</span></span><br><span class="line">                <span class="comment">//删除的节点有两个子树</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> delRightTreeMin(targetNode.right);<span class="comment">//用个临时变量将最小结点的值保存</span></span><br><span class="line">                targetNode.value = minValue;<span class="comment">//重置value值</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//情况二，删除只有一颗子树的节点，因为前两种情况都排除了</span></span><br><span class="line">                <span class="comment">//如果要删除的节点有左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left != <span class="literal">null</span>) &#123;<span class="comment">//表示要删除的节点有左节点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;<span class="comment">//父节点存在</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            <span class="comment">//如果targetNode是parent的左子节点</span></span><br><span class="line">                            parent.left = targetNode.left;<span class="comment">//删除</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//说明targetNode是parent的右子节点</span></span><br><span class="line">                            parent.right = targetNode.left;<span class="comment">//删除</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//父节点不存在，且目前只有一颗左子树</span></span><br><span class="line">                        root = targetNode.left;<span class="comment">////删除</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//表示要删除的节点有右节点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;<span class="comment">//父节点存在</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            <span class="comment">//如果targetNode是parent的左子节点</span></span><br><span class="line">                            parent.left = targetNode.right;<span class="comment">//删除</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果targetNode是parent的右子节点</span></span><br><span class="line">                            parent.right = targetNode.right;<span class="comment">//删除</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//父节点不存在，且目前只有一颗右子树</span></span><br><span class="line">                        root = targetNode.right;<span class="comment">////删除</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infisOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.infisOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空树，不可遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建node节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> + <span class="string">&quot;value=&quot;</span> + value + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点</span></span><br><span class="line">    <span class="comment">//递归的形式添加结点，需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值，和当前子树的节点的值关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点</span></span><br><span class="line">            <span class="comment">//如果当前节点左子结点为null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向左子树添加</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infisOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infisOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infisOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到了返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="built_in">this</span>.value) &#123;<span class="comment">//找到就返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value) &#123;<span class="comment">//如果查找的值，小于当前节点，向左子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;<span class="comment">//如果左子树为空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);<span class="comment">//向左递归</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果查找的值不小于当前结点，享有字数递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);<span class="comment">//向右递归</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除结点的父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 要删除结点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要删除结点的父节点，就返回</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.value == value) || (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt;= value &amp;&amp; <span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//如果查找的值大于当前结点的值，且当前结点的左子结点不为空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.value &gt; value &amp;&amp; <span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//如果查找的值小于当前结点的值，且当前结点的右子结点不为空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//没有找到父节点，就返回空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h3><h4 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h4><p>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211218204644523.png" alt="image-20211218204644523"></p>
<p>左边BST 存在的问题分析:</p>
<ol>
<li>左子树全部为空，从形式上看，更像一个单链表。</li>
<li>插入速度没有影响</li>
<li>查询速度明显降低（因为需要依次比较），不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢</li>
<li>解决方案——平衡二叉树（AVL）</li>
</ol>
<h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树，可以<strong>保证查询效率较高</strong>。</li>
<li>具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有<strong>红黑树</strong>、<strong>AVL</strong>、<strong>替罪羊树</strong>、<strong>Treap</strong>、<strong>伸展树</strong>等。</li>
<li>举例说明，看看下面哪些AVL树，为什么?</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211218210230774.png" alt="image-20211218210230774"></p>
<h4 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h4><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><p>给你一个数列，创建出对应的平衡二叉树，数列 {4,3,6,5,7,8}</p>
<h5 id="思路分析-22"><a href="#思路分析-22" class="headerlink" title="思路分析"></a>思路分析</h5><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219141210314.png" alt="image-20211219141210314"></p>
<h5 id="代码实现-26"><a href="#代码实现-26" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左旋转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的节点，以当前节点为值</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">    <span class="comment">//把新节点的左子树设置为当前节点的左子树</span></span><br><span class="line">    newNode.left = left;</span><br><span class="line">    <span class="comment">//把新节点的右子树设置成当前结点右子树的左子树</span></span><br><span class="line">    newNode.right = right.left;</span><br><span class="line">    <span class="comment">//把当前节点的值替换成右子树的值</span></span><br><span class="line">    value = right.value;</span><br><span class="line">    <span class="comment">//把当前节点的右子树设置成指向当前结点右子树的右子树</span></span><br><span class="line">    right = right.right;</span><br><span class="line">    <span class="comment">//把当前节点的左子树（结点）指向新生成的结点</span></span><br><span class="line">    left = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219140912638.png" alt="image-20211219140912638"></p>
<p>之后：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219140851428.png" alt="image-20211219140851428"></p>
<h4 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h4><h5 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h5><p>给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}</p>
<h5 id="思路分析-23"><a href="#思路分析-23" class="headerlink" title="思路分析"></a>思路分析</h5><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219142008187.png" alt="image-20211219142008187"></p>
<h5 id="代码实现-27"><a href="#代码实现-27" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lightRotate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的节点，以当前节点为值</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">    <span class="comment">//把新节点的右子树设置为当前节点的右子树</span></span><br><span class="line">    newNode.right = right;</span><br><span class="line">    <span class="comment">//把新节点的左子树设置成当前结点左子树的右子树</span></span><br><span class="line">    newNode.left = left.right;</span><br><span class="line">    <span class="comment">//把当前节点的值替换成左子树的值</span></span><br><span class="line">    value = left.value;</span><br><span class="line">    <span class="comment">//把当前节点的左子树设置成指向当前结左子树的左子树</span></span><br><span class="line">    left = left.left;</span><br><span class="line">    <span class="comment">//把当前节点的右子树（结点）指向新生成的结点</span></span><br><span class="line">    right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>旋转前：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219142818308.png" alt="image-20211219142818308"></p>
<p>旋转后：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219142752812.png" alt="image-20211219142752812"></p>
<h4 id="双旋树"><a href="#双旋树" class="headerlink" title="双旋树"></a>双旋树</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树，但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列</p>
<p>int[] arr &#x3D; { 10, 11, 7, 6, 8, 9 };  运行原来的代码可以看到，并没有转成 AVL树.</p>
<p>int[] arr &#x3D; {2,1,6,5,7,3}; &#x2F;&#x2F; 运行原来的代码可以看到，并没有转成 AVL树</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219144705124.png" alt="image-20211219144705124"></p>
<h5 id="思路分析-24"><a href="#思路分析-24" class="headerlink" title="思路分析"></a>思路分析</h5><ol>
<li>当符号右旋转的条件时</li>
<li>如果它的左子树的右子树高度大于它的左子树的高度</li>
<li>先对当前这个结点的左节点进行左旋转（7）</li>
<li>在对当前结点进行右旋转的操作即可</li>
</ol>
<h5 id="代码实现-28"><a href="#代码实现-28" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双旋转</span></span><br><span class="line"><span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;<span class="comment">//右大于左</span></span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">null</span> &amp;&amp; right.rightHeight() &lt; right.leftHeight()) &#123;<span class="comment">//如果当前结点的右子树的左子树大于右子树的高度</span></span><br><span class="line">        right.rightRotate();<span class="comment">//对象前结点的右子树进行右旋转</span></span><br><span class="line">        leftRotate();<span class="comment">//再对当前节点进行左旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有上述情况，直接左旋转</span></span><br><span class="line">    leftRotate();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;<span class="comment">//左大于右</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; left.leftHeight() &lt; left.rightHeight()) &#123;<span class="comment">//如果当前节点的左子树的右子树大于左子树的高度</span></span><br><span class="line">        left.leftRotate();<span class="comment">//对当前节点的左子树进行左旋转</span></span><br><span class="line">        rightRotate();<span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有上述情况，直接右旋转</span></span><br><span class="line">    rightRotate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>方法类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVLTreeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr1[] = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="comment">//创建以一个AVLTree对象</span></span><br><span class="line">        <span class="type">AVLTree</span> <span class="variable">leftavlTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AVLTree</span>();</span><br><span class="line">        <span class="comment">//添加结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            leftavlTree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr1[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        leftavlTree.infisOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子树高度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;树的高度:&quot;</span> + leftavlTree.getRoot().height());</span><br><span class="line">        <span class="comment">//左子树高度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;左子树高度:&quot;</span> + leftavlTree.getRoot().leftHeight());</span><br><span class="line">        <span class="comment">//右子树高度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;右子树高度:&quot;</span> + leftavlTree.getRoot().rightHeight());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> arr2[] = &#123;<span class="number">10</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//创建以一个AVLTree对象</span></span><br><span class="line">        <span class="type">AVLTree</span> <span class="variable">rightavlTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AVLTree</span>();</span><br><span class="line">        <span class="comment">//添加结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">            rightavlTree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr2[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        rightavlTree.infisOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子树高度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;树的高度:&quot;</span> + rightavlTree.getRoot().height());</span><br><span class="line">        <span class="comment">//左子树高度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;左子树高度:&quot;</span> + rightavlTree.getRoot().leftHeight());</span><br><span class="line">        <span class="comment">//右子树高度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;右子树高度:&quot;</span> + rightavlTree.getRoot().rightHeight());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> arr3[] = &#123;<span class="number">10</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//创建以一个AVLTree对象</span></span><br><span class="line">        <span class="type">AVLTree</span> <span class="variable">avlTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AVLTree</span>();</span><br><span class="line">        <span class="comment">//添加结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr3.length; i++) &#123;</span><br><span class="line">            avlTree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr3[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        avlTree.infisOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子树高度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;树的高度:&quot;</span> + avlTree.getRoot().height());</span><br><span class="line">        <span class="comment">//左子树高度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;左子树高度:&quot;</span> + avlTree.getRoot().leftHeight());</span><br><span class="line">        <span class="comment">//右子树高度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;右子树高度:&quot;</span> + avlTree.getRoot().rightHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&#123;value=<span class="number">3</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">4</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">5</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">6</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">7</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">8</span>&#125;</span><br><span class="line">树的高度:<span class="number">3</span></span><br><span class="line">左子树高度:<span class="number">2</span></span><br><span class="line">右子树高度:<span class="number">2</span></span><br><span class="line">Node&#123;value=<span class="number">6</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">7</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">8</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">9</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">10</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">12</span>&#125;</span><br><span class="line">树的高度:<span class="number">3</span></span><br><span class="line">左子树高度:<span class="number">2</span></span><br><span class="line">右子树高度:<span class="number">2</span></span><br><span class="line">Node&#123;value=<span class="number">6</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">7</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">8</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">9</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">10</span>&#125;</span><br><span class="line">Node&#123;value=<span class="number">12</span>&#125;</span><br><span class="line">树的高度:<span class="number">3</span></span><br><span class="line">左子树高度:<span class="number">2</span></span><br><span class="line">右子树高度:<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>右大于左，左旋转</strong></p>
<p><strong>左大于右，右旋转</strong></p>
<p>add方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加结点</span></span><br><span class="line"><span class="comment">//递归的形式添加结点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断传入的节点的值，和当前子树的节点的值关系</span></span><br><span class="line">    <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点</span></span><br><span class="line">        <span class="comment">//如果当前节点左子结点为null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//递归的向左子树添加</span></span><br><span class="line">            <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//递归的向右子树添加</span></span><br><span class="line">            <span class="built_in">this</span>.right.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当添加完一个节点后，右子树与左子树的高度差&gt;1，就是用AVL</span></span><br><span class="line">    <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;<span class="comment">//右大于左</span></span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;<span class="comment">//左大于右</span></span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双旋转</span></span><br><span class="line">    <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;<span class="comment">//右大于左</span></span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span> &amp;&amp; right.rightHeight() &gt; right.leftHeight()) &#123;<span class="comment">//如果当前结点的右子树的左子树大于右子树的高度</span></span><br><span class="line">            right.rightRotate();<span class="comment">//对象前结点的右子树进行右旋转</span></span><br><span class="line">            leftRotate();<span class="comment">//再对当前节点进行左旋转</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有上述情况，直接左旋转</span></span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;<span class="comment">//左大于右</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; left.leftHeight() &gt; left.rightHeight()) &#123;<span class="comment">//如果当前节点的左子树的右子树大于左子树的高度</span></span><br><span class="line">            left.leftRotate();<span class="comment">//对当前节点的左子树进行左旋转</span></span><br><span class="line">            rightRotate();<span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有上述情况，直接右旋转</span></span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h1><h2 id="二叉树与B树"><a href="#二叉树与B树" class="headerlink" title="二叉树与B树"></a>二叉树与B树</h2><h3 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219151929265.png" alt="image-20211219151929265"></p>
<ul>
<li>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)，就存在如下问题：<ul>
<li><strong>问题1：</strong>在构建二叉树时，需要多次进行I&#x2F;O操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响</li>
<li><strong>问题2：</strong>节点海量，也会造成二叉树的高度很大，会降低操作速度。</li>
</ul>
</li>
</ul>
<h3 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h3><ol>
<li>在二叉树中，每个节点有数据项，最多有两个子节点。如果<strong>允许每个节点可以有更多的数据项和更多的子节点</strong>，就是<strong>多叉树</strong>（multiway tree）</li>
<li><strong>后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化</strong>。</li>
<li>举例说明(下面2-3树就是一颗多叉树)</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219153313282.png" alt="image-20211219153313282"></p>
<h3 id="B数"><a href="#B数" class="headerlink" title="B数"></a>B数</h3><p>B树通过重新组织节点，降低树的高度，并且减少i&#x2F;o读写次数来提升效率。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219153543425.png" alt="image-20211219153543425"></p>
<ol>
<li><strong>如图B树通过重新组织节点， 降低了树的高度</strong>。</li>
<li><strong>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I&#x2F;O就可以完全载入</strong>。</li>
<li>将树的度M设置为1024，在600亿个元素中最多只需要4次I&#x2F;O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中</li>
</ol>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>2-3树是最简单的B树结构，为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切的说，我们将一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两条链)，而现在我们引入3-结点，它含有两个键和三条链。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。</p>
<ul>
<li>2-结点：<ul>
<li>含有<strong>一个键</strong>(及其对应的值)和<strong>两条链</strong>，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。</li>
</ul>
</li>
<li>3-结点：<ul>
<li>含有<strong>两个键</strong>(及其对应的值)和<strong>三条链</strong>，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</li>
</ul>
</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.</li>
<li>2-3树是由二节点和三节点构成的树。</li>
</ol>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219233401095.png" alt="image-20211219233401095"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ol>
<li><strong>2-3树的所有叶子节点都在同一层。(只要是B树都满足这个条件)</strong></li>
<li><strong>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。</strong></li>
<li><strong>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。</strong></li>
<li><strong>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件。</strong> </li>
<li><strong>对于三节点的子树的值大小仍然遵守。(BST 二叉排序树)的规则)</strong></li>
</ol>
<h4 id="1-向2-结点中插入新键"><a href="#1-向2-结点中插入新键" class="headerlink" title="1.向2-结点中插入新键"></a>1.向2-结点中插入新键</h4><p>往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找,然后将节点挂到未找到的节点上。2-3树之所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一个2-结点，那么很容易，我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。但是如果查找的节点结束于一个3-结点，那么可能有点麻烦。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219235107064.png" alt="image-20211219235107064"></p>
<h4 id="2-向一棵只含有一个3-结点的树中插入新键"><a href="#2-向一棵只含有一个3-结点的树中插入新键" class="headerlink" title="2.向一棵只含有一个3-结点的树中插入新键"></a>2.向一棵只含有一个3-结点的树中插入新键</h4><p>假设2-3树只包含一个3-结点，这个结点有两个键,没有空间来插入第三个键了，最自然的方式是我们假设这个结点能存放三个元素,暂时使其变成一个4结点，同时他包含四条链接。然后，我们将这个4结点的中间元素提升，左边的键作为左子结点，右边的键作为其右子结点。插入完成,变为平衡2-3查找树，树的高度从0变为1。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219235141319.png" alt="image-20211219235141319"></p>
<h4 id="3-向一个父节点为2-结点的3-结点中插入新键"><a href="#3-向一个父节点为2-结点的3-结点中插入新键" class="headerlink" title="3.向一个父节点为2-结点的3-结点中插入新键"></a>3.向一个父节点为2-结点的3-结点中插入新键</h4><p>和上面的情况一样，我们也可以将新的元素插入到3-结点中，使其成为一个临时的4-结点，然后，将该结点中的中间元素提升到父结点即2结点中，使其父结点成为一个3-结点，然后将左右结点分别挂在这个3-结点的恰当位置。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220000544831.png" alt="image-20211220000544831"></p>
<h4 id="4-向一个父节点为3-结点的3-结点中插入新键"><a href="#4-向一个父节点为3-结点的3-结点中插入新键" class="headerlink" title="4.向一个父节点为3-结点的3-结点中插入新键"></a>4.向一个父节点为3-结点的3-结点中插入新键</h4><p>当我们插入的结点是3结点的时候，我们将该结点拆分，中间元素提升至父结点，但是此时父结点是一个3结点 ，插入之后，父结点变成了4结点，然后继续将中间元素提升至其父结点,直至遇到一个父结点是2-结点，然后将其变为3结点，不需要继续进行拆分。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220001414749.png" alt="image-20211220001414749"></p>
<h4 id="5-分解根节点"><a href="#5-分解根节点" class="headerlink" title="5.分解根节点"></a>5.分解根节点</h4><p>当插入结点到根结点的路径上全部是3结点的时候，最终我们的根结点会编程一个临时的4-结点，此时，就需要将根结点拆分为两个2-结点，树的高度加1。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220002030847.png" alt="image-20211220002030847"></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>通过对2-3树插入操作的分析,我们发现在插入的时候, 2-3树需要做一些局部的变换来保持2-3树的平衡。</p>
<p>一棵完全平衡的2-3树具有以下性质:</p>
<ol>
<li>任意空链接到根结点的路径长度都是相等的。</li>
<li>4-结点变换为3-结点时，树的高度不会发生变化（4），只有当根结点是临时的4-结点。分解根结点时，树高+1（5）。</li>
<li>2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>直接实现2-3树比较复杂,因为：</p>
<ul>
<li>要处理不同的结点类型,非常繁琐；</li>
<li>需要多次比较操作来将结点下移；</li>
<li>要上移来拆分4-结点；</li>
<li>拆分4结点的情况有很多种；</li>
</ul>
<p>2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。但是2-3查找树作为一种比较重要的概念和思路对于我们后面要讲到的红黑树、B树和B+树非常重要。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="概述-16"><a href="#概述-16" class="headerlink" title="概述"></a>概述</h3><p>我们前面介绍了2-3树,可以看到2-3树能保证在插入元素之后，树依然保持平衡状态，它的最坏情况下所有子结点都是2-结点，树的高度为IogN，相比于我们普通的二叉查找树，最坏情况下树的高度为N，确实保证了最坏情况下的时间复杂度，但是2-3树实现起来过于复杂，所以我们介绍一种2-3树思想的简单实现：红黑树。<br>红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树。我们将树中的链接分为两种类型：</p>
<p><strong>红链接：</strong>将两个2-结点连接起来构成一个3-结点</p>
<p><strong>黑链接：</strong>则是2-3树中的普遍链接</p>
<p>确切的说，我们将3-结点表示为由一条左斜的红色链接(两个2结点其中之一是另一个的左子结点相连的两个2结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220085822472.png" alt="image-20211220085822472"></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>红黑树是含有红黑链接并满足下列条件的二叉查找树：</p>
<ol>
<li>红链接均为左链接；</li>
<li>没有任何一个结点同时和两条红链按相连；（存在四链接）</li>
<li>该树是完美黑色平衡的，即任意空链按到根结点的路径上的黑链接数量相同；</li>
</ol>
<p>下面是红黑树与2-3树的对应关系：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220090433898.png" alt="image-20211220090433898"></p>
<h3 id="思路分析-25"><a href="#思路分析-25" class="headerlink" title="思路分析"></a>思路分析</h3><p>用一个boolean值来表示颜色，true为红链接，false为黑链接。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220091340979.png" alt="image-20211220091340979"></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220091454829.png" alt="image-20211220091454829"></p>
<h3 id="树的操作"><a href="#树的操作" class="headerlink" title="树的操作"></a>树的操作</h3><h4 id="平衡化"><a href="#平衡化" class="headerlink" title="平衡化"></a>平衡化</h4><p>在对红黑树进行一些增删改查的操作后，很有可能会出现红色的右链接或者两条连续红色的链接，而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。</p>
<h5 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h5><p>&#x3D;&#x3D;当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋 。（必须保证左子结点为红色）&#x3D;&#x3D;</p>
<p>前提： 当前结点为 h ，它的右子结点为 x ；</p>
<p>左旋过程：</p>
<ol>
<li>让 x 的左子结点变为 h 的右子结点： h.right&#x3D;x.left；</li>
<li>让 h 成为 x 的左子结点： x.left&#x3D;h；</li>
<li>让x 的 color 属性变为h 的 color 属性值： x.color&#x3D;h.color；</li>
<li>让 h 的 color 属性变为红色 ： h.color&#x3D;true；</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220093454129.png" alt="image-20211220093454129"></p>
<h5 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h5><p>&#x3D;&#x3D;当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋。&#x3D;&#x3D;</p>
<p>前提： 当前结点为 h ，它的左子结点为 x ；</p>
<p>右旋过程：</p>
<ol>
<li>让 x 的右子结点成为 h 的左子结点： h.left &#x3D; x.right;</li>
<li>让 h 成为 x 的右子结点： x.right&#x3D;h;</li>
<li>让 x 的 color 变为 h 的 color 属性值： x.color &#x3D; h.color;</li>
<li>让h 的 color 为红色 ；</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220093406092.png" alt="image-20211220093406092"></p>
<p>但是右旋后，还是不符合红黑树的定义，这时候还需要一个&#x3D;&#x3D;<strong>颜色反转</strong>&#x3D;&#x3D;的操作。</p>
<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><h5 id="1-向单个2-结点中插入新键"><a href="#1-向单个2-结点中插入新键" class="headerlink" title="1.向单个2-结点中插入新键"></a>1.向单个2-结点中插入新键</h5><ol>
<li><p>如果新键小于当前结点的键，我们只需要新增一个红色结点即可。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220094135825.png" alt="image-20211220094135825"></p>
</li>
<li><p>如果新键大于当前结点的键，那么新增的红色结点将会产生一条红色的右链接，此时我们需要通过左旋，把红色右链接变成左链接，插入操作才算完成。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220094114350.png" alt="image-20211220094114350"></p>
</li>
</ol>
<h5 id="2-向底部的2-结点插入新键"><a href="#2-向底部的2-结点插入新键" class="headerlink" title="2.向底部的2-结点插入新键"></a>2.向底部的2-结点插入新键</h5><p>我们会用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么刚才讨论的两种方式仍然适用。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220094425480.png" alt="image-20211220094425480"></p>
<h5 id="3-颜色反转"><a href="#3-颜色反转" class="headerlink" title="3.颜色反转"></a>3.颜色反转</h5><p>当一个结点的左子结点和右子结点的 color 都为 RED 时，也就是出现了临时的 4- 结点，此时只需要把左子结点和右子点的颜色变为BLACK ，同时让当前结点的颜色变为 RED 即可。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220094522060.png" alt="image-20211220094522060"></p>
<h5 id="4-向一个双键树中插入新键"><a href="#4-向一个双键树中插入新键" class="headerlink" title="4.向一个双键树中插入新键"></a>4.向一个双键树中插入新键</h5><ol>
<li><p>新键大于原树中的两个键</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220094621838.png" alt="image-20211220094621838"></p>
</li>
<li><p>新键小于原树中的两个键</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220095657623.png" alt="image-20211220095657623"></p>
</li>
<li><p>新键介于原数中两个键之间</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220100250376.png" alt="image-20211220100250376"></p>
</li>
</ol>
<h5 id="5-根结点的颜色总是黑色"><a href="#5-根结点的颜色总是黑色" class="headerlink" title="5.根结点的颜色总是黑色"></a>5.根结点的颜色总是黑色</h5><p>在结点 Node 对象中 color 属性表示的是父结点指向当前结点的连接的颜色，由于根结点不存在父结点， <strong>所以每次插入操作后，我们都需要把根结点的颜色设置为黑色</strong> 。</p>
<h5 id="6-向树底部的3-结点插入新键"><a href="#6-向树底部的3-结点插入新键" class="headerlink" title="6.向树底部的3-结点插入新键"></a>6.向树底部的3-结点插入新键</h5><p>假设在树的底部的一个 3- 结点下加入一个新的结点。前面我们所讲的 3 种情况都会出现。指向新结点的链接可能是 3-结点的右链接（此时我们只需要转换颜色即可），或是左链接 ( 此时我们需要进行右旋转然后再转换 ) ，或是中链 接( 此时需要先左旋转然后再右旋转，最后转换颜色 ) 。颜色转换会使中间结点的颜色变红，相当于将它送入了父结点。这意味着父结点中继续插入一个新键，我们只需要使用相同的方法解决即可，直到遇到一个2- 结点或者根结点为止。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220100718754.png" alt="image-20211220100718754"></p>
<h4 id="代码实现-29"><a href="#代码实现-29" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220101107115.png" alt="image-20211220101107115"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//红黑树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBlackTree</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; root;</span><br><span class="line">    <span class="comment">//结点个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="comment">//直接true、false可读性不高</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//红</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//黑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//结点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="comment">//存储键</span></span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="comment">//存储值</span></span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        <span class="comment">//记录左子结点</span></span><br><span class="line">        <span class="keyword">private</span> Node&lt;K, V&gt; left;</span><br><span class="line">        <span class="comment">//记录右子结点</span></span><br><span class="line">        <span class="keyword">private</span> Node&lt;K, V&gt; right;</span><br><span class="line">        <span class="comment">//我们将指向该结点的连接定义成颜色。</span></span><br><span class="line">        <span class="comment">//在红黑树中，根节点是一个比较特殊的结点，它的连接一定是黑色的，因为没有任何结点指向它/</span></span><br><span class="line">        <span class="comment">//由其父节点指向它的链接的颜色</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; left, Node&lt;K, V&gt; right, <span class="type">boolean</span> color)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedBlackTree</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取树中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断树是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 判断指向该结点的连接是否为红色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRed</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">        <span class="comment">//如果为null，我们认为其连接是黑色的</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> node.color == RED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为红黑树本身一个种平衡树。所以我们要进行树的平衡化。使整个树平衡（意思就是：在数进行增删改查操作时不破坏红黑树的规则）:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node h结点的右连接为红，我们需要将该红链接改到左面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node 返回更改后满足条件的结点（更改后的结点并不是h了，是h的右子节点）</span></span><br><span class="line"><span class="comment">     * 左旋目的：是为了有4-结点时操作</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 由于传进来的这个结点应该还是其父节点的，所以我们要返回修改后的结点作为其原来父节点的左/右结点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">rotateLeft</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">        <span class="comment">//获取node结点的右子节点rightnode</span></span><br><span class="line">        Node&lt;K, V&gt; rightnode = node.right;</span><br><span class="line">        <span class="comment">//将rightnode的左子节点作为当前结点的右子节点(因为rightnode的左子节点必比node大)</span></span><br><span class="line">        node.right = rightnode.left;</span><br><span class="line">        <span class="comment">//将node作为rightnode的左子节点</span></span><br><span class="line">        rightnode.left = node;</span><br><span class="line">        <span class="comment">//将node的颜色复制给rightnode颜色，因为之前与上面连接的是h，该后就变成rightnode了</span></span><br><span class="line">        rightnode.color = node.color;</span><br><span class="line">        <span class="comment">//node的颜色为红色</span></span><br><span class="line">        node.color = RED;</span><br><span class="line">        <span class="comment">//返回新的结点</span></span><br><span class="line">        <span class="keyword">return</span> rightnode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node node结点和其左子结点（leftnode）的连接和 leftnode和leftnode的左子结点的左子树连接都为红，我们需要进行右旋操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node 返回更改后的结点（更改后，返回为：node与其左子结点和其右子结点的连接都为红。但是显然，这样也不行，因为还是构成了一个4-结点，所以我们好需要一步操作：”颜色反转“）</span></span><br><span class="line"><span class="comment">     * 右旋目的：当出现当出现一个结点的两个连接都为红链接时，说明这是一个4-结点，但是红黑树/2-3树不允许4-结点的存在</span></span><br><span class="line"><span class="comment">     * 函数作用：“将node结点和其左子结点（leftnode）的连接和 leftnode和leftnode的左子结点的左子树连接都为红” 修改为： “该结点与其左子结点和其右子结点的连接都为红”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">rotateRight</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">        <span class="comment">//获取h的左子节点leftnode</span></span><br><span class="line">        Node&lt;K, V&gt; leftnode = node.left;</span><br><span class="line">        <span class="comment">//leftnode的右子节点作为node的左子节点</span></span><br><span class="line">        node.left = leftnode.right;</span><br><span class="line">        <span class="comment">//node作为leftnode的右子节点</span></span><br><span class="line">        leftnode.right = node;</span><br><span class="line">        <span class="comment">//把node的颜色赋值给leftnode的颜色</span></span><br><span class="line">        leftnode.color = node.color;</span><br><span class="line">        <span class="comment">//让node的颜色为红色</span></span><br><span class="line">        node.color = RED;</span><br><span class="line">        <span class="comment">//返回修改后满足条件的结点</span></span><br><span class="line">        <span class="keyword">return</span> leftnode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转颜色：即将右旋后的结果在进行处理，使其恢复红黑树的规则</span></span><br><span class="line"><span class="comment">     * 这个方法就比较简单了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node node结点的左右子树连接都为红色时，进行修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flipColors</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">        <span class="comment">//让node的左子节点和右子结点的颜色变成黑色</span></span><br><span class="line">        node.left.color = BLACK;</span><br><span class="line">        node.right.color = BLACK;</span><br><span class="line">        <span class="comment">//node结点的颜色变为红色</span></span><br><span class="line">        node.color = RED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于我们想要实现平衡树，所以每次插入都让其连接为红色，然后使整颗树平衡</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        root = put(root, key, value);</span><br><span class="line">        <span class="comment">//因为红黑树结构可能发生改变，根节点的颜色可能发生改变</span></span><br><span class="line">        <span class="comment">//根节点的颜色总是黑色的</span></span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * insert重载方法，向指定树中插入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  指定树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   插入的键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 插入的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的结点是插入后的根节点（因为插入后可能会引起树根节点的变化）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">put</span><span class="params">(Node&lt;K, V&gt; node, K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果node为空，那么直接返回一个红色的结点即可</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, <span class="literal">null</span>, <span class="literal">null</span>, RED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断插入元素与当前结点key值的大小关系,(cmp&lt;0说明前面的小)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> node.key.compareTo(key);<span class="comment">//比较</span></span><br><span class="line">        <span class="comment">//如果比当前元素小</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;<span class="comment">//大于，继续左递归查找</span></span><br><span class="line">            node.left = put(node.left, key, value);<span class="comment">//递归寻找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;<span class="comment">//小于，继续右递归查找</span></span><br><span class="line">            node.right = put(node.right, key, value);<span class="comment">//同理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//key相等，说明执行的不是增加，是修改</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们需要判断插入后，如果不满足红黑树的定义，我们要把它改成满足红黑树的样子</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left)) &#123;<span class="comment">//当当前结点的左子结点为黑色，右子结点为红色</span></span><br><span class="line">            node = rotateLeft(node);<span class="comment">//左旋</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123;<span class="comment">//当当前结点的左子结点为红色，左子结点的左子结点还是红色</span></span><br><span class="line">            node = rotateRight(node);<span class="comment">//右旋</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed((node.right))) &#123;<span class="comment">//当当前节点的左子节点和右子结点都为红色时</span></span><br><span class="line">            flipColors(node);<span class="comment">//颜色反转</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取整个树的key所对应value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 找到的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get的重载方法，找到某棵树上的键所对应的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 某个结点/树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 找到的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> V <span class="title function_">get</span><span class="params">(Node&lt;K, V&gt; node, K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//为空</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> node.key.compareTo(key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;<span class="comment">//大于，向左递归，继续查找</span></span><br><span class="line">            <span class="keyword">return</span> get(node.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;<span class="comment">//小于，向右递归，继续查找</span></span><br><span class="line">            <span class="keyword">return</span> get(node.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到，输出value值</span></span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedBlackTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建树</span></span><br><span class="line">        RedBlackTree&lt;Integer, String&gt; tree = <span class="keyword">new</span> <span class="title class_">RedBlackTree</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存入元素</span></span><br><span class="line">        tree.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        tree.put(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        tree.put(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        tree.put(<span class="number">4</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        tree.put(<span class="number">5</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">        tree.put(<span class="number">6</span>, <span class="string">&quot;F&quot;</span>);</span><br><span class="line">        tree.put(<span class="number">7</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        tree.put(<span class="number">8</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">        tree.put(<span class="number">9</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; tree.size(); i++) &#123;</span><br><span class="line">            System.out.println(tree.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220113037434.png" alt="image-20211220113037434"></p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(logn)的时间复杂度进行查找、 顺序读取、插入和删除等操作。</p>
<p>前面已经介绍了2-3树和2-3-4树，他们就是B树(英语：B-tree 也写成B-树)，这里我们再做一个说明，我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219173715288.png" alt="image-20211219173715288"></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多,并不确定，需要看具体的实现。现在我们选择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：</p>
<ul>
<li>每个结点最多有M-1个key，并组以升排列：</li>
<li>每个结点最多能有M个子结点：</li>
<li>根结点至少有两个子结点：</li>
</ul>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220115724811.png" alt="image-20211220115724811"></p>
<p>在实际应用中B树的阶数一般都比较大(通常大于100 ) ，所以，即使存储大量的数据，B树的高度仍然比较小，这样在某些应用场景下，就可以体现出它的优势。</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B树为例，看看B树的数据存储。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220120829657.png" alt="image-20211220120829657"></p>
<p><strong>B树的说明：</strong></p>
<ol>
<li><strong>B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</strong></li>
<li><strong>B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</strong></li>
<li><strong>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.</strong></li>
<li><strong>搜索有可能在非叶子结点结束</strong></li>
<li><strong>其搜索性能等价于在关键字全集内做一次二分查找</strong></li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。</p>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>磁盘能够保存大量的数据,从GB-直到TB级 ,但是他的读取速度比较慢,因为涉及到机器操作,读取速度为毫秒级。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220121117356.png" alt="image-20211220121117356"></p>
<p>磁盘由盘片构成，每个盘片有两面,又称为盘面。盘片中央有一个可以旋转的主轴，他使得盘片以固定的旋转速率旋转，通常是5400rpm或者是7200rpm，一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内 。盘片的每个表面是由一组称为磁道同心圆组成的，每个磁道被划分为了一组扇区，每一个扇区包含相等数量的数据位，通常是512个子节，扇区之间由一些间隙隔开，这些间隙中不存储数据。</p>
<h4 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220121237801.png" alt="image-20211220121237801"></p>
<p>磁盘用磁头来读写存储在盘片表面的位，而磁头连接到一个移动臂上，移动臂沿着盘片半径前后移动，可以将磁头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到该位的值,也可以修改值。对磁盘的访问时间分为<strong>寻道时间</strong>，<strong>旋转时间</strong>，以及<strong>传送时间</strong>。</p>
<p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此<strong>为了提高效率，要尽量减少磁盘I&#x2F;O，减少读写操作</strong>。为了到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<strong>局部性原理</strong>：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此预读可以提高I&#x2F;O效率。</p>
<p><strong>页是计算机管理存储器的逻辑块</strong>，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（1024个字节或其整数倍），预读的长度一般为页的整倍数。</p>
<p>文件系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页（1024个字节或其整数倍），这样每个结点只需要一次I&#x2F;O就可以完全载入。那么3层的B树可以容纳1024 *1024 *1024差不多10亿个数据，如果换成二叉查找树，则需要30层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在10亿个数据中查找目标值，只需要小于3次硬盘读取就可以找到目标值，但红黑树需要小于30次，因此<strong>B树大大提高了IO的操作效率</strong>。</p>
<p><strong>小结</strong></p>
<ol>
<li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li>
<li>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>
</ol>
<p><strong>再举例</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220130163734135.png" alt="image-20220130163734135"></p>
<h2 id="B-数"><a href="#B-数" class="headerlink" title="B+数"></a>B+数</h2><p>B+树也是一种多路搜索树，<strong>基于B树做出了改进</strong>，主流的DBMS都支持B+树的索引方式，比如MySQL。相比于B-Tree，<strong>B+Tree适合文件索引系统</strong>。</p>
<p>B+树是对B树的一种变形树，它与B树的差异在于：</p>
<ol>
<li>非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；</li>
<li>树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219173823083.png" alt="image-20211219173823083"></p>
<h3 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h3><p>若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B+树为例，看看B+树的数据存储。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220123952003.png" alt="image-20211220123952003"></p>
<p><strong>B+树的说明:</strong></p>
<ol>
<li><strong>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</strong></li>
<li><strong>&#x3D;&#x3D;所有关键字都出现在叶子结点的链表中&#x3D;&#x3D;（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</strong></li>
<li><strong>不可能在非叶子结点命中</strong></li>
<li><strong>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</strong></li>
<li><strong>更适合文件索引系统</strong></li>
<li><strong>&#x3D;&#x3D;B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然&#x3D;&#x3D;.</strong></li>
</ol>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>在<strong>数据库</strong>的操作中，<strong>查询</strong>操作可以说是最频繁的一种操作，因此在设计数据库时，必须要考虑到查询的效率问题， 在很多数据库中，都是用到了B+树来提高查询的效率；</p>
<p>在操作数据库时，我们为了提高查询效率，<strong>可以基于某张表的某个字段建立索引</strong>，就可以提高查询效率，那其实<strong>这个索引就是 B+ 树这种数据结构实现的</strong>。</p>
<h4 id="未建立主键索引的查询"><a href="#未建立主键索引的查询" class="headerlink" title="未建立主键索引的查询"></a>未建立主键索引的查询</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220124945572.png" alt="image-20211220124945572"></p>
<p>执行 &#x3D;&#x3D;select * from user where id&#x3D;18&#x3D;&#x3D; 需要从第一条数据开始，一直查询到第6条，发现id&#x3D;18，此时才能查询出目标结果,共需要比较6次；</p>
<h4 id="建立主键索引的查询"><a href="#建立主键索引的查询" class="headerlink" title="建立主键索引的查询"></a>建立主键索引的查询</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220125235822.png" alt="image-20211220125235822"></p>
<p>执行 &#x3D;&#x3D;select * from user where id&#x3D;18&#x3D;&#x3D; 时，从索引开始查，效率提高；</p>
<h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>执行&#x3D;&#x3D;select * from user where id&gt;&#x3D;12 and id&lt;&#x3D;18&#x3D;&#x3D; ，如果有了索引，由于B+树的叶结点形成了一个有序链表，所以我们只需要找到id为12的叶子结点，按照遍历链表的方式顺序往后查即可，效率非常高。</p>
<h2 id="B树和B-树的对比"><a href="#B树和B-树的对比" class="headerlink" title="B树和B+树的对比"></a>B树和B+树的对比</h2><p><strong>B+树的优点：</strong></p>
<ol>
<li><strong>由于 B+ 树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下， 能够存放更多的 key 。</strong></li>
<li><strong>B+树的叶子结点都是相连的</strong>，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且<strong>由于数据顺序排列并且相连，所以便于区间查找和搜索</strong>。而B树则需要进行每一层的递归遍历。</li>
</ol>
<p><strong>B树的优点：</strong></p>
<p>由于 B 树的每一个节点都包含 key 和 value，因此我们根据 key查找 value时，只需要找到 key 所在的位置，就能找到 value，但 <strong>B+ 树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value</strong> 。</p>
<p><strong>B+树和B树的差异在于以下几点：</strong></p>
<ol>
<li>B+树有k个孩子的节点就有k个关键字。也就是孩子数量&#x3D;关键字数，而B树中，孩子数量&#x3D;关键字数+1。</li>
<li>B+树非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大(或最小)。</li>
<li>B+树的非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B树中，非叶子节点既保存索引，也保存数据记录。</li>
<li>B+树所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li>
</ol>
<p>B树</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220130164535884.png" alt="image-20220130164535884"></p>
<p>B+树</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220130164503945.png" alt="image-20220130164503945"></p>
<p>B+树和B树的查询过程差不多，但是B+树和B树有个根本的差异在于，<strong>B+树的中间节点并不直接存储数据</strong>。这样的好处都有什么呢?</p>
<p>首先，<strong>B+树查询效率更稳定</strong>。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p>
<p>其次，<strong>B+树的查询效率更高</strong>。这是因为通常B+树比B树<strong>更矮胖</strong>(阶数更大， 深度更低)，查询所需要的磁盘I&#x2F;O也会更少。同样的磁盘页大小，B+ 树可以存储更多的节点关键字。</p>
<p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+ 树的效率也比B树高</strong>。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B*树"></a>B*树</h2><p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211219173900243.png" alt="image-20211219173900243"></p>
<p><strong>B*树的说明:</strong></p>
<ol>
<li><em><em>B</em> 树定义了非叶子结点关键字个数至少为(2&#x2F;3)</em> M，即块的最低使用率为2&#x2F;3，而B+树的块的最低使用率为B+树的1&#x2F;2。**</li>
<li><strong>从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</strong>。</li>
</ol>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种树型的数据结构，并查集可以高效地进行如下操作：</p>
<ul>
<li>查询元素p和元素q是否属于同一组</li>
<li>合并元索p和元素q所在的组</li>
</ul>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220133541170.png" alt="image-20211220133541170"></p>
<h3 id="并查集结构"><a href="#并查集结构" class="headerlink" title="并查集结构"></a>并查集结构</h3><p>并查集也是一种树型结构，但这棵树跟我们之前讲的二叉树、红黑树、B树等都不一样，这种树的要求比较简单：</p>
<ol>
<li><p>每个元索都唯一的对应一个结点；</p>
</li>
<li><p>每一组数据中的多个元素都在同一颗树中；</p>
</li>
<li><p>一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系；</p>
</li>
<li><p>元素在树中并没有子父级关系的硬性要求；</p>
</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220134001266.png" alt="image-20211220134001266"></p>
<h3 id="代码实现-30"><a href="#代码实现-30" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220134312011.png" alt="image-20211220134312011"></p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li>初始情况下,每个元素都在-个独立的分组中 ,所以,初始情况下,并查集中的数据默认分为N个组；</li>
<li>初始化数组eleAndGroup；</li>
<li>把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点所在的分组，那么初始化情况下，i 索引处存储的值就是 i。</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220135507161.png" alt="image-20211220135507161"></p>
<h4 id="合并方法"><a href="#合并方法" class="headerlink" title="合并方法"></a>合并方法</h4><ol>
<li>如果p和q已经在同一个分组中，则无需合并</li>
<li>如果p和q不在同一个分组，则只需要将p元素所在组的所有的元素的组标识符修改为q元素所在组的标识符即可</li>
<li>分组数量</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220142312931.png" alt="image-20211220142312931"></p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录并差好几种数据的分组个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] eleAndGroup;</span><br><span class="line">    <span class="comment">//记录并吃噶合计中数据的分组个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化分组的数量</span></span><br><span class="line">        <span class="built_in">this</span>.count = N;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化eleAndGroup数组</span></span><br><span class="line">        <span class="built_in">this</span>.eleAndGroup = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化eleAndGroup中元素及其所在数组的标识符</span></span><br><span class="line">        <span class="comment">//让eleAndGroup数组的索引作为变成嘎哈及的每个节点的元素</span></span><br><span class="line">        <span class="comment">//并且让每个索引处的值（该元素所在的组的标识符）就是该索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; eleAndGroup.length; i++) &#123;</span><br><span class="line">            eleAndGroup[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前并查集中的数据有多少分组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//元素p所在分组的标识符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> eleAndGroup[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断并查集中元素p和元素q是否在同一分组中(判断两个元素的标识符是否相等)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把p元素所在分组和q元素所在分组合并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="comment">//判断p、q是不是已经在同一分组中，如果已经在同一分组中，直接结束方法</span></span><br><span class="line">        <span class="keyword">if</span> (connected(p, q)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不在同一分组中</span></span><br><span class="line">        <span class="comment">//找到p所在分组的标识符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pGroup</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="comment">//找到q所在分组的标识符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">qGroup</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="comment">//合并：让p所在组的所有元素的组标识符变为q所在分组的标识符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; eleAndGroup.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eleAndGroup[i] == pGroup) eleAndGroup[i] = qGroup;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分组个数-1</span></span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>如果我们并查集存储的每一个整数表示的是一个大型计算机网络中的计算机 ，则我们就可以通过connected(int p,int g)来检测，该网络中的某两台计算机之间是否连通？如果连通，则他们之间可以通信，如果不连通，则不能通信，此时我们又可以调用union(int p,int q)使得p和q之间连通,这样两台计算机之间就可以通信了。</p>
<p>一般像计算机这样网络型的数据，我们要求网络中的每两个数据之间都是相连通的，也就是说，我们需要调用很多次union方法，使得网络中所有数据相连，其实我们很容易可以得出，如果要让网络中的数据都相连，则我们至少要调用N-1次union方法才可以，但由于我们的union方法中使用for循环遍历了所有的元素，所以很明显，我们之前实现的合并算法的时间复杂度是0(N^2)，如果要解决大规模问题，它是不合适的，所以我们需要对算法进行优化。</p>
<h3 id="YF-Tree算法优化"><a href="#YF-Tree算法优化" class="headerlink" title="YF_Tree算法优化"></a>YF_Tree算法优化</h3><p>为了提升union算法的性能，我们需要重新设计find方法和union方法的实现，此时我们先需要对我们的之前数据结构中的eleAndGourp数组的含义进行重新设定：</p>
<ol>
<li>我们仍然让eleAndGroup数组的索引作为某个结点的元素；</li>
<li><strong>eleAndGroup[i]的值不再是当前结点所在的分组标识，而是该结点的&#x3D;&#x3D;父结点&#x3D;&#x3D;；</strong></li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220143506071.png" alt="image-20211220143506071"></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220144347086.png" alt="image-20211220144347086"></p>
<h4 id="查询方法优化"><a href="#查询方法优化" class="headerlink" title="查询方法优化"></a>查询方法优化</h4><ol>
<li>判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了；</li>
<li>如果当前元素p的父结点不是自己，则让p&#x3D;eleAndGroup[p]，继续找父结点的父结点，直到找到根结点为止；</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220144729036.png" alt="image-20211220144729036"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//元素p所在分组的标识符</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == eleAndGroup[p]) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            p = eleAndGroup[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并方法优化"><a href="#合并方法优化" class="headerlink" title="合并方法优化"></a>合并方法优化</h4><ol>
<li>找到p元素所在树的根结点</li>
<li>找到q元素所在树的根结点</li>
<li>如果p和q已经在同一个树中，则无需合并；</li>
<li>如果p和q不在同一个分组，则只需要将p元素所在树根结点的父结点设置为q元素的根结点即可；</li>
<li>分组数量-1。</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220145355301.png" alt="image-20211220145355301"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把p元素所在分组和q元素所在分组合并</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="comment">//p的根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pRoot</span>  <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="comment">//q的根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">qRoot</span>  <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span> (pRoot  == qRoot ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让p所在树的根节点的父节点变为q所在树的根节点即可</span></span><br><span class="line">    eleAndGroup[pRoot] = qRoot ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组的数量-1</span></span><br><span class="line">    <span class="built_in">this</span>.count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化后的性能分析"><a href="#优化后的性能分析" class="headerlink" title="优化后的性能分析"></a>优化后的性能分析</h4><p>我们优化后的算法union，如果要把并查集中所有的数据连通，仍然至少要调用N-1次union方法，但是，我们发现union方法中已经没有了for循环，所以union算法的时间复杂度由0(N^2)变为了O(N)。</p>
<p>但是这个算法仍然有问题，因为我们之前不仅修改了union算法，还修改了find算法。我们修改前的find算法的时间复杂度在任何情况下都为0(1)，但修改后的find算法在最坏情况下是0(N) ：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220150109345.png" alt="image-20211220150109345"></p>
<p>在union方法中调用了find方法，所以在最坏情况下union算法的时间复杂度仍然为O(N^2)。</p>
<h3 id="路径压缩优化"><a href="#路径压缩优化" class="headerlink" title="路径压缩优化"></a>路径压缩优化</h3><p>UF_ Tree中最坏情况下union算法的时间复杂度为0(N^2)，其最主要的问题在于最坏情况下，树的深度和数组的大小一样，如果我们能够通过一些算法让合并时，生成的树的深度尽可能的小，就可以优化find方法。</p>
<p>之前我们在union算法中，合并树的时候将任意的一棵树连接到了另外一棵树，这种合并方法是比较暴力的，如果我们把并查集中每一棵树的大小记录下来，然后在每次合并树的时候，把较小的树连接到较大的树上，就可以减小树的深度。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220150439018.png" alt="image-20211220150439018"></p>
<p>只要我们保证每次合并，都能把小树合并到大树上，就能够压缩合并后新树的路径，这样就能提高find方法的效率。为了完成这个需求，我们需要另外一个数组来记录存储每个根结点对应的树中元素的个数，并且需要一些代码调整数组中的值。</p>
<h4 id="代码实现-31"><a href="#代码实现-31" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220150705566.png" alt="image-20211220150705566"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把p元素所在分组和q元素所在分组合并</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="comment">//p的根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="comment">//q的根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span> (pRoot == qRoot) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较pRoot和qRoot对应的树大小，将较小的树合并到较大的树之中</span></span><br><span class="line">    <span class="keyword">if</span> (sz[pRoot] &lt; sz[qRoot]) &#123;</span><br><span class="line">        eleAndGroup[pRoot] = qRoot;<span class="comment">//让p所在树的根节点的父节点变为q所在树的根节点即可</span></span><br><span class="line">        sz[qRoot] += sz[pRoot];<span class="comment">//更新qRoot中的元素个数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        eleAndGroup[qRoot] = pRoot;<span class="comment">//让q所在树的根节点的父节点变为p所在树的根节点即可</span></span><br><span class="line">        sz[pRoot] += sz[qRoot];<span class="comment">//更新pRoot中的元素个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组的数量-1</span></span><br><span class="line">    <span class="built_in">this</span>.count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例——畅通工程"><a href="#案例——畅通工程" class="headerlink" title="案例——畅通工程"></a>案例——畅通工程</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府”畅通工程’的目标是使全省任何两个城镇间都可以实现交通(不一定有直接的道路相连，只要互相间接通过道路可达即可)。问最少还需要建设多少条道路？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">20</span><br><span class="line">7</span><br><span class="line">0 1</span><br><span class="line">6 9</span><br><span class="line">3 8</span><br><span class="line">5 11</span><br><span class="line">2 12</span><br><span class="line">6 10</span><br><span class="line">4 8</span><br></pre></td></tr></table></figure>

<p>城镇道路统计表，下面是对数据的解释：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220152242607.png" alt="image-20211220152242607"></p>
<p>总共有20个城市，目前已经修改好了7条道路，问还需要修建多少条道路，才能让这20个城市之间全部相通？</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h4><ol>
<li>创建一个并查集UF _ Tree _ Weighted(20)；</li>
<li>分别调用union(0, 1)，union(6,9)，union(3,8)，union(5,11)，union(2,12)，union(6,10)，union(4,8)，表示已经修建好的道路把对应的城市连接起来；</li>
<li>如果城市全部连接起来，那么并查集中剩余的分组数目为1，所有的城市都在一个树中，所以，只需要获取当前并查集中剩余的数目，减去1，就是还需要修建的道路数目。</li>
</ol>
<h4 id="代码实现-32"><a href="#代码实现-32" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoadUF</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(RoadUF.class.getClassLoader().getResourceAsStream(<span class="string">&quot;com/algorithm/_8_2Tree/UF/Test/Test.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取到第一行数据20</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalNumber</span> <span class="operator">=</span> Integer.parseInt(bufferedReader.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建一个并查集</span></span><br><span class="line">        <span class="type">UFTree_Weighted</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UFTree_Weighted</span>(totalNumber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取第二行数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">roadNumber</span> <span class="operator">=</span> Integer.parseInt(bufferedReader.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环读取7条数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; roadNumber; i++) &#123;</span><br><span class="line">            <span class="comment">//逐行读取数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">            String[] str = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> Integer.parseInt(str[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> Integer.parseInt(str[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            uf.union(p, q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">roads</span> <span class="operator">=</span> uf.getCount() - <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;还需要修建&quot;</span>+roads+<span class="string">&quot;条道路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220154135860.png" alt="image-20211220154135860"></p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>图是一种<strong>数据结构</strong>，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。</p>
<p><strong>概念</strong></p>
<p>顶点、边、路径</p>
<p>无向图：顶点之间的连接没有方向</p>
<p>有向图：顶点之间的连接带有方向</p>
<p>带权图（网）：边带权值</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220163302023.png" alt="image-20211220163302023"></p>
<h2 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h2><p>图的表示方式有两种：二维数组表示（<strong>邻接矩阵</strong>）；链表表示（<strong>邻接表</strong>）</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵是表示图形中<strong>顶点之间相邻关系</strong>的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1…n个点。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220163455102.png" alt="image-20211220163455102"></p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会<strong>造成空间的一定损失</strong>。</p>
<p><strong>邻接表</strong>的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，<strong>邻接表由数组+链表组成</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220163752150.png" alt="image-20211220163752150"></p>
<p>说明：</p>
<ol>
<li>标号为0的节点的相关联的结点为1 2 3 4</li>
<li>标号为1的结点的相关联结点为0 4</li>
<li>标号为2的结点的相关联结点为0 4 5</li>
<li>……</li>
</ol>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220164455460.png" alt="image-20211220164455460"></p>
<h3 id="思路分析-26"><a href="#思路分析-26" class="headerlink" title="思路分析"></a>思路分析</h3><ul>
<li>存储顶点 String，使用ArrayList</li>
<li>保存矩阵int[] [] edges</li>
</ul>
<h3 id="代码实现-33"><a href="#代码实现-33" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;<span class="comment">//存储树对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;<span class="comment">//表示边的数目</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String VertexValue[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">Grap</span> <span class="variable">grap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Grap</span>(n);</span><br><span class="line">        <span class="comment">//循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : VertexValue) &#123;</span><br><span class="line">            grap.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        grap.insertEdges(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示</span></span><br><span class="line">        grap.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Grap</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到变的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点i下标（对应的数据 0-&gt;&quot;A&quot; 1-&gt;&quot;B&quot; 2-&gt;&quot;C&quot;）</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     表示点的下标即是第几个顶点：&quot;A&quot;-&quot;B&quot; &quot;A&quot;-&gt;&quot;0&quot; &quot;B&quot;-&gt;1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     表示第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示权值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdges</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略：</p>
<ul>
<li>深度优先遍历</li>
<li>广度优先遍历</li>
</ul>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><h4 id="思路分析-27"><a href="#思路分析-27" class="headerlink" title="思路分析"></a>思路分析</h4><p>图的深度优先搜索(Depth First Search) 。</p>
<ol>
<li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：<strong>每次都在访问完当前结点后首先访问当前结点的第一个邻接结点</strong>。</li>
<li>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li>
<li>显然，深度优先搜索是一个递归的过程</li>
</ol>
<h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol>
<li>访问初始结点v，并标记结点v为已访问。</li>
<li>查找结点v的第一个邻接结点w。</li>
<li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li>
<li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</li>
<li>查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220181029054.png" alt="image-20211220181029054"></p>
<h4 id="核心代码实现-3"><a href="#核心代码实现-3" class="headerlink" title="核心代码实现"></a>核心代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取第一个邻接结点的下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 当前访问的结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[index][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据前一个邻接结点的下标来获取下一个邻接结点</span></span><br><span class="line"><span class="comment"> * 查找结点v1的第一个邻接结点v2的下一个邻接结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v1 当前被访问结点的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v2 当前结点的第一个邻接结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v2 + <span class="number">1</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[v1][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isVisited 用来判断当前结点i是否被访问的boolean数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i         被访问的结点下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">//首先访问该结点，输出</span></span><br><span class="line">    System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//将结点设置为已经访问</span></span><br><span class="line">    isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//查找结点i的第一个邻接结点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">firstNeighbor</span> <span class="operator">=</span> getFirstNeighbor(i);</span><br><span class="line">    <span class="keyword">while</span> (firstNeighbor != -<span class="number">1</span>) &#123;<span class="comment">//说明存在邻接结点</span></span><br><span class="line">        <span class="keyword">if</span> (!isVisited[firstNeighbor]) &#123;<span class="comment">//没有被访问过，</span></span><br><span class="line">            dfs(isVisited, firstNeighbor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果firstNeighbor已经被访问过</span></span><br><span class="line">        <span class="comment">//查找结点i的第一个邻接结点的下一个邻接结点</span></span><br><span class="line">        firstNeighbor = getNextNeighbor(i, firstNeighbor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对dfs进行重载，遍历我们所有的结点，并进行dfs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span> &#123;</span><br><span class="line">    isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">    <span class="comment">//便利所有的结点，进行dfs[回溯]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">            dfs(isVisited, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><h4 id="思路分析-28"><a href="#思路分析-28" class="headerlink" title="思路分析"></a>思路分析</h4><p>图的广度优先搜索(Broad First Search) 。</p>
<p>类似于一个<strong>分层搜索</strong>的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p>
<h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol>
<li>访问初始结点v并标记结点v为已访问。</li>
<li>结点v入队列。</li>
<li>当队列非空时，继续执行，否则算法结束。</li>
<li>出队列，取得队头结点u。</li>
<li>查找结点u的第一个邻接结点w。</li>
<li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：<ol>
<li>若结点w尚未被访问，则访问结点w并标记为已访问。 </li>
<li>结点w入队列 。</li>
<li>查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</li>
</ol>
</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220181631283.png" alt="image-20211220181631283"></p>
<h4 id="核心代码实现-4"><a href="#核心代码实现-4" class="headerlink" title="核心代码实现"></a>核心代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取第一个邻接结点的下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 当前访问的结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[index][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据前一个邻接结点的下标来获取下一个邻接结点</span></span><br><span class="line"><span class="comment"> * 查找结点v1的第一个邻接结点v2的下一个邻接结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v1 当前被访问结点的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v2 当前结点的第一个邻接结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v2 + <span class="number">1</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[v1][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> u;<span class="comment">//表示队列的头结点对应的下标</span></span><br><span class="line">    <span class="type">int</span> w;<span class="comment">//邻接结点w</span></span><br><span class="line">    <span class="comment">//队列，记录结点访问的顺序</span></span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    <span class="comment">//返回结点，输出结点信息</span></span><br><span class="line">    System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//标记为已访问</span></span><br><span class="line">    isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//将节点加入队列</span></span><br><span class="line">    queue.addLast(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//取出队列的头结点小标</span></span><br><span class="line">        u = (Integer) queue.removeFirst();</span><br><span class="line">        <span class="comment">//得到第一个邻接点的下标</span></span><br><span class="line">        w = getFirstNeighbor(u);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;<span class="comment">//找到了</span></span><br><span class="line">            <span class="comment">//是否访问过</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w]) &#123;<span class="comment">//没有访问过</span></span><br><span class="line">                System.out.print(getValueByIndex(w) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                <span class="comment">//标记已经访问</span></span><br><span class="line">                isVisited[w] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//入队列</span></span><br><span class="line">                queue.addLast(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已经访问过</span></span><br><span class="line">            <span class="comment">//以u为前驱点，找w后面的下一个邻接点</span></span><br><span class="line">            w = getNextNeighbor(u, w);<span class="comment">//体现出广度优先</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对dfs进行重载，遍历我们所有的结点，并进行dfs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">    isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">    <span class="comment">//便利所有的结点，进行dfs[回溯]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">            bfs(isVisited, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h2><h3 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DFSGrap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;<span class="comment">//存储树对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;<span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[],记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DFSGrap</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到变的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点i下标（对应的数据 0-&gt;&quot;A&quot; 1-&gt;&quot;B&quot; 2-&gt;&quot;C&quot;）</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     表示点的下标即是第几个顶点：&quot;A&quot;-&quot;B&quot; &quot;A&quot;-&gt;&quot;0&quot; &quot;B&quot;-&gt;1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     表示第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示权值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdges</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取第一个邻接结点的下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 当前访问的结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据前一个邻接结点的下标来获取下一个邻接结点</span></span><br><span class="line"><span class="comment">     * 查找结点v1的第一个邻接结点v2的下一个邻接结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 当前被访问结点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 当前结点的第一个邻接结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v2 + <span class="number">1</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度优先</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited 用来判断当前结点i是否被访问的boolean数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i         被访问的结点下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//首先访问该结点，输出</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//将结点设置为已经访问</span></span><br><span class="line">        isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//查找结点i的第一个邻接结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">firstNeighbor</span> <span class="operator">=</span> getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span> (firstNeighbor != -<span class="number">1</span>) &#123;<span class="comment">//说明存在邻接结点</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisited[firstNeighbor]) &#123;<span class="comment">//没有被访问过，</span></span><br><span class="line">                dfs(isVisited, firstNeighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果firstNeighbor已经被访问过</span></span><br><span class="line">            <span class="comment">//查找结点i的第一个邻接结点的下一个邻接结点</span></span><br><span class="line">            firstNeighbor = getNextNeighbor(i, firstNeighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对dfs进行重载，遍历我们所有的结点，并进行dfs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span> &#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">//便利所有的结点，进行dfs[回溯]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">                dfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DFSGrapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String VertexValue[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">DFSGrap</span> <span class="variable">grap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DFSGrap</span>(n);</span><br><span class="line">        <span class="comment">//循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : VertexValue) &#123;</span><br><span class="line">            grap.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        grap.insertEdges(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示</span></span><br><span class="line">        grap.show();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;深度遍历&quot;</span>);</span><br><span class="line">        grap.dfs();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220193903313.png" alt="image-20211220193903313"></p>
<h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BFSGrap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;<span class="comment">//存储树对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;<span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[],记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BFSGrap</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到变的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点i下标（对应的数据 0-&gt;&quot;A&quot; 1-&gt;&quot;B&quot; 2-&gt;&quot;C&quot;）</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     表示点的下标即是第几个顶点：&quot;A&quot;-&quot;B&quot; &quot;A&quot;-&gt;&quot;0&quot; &quot;B&quot;-&gt;1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     表示第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示权值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdges</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取第一个邻接结点的下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 当前访问的结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据前一个邻接结点的下标来获取下一个邻接结点</span></span><br><span class="line"><span class="comment">     * 查找结点v1的第一个邻接结点v2的下一个邻接结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 当前被访问结点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 当前结点的第一个邻接结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v2 + <span class="number">1</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//广度优先</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> u;<span class="comment">//表示队列的头结点对应的下标</span></span><br><span class="line">        <span class="type">int</span> w;<span class="comment">//邻接结点w</span></span><br><span class="line">        <span class="comment">//队列，记录结点访问的顺序</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//返回结点，输出结点信息</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//标记为已访问</span></span><br><span class="line">        isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//将节点加入队列</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//取出队列的头结点小标</span></span><br><span class="line">            u = (Integer) queue.removeFirst();</span><br><span class="line">            <span class="comment">//得到第一个邻接点的下标</span></span><br><span class="line">            w = getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;<span class="comment">//找到了</span></span><br><span class="line">                <span class="comment">//是否访问过</span></span><br><span class="line">                <span class="keyword">if</span> (!isVisited[w]) &#123;<span class="comment">//没有访问过</span></span><br><span class="line">                    System.out.print(getValueByIndex(w) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                    <span class="comment">//标记已经访问</span></span><br><span class="line">                    isVisited[w] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//入队列</span></span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//已经访问过</span></span><br><span class="line">                <span class="comment">//以u为前驱点，找w后面的下一个邻接点</span></span><br><span class="line">                w = getNextNeighbor(u, w);<span class="comment">//体现出广度优先</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对dfs进行重载，遍历我们所有的结点，并进行dfs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">//便利所有的结点，进行dfs[回溯]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">                bfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BFSGrapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String VertexValue[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">BFSGrap</span> <span class="variable">grap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BFSGrap</span>(n);</span><br><span class="line">        <span class="comment">//循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : VertexValue) &#123;</span><br><span class="line">            grap.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        grap.insertEdges(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        grap.insertEdges(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示</span></span><br><span class="line">        grap.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;深度遍历&quot;</span>);</span><br><span class="line">        grap.bfs();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220202109156.png" alt="image-20211220202109156"></p>
<h2 id="深度优先和广度优先"><a href="#深度优先和广度优先" class="headerlink" title="深度优先和广度优先"></a>深度优先和广度优先</h2><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220202947941.png" alt="image-20211220202947941"></p>
<h3 id="深度优先-1"><a href="#深度优先-1" class="headerlink" title="深度优先"></a>深度优先</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220204212483.png" alt="image-20211220204212483"></p>
<h3 id="广度优先-1"><a href="#广度优先-1" class="headerlink" title="广度优先"></a>广度优先</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220204243324.png" alt="image-20211220204243324"></p>
<h3 id="代码实现-34"><a href="#代码实现-34" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广度优先</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        String VertexValue[] = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">BFSGrap</span> <span class="variable">bfsGrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BFSGrap</span>(n);</span><br><span class="line">        <span class="comment">//循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : VertexValue) &#123;</span><br><span class="line">            bfsGrap.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        bfsGrap.insertEdges(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        bfsGrap.insertEdges(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        bfsGrap.insertEdges(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        bfsGrap.insertEdges(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        bfsGrap.insertEdges(<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">        bfsGrap.insertEdges(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">        bfsGrap.insertEdges(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        bfsGrap.insertEdges(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">        bfsGrap.insertEdges(<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;广度优先：&quot;</span>);</span><br><span class="line">        bfsGrap.bfs();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//深度优先</span></span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">DFSGrap</span> <span class="variable">dfsGrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DFSGrap</span>(n);</span><br><span class="line">        <span class="comment">//循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : VertexValue) &#123;</span><br><span class="line">            dfsGrap.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        dfsGrap.insertEdges(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        dfsGrap.insertEdges(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        dfsGrap.insertEdges(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        dfsGrap.insertEdges(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        dfsGrap.insertEdges(<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">        dfsGrap.insertEdges(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">        dfsGrap.insertEdges(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        dfsGrap.insertEdges(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">        dfsGrap.insertEdges(<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;深度优先：&quot;</span>);</span><br><span class="line">        dfsGrap.dfs();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211220203814068.png" alt="image-20211220203814068"></p>
<h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><h2 id="二分查找（非递归）"><a href="#二分查找（非递归）" class="headerlink" title="二分查找（非递归）"></a>二分查找（非递归）</h2><ol>
<li>前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式；</li>
<li>二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找；</li>
<li>二分查找法的运行时间为对数时间O(log<sub>2</sub>n) ，即查找到需要的目标位置最多只需要log<sub>2</sub>n步，假设从[0,99]的队列(100个数，即n&#x3D;100)中寻到目标数30，则需要查找步数为log<sub>2</sub>100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7)</li>
</ol>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成。</p>
<h4 id="代码实现-35"><a href="#代码实现-35" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归实现二分查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_1BinarySearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找的非递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待查找的数组，arr是升序排列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 需要查找的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左头</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;<span class="comment">//右头</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;<span class="comment">//中间值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;<span class="comment">//需要向左边查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//需要向右边查找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> findVal)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123; <span class="comment">//在端点的时候就是left==right</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> _1BinarySearch.binarySearch(arr, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><h3 id="概述-17"><a href="#概述-17" class="headerlink" title="概述"></a>概述</h3><ol>
<li>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</li>
<li>分治算法可以求解的一些经典问题<ul>
<li>二分搜索</li>
<li>大整数乘法</li>
<li>棋盘覆盖</li>
<li>合并排序</li>
<li>快速排序</li>
<li>线性时间选择</li>
<li>最接近点对问题</li>
<li>循环赛日程表</li>
<li><strong>汉诺塔</strong></li>
</ul>
</li>
</ol>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>分治法在每一层递归上都有三个步骤：</p>
<ol>
<li><strong>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</strong></li>
<li><strong>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题；</strong></li>
<li><strong>合并：将各个子问题的解合并为原问题的解。；</strong></li>
</ol>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><strong>分治(Divide-and-Conquer(P))算法设计模式如下：</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211221183513873.png" alt="image-20211221183513873"></p>
<ul>
<li>其中|P|表示问题P的规模；</li>
<li>n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。</li>
<li>ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。</li>
</ul>
<p>因此，<strong>当P的规模不超过n0时直接用算法ADHOC(P)求解。</strong></p>
<ul>
<li>算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</li>
</ul>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><p>汉罗塔</p>
<p>大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<h4 id="思路分析-29"><a href="#思路分析-29" class="headerlink" title="思路分析"></a>思路分析</h4><ol>
<li>如果是有一个盘， A-&gt;C</li>
<li>如果我们有 n &gt;&#x3D; 2 情况，我们总是可以看做是两个盘：<strong>最下边的一个盘</strong>、<strong>上面的所有盘</strong><ol>
<li>先把 最上面的盘 A-&gt;B</li>
<li>把最下边的盘 A-&gt;C</li>
<li>把B塔的所有盘 从 B-&gt;C</li>
</ol>
</li>
</ol>
<h4 id="代码实现-36"><a href="#代码实现-36" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//汉罗塔</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_2Hanoitower</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记步数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        hanoitower(<span class="number">6</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共&quot;</span> + i + <span class="string">&quot;步&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoitower</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果只有一个盘</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">&quot;第1个盘子:&quot;</span> + a + <span class="string">&quot;-&gt;&quot;</span> + c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">//1.先把上面的所有盘 A-&gt;B,移动过程会使用到 C</span></span><br><span class="line">                hanoitower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">                <span class="comment">//2.把最下边的盘 A-&gt;C</span></span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span> + num + <span class="string">&quot;个盘子:&quot;</span> + a + <span class="string">&quot;-&gt;&quot;</span> + c);</span><br><span class="line">                <span class="comment">//3.把B塔的所有盘 从 B-&gt;C ,移动过程会使用到 A</span></span><br><span class="line">                hanoitower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ol>
<li>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</li>
<li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li>
<li>与分治法不同的是，<strong>适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的</strong>。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</li>
<li>动态规划可以通过填表的方式来逐步推进，得到最优解.</li>
</ol>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><p>背包问题：有一个背包，容量为4磅 ， 现有如下物品</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211221202057683.png" alt="image-20211221202057683"></p>
<ol>
<li>要求达到的目标为装入的背包的总价值最大，并且重量不超出</li>
<li>要求装入的物品不能重复</li>
</ol>
<h4 id="思路分析-30"><a href="#思路分析-30" class="headerlink" title="思路分析"></a>思路分析</h4><ul>
<li><p>背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)</p>
</li>
<li><p>这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。</p>
</li>
<li><p>算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i] [j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211221205212112.png" alt="image-20211221205212112"></p>
<ol>
<li><pre><code class="java">v[i][0]=v[0][j]=0; //表示填入表第一行和第一列是0
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```java</span><br><span class="line">   当w[i]&gt; j 时：v[i][j]=v[i-1][j]   // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>&#96;&#96;&#96;java<br>当j&gt;&#x3D;w[i]时： v[i][j]&#x3D;max{v[i-1][j], v[i]+v[i-1][j-w[i]]}<br>&#x2F;&#x2F; 当准备加入的新增的商品的容量小于等于当前背包的容量。<br>&#x2F;&#x2F; 比较 上一个单元格能装入的最大价值 和 表示当前商品的价值+能加入的上一个商品最大数量的价值 的大小，那种情况价值大，取哪种情况。<br>&#x2F;&#x2F; 装入的方式:<br>&#x2F;&#x2F; v[i-1][j]： 就是上一个单元格的装入的最大值<br>&#x2F;&#x2F; v[i] : 表示当前商品的价值<br>&#x2F;&#x2F; v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值<br>&#x2F;&#x2F; j-w[i] j:当前容量，w[i]当前商品的重量 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 代码实现</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//01背包</span><br><span class="line">public class KnapsackProblem &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] weight = &#123;1, 4, 3&#125;;//物品的重量</span><br><span class="line">        int[] value = &#123;1500, 3000, 2000&#125;;//物品的价值，这里的value[i]就是v[i]</span><br><span class="line">        int m = 4;//背包的容量</span><br><span class="line">        int n = value.length;//物品的个数</span><br><span class="line"></span><br><span class="line">        //创建二维数组，表示背包</span><br><span class="line">        //v[i][j] 表示在前i个物品中能装入容量为j的背包中的最大价值</span><br><span class="line">        int[][] v = new int[n + 1][m + 1];</span><br><span class="line"></span><br><span class="line">        //为了记录放入商品的情况，我们定一个二维数组</span><br><span class="line">        int[][] path = new int[n + 1][m + 1];</span><br><span class="line"></span><br><span class="line">        //初始化第一行和第一列，在本程序中可以不写，因为默认为0</span><br><span class="line">        for (int i = 0; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][0] = 0;//将第一列设置为0</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; v[0].length; i++) &#123;</span><br><span class="line">            v[0][i] = 0;//将第一行设置为0</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //根据前面得到的公式来动态规划处理</span><br><span class="line">        for (int i = 1; i &lt; v.length; i++) &#123;//不处理第一行，i是从1开始的</span><br><span class="line">            for (int j = 1; j &lt; v[0].length; j++) &#123;//不处理第一列，j是从1开始的</span><br><span class="line">                //公式</span><br><span class="line">                if (weight[i - 1] &gt; j) &#123;//当准备加入的商品的容量大于当前背包的容量时，因为我们程序i是从1开始的，因此原来公式中的w[i]修改为w[i-1]</span><br><span class="line">                    v[i][j] = v[i - 1][j];//直接使用上一个单元格的装入策略</span><br><span class="line">                &#125; else &#123;// 当准备加入的新增的商品的容量小于等于当前背包的容量。</span><br><span class="line">                    //比较 上一个单元格能装入的最大价值 和 表示当前商品的价值+能加入的上一个商品最大数量的价值 的大小，那种情况价值大，取哪种情况。</span><br><span class="line">                    //因为我们程序i是从1开始的，因此原来公式中的value[i]修改为value[i-1],weight[i]该我weight[i-1]</span><br><span class="line"></span><br><span class="line">                    //v[i][j] = Math.max(v[i - 1][j], value[i - 1] + v[i ][j - weight[i]]);//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: -3</span><br><span class="line">                    //v[i][j] = Math.max(v[i - 1][j], value[i - 1] + v[i - 1][j - weight[i - 1]]);</span><br><span class="line"></span><br><span class="line">                    //为了记录商品存放到背包的情况，我们不能兼得使用上面的工具</span><br><span class="line">                    if (v[i - 1][j] &lt; value[i - 1] + v[i - 1][j - weight[i - 1]]) &#123;</span><br><span class="line">                        v[i][j] = value[i - 1] + v[i - 1][j - weight[i - 1]];</span><br><span class="line">                        //把当前的情况记录到path</span><br><span class="line">                        path[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //遍历v，查看一下当前情况</span><br><span class="line">        for (int i = 0; i &lt; v.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; v[i].length; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //输出最后我们放入的商品</span><br><span class="line">        //遍历path</span><br><span class="line"></span><br><span class="line">        // 这样每更新一次最大值，对应情况的path就会被标记为1，而输出</span><br><span class="line">        // 会输出会把所有放入情况都得到，而我们只需要最后的放入</span><br><span class="line">//        for (int i = 0; i &lt; path.length; i++) &#123;</span><br><span class="line">//            for (int j = 0; j &lt; path[i].length; j++) &#123;</span><br><span class="line">//                if (path[i][j] == 1) &#123;</span><br><span class="line">//                    System.out.print(&quot;第&quot; + i + &quot;个商品放入到背包&quot;);</span><br><span class="line">//                    j -= weight[i - 1];</span><br><span class="line">//                &#125;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;价值最大的情况：&quot;);</span><br><span class="line">        int i = path.length - 1;//行的最大下标</span><br><span class="line">        int j = path[0].length - 1;//列的最大下标</span><br><span class="line">        while (i &gt; 0 &amp;&amp; j &gt; 0) &#123;//从path的最后开始找</span><br><span class="line">            if (path[i][j] == 1) &#123;</span><br><span class="line">                System.out.println(&quot;第&quot; + i + &quot;个商品放入到背包&quot;);</span><br><span class="line">                j -= weight[i - 1];//包的重量-当前商品的重量</span><br><span class="line">            &#125;</span><br><span class="line">            i--;//已经找到一个商品，寻找下一个商品</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="暴力匹配算法实现"><a href="#暴力匹配算法实现" class="headerlink" title="暴力匹配算法实现"></a>暴力匹配算法实现</h3><h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h4><p>字符串匹配问题：</p>
<ol>
<li>有一个字符串 str1&#x3D; “”硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好””，和一个子串 str2&#x3D;”尚硅谷你尚硅你”</li>
<li>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</li>
</ol>
<h4 id="思路分析-31"><a href="#思路分析-31" class="headerlink" title="思路分析"></a>思路分析</h4><p>如果用暴力匹配的思路，并假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有：</p>
<ol>
<li>如果当前字符匹配成功（即str1[i] &#x3D;&#x3D; str2[j]），则i++，j++，继续匹配下一个字符</li>
<li>如果失配（即str1[i]! &#x3D; str2[j]），令i &#x3D; i - (j - 1)，j &#x3D; 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li>
<li>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)</li>
<li>暴力匹配算法实现.</li>
</ol>
<h4 id="代码实现-37"><a href="#代码实现-37" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符匹配</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViolenceMatch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;adsadasdasjkdbaskjdasj&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ask&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> violenceMatch(str1, str2);</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力匹配实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">violenceMatch</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> s2.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//i索引指向s1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//j索引指向s2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - (j - <span class="number">1</span>);<span class="comment">//移动到i的下一位</span></span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (j == len2) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP算法实现"><a href="#KMP算法实现" class="headerlink" title="KMP算法实现"></a>KMP算法实现</h3><ol>
<li>KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</li>
<li>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法.</li>
<li>KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间</li>
</ol>
<h4 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h4><ol>
<li>有一个字符串 str1&#x3D; “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2&#x3D;”ABCDABD”</li>
<li>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</li>
</ol>
<h4 id="思路分析-32"><a href="#思路分析-32" class="headerlink" title="思路分析"></a>思路分析</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/v_july_v/article/details/7041827">彻底理解KMP</a></p>
<blockquote>
<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， </p>
<p>－”A”的前缀和后缀都为空集，共有元素的长度为0； </p>
<p>－”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0； </p>
<p>－”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； </p>
<p>－”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； </p>
<p>－”ABCDA”的前缀为[&#x3D;&#x3D;A&#x3D;&#x3D;, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA,&#x3D;&#x3D;A&#x3D;&#x3D;]，共有元素为”A”，长度为1； </p>
<p>－”ABCDAB”的前缀为[A,&#x3D;&#x3D;AB&#x3D;&#x3D;, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, &#x3D;&#x3D;AB&#x3D;&#x3D;, B]，共有元素为”AB”，长度为2； </p>
<p>－”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 </p>
</blockquote>
<p><strong>当前缀和后缀中有相同的元素时，就可以把后缀中的元素当做是新的起点。</strong></p>
<p><strong>到达这个后缀的步长恰巧是：（已匹配的字符总长度 - 后缀的长度）</strong></p>
<h4 id="代码实现-38"><a href="#代码实现-38" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kmp算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMPAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = kmpNext(str2);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> kmpSearch(str1, str2, next);</span><br><span class="line"></span><br><span class="line">        System.out.println(index);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kmp搜索算法的实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 愿字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(String str1, String str2, <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要处理str1.charAt(i) != str2.charAt(j)</span></span><br><span class="line">            <span class="comment">//KMP核心</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == str2.length()) &#123;<span class="comment">//找到了</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取字符串的部分匹配值表的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dest 当前字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 部分匹配表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] kmpNext(String dest) &#123;</span><br><span class="line">        <span class="comment">//创建一个数组，保存部分匹配值</span></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[dest.length()];</span><br><span class="line"></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//如果字符串长度是1，部分匹配值就是0</span></span><br><span class="line">        <span class="comment">//i表示后缀缀（一直在移动），j表示前缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//当dest.charAt(i) != dest.charAt(j)成立时</span></span><br><span class="line">            <span class="comment">//我们需要从next[j-1]处获取新的j</span></span><br><span class="line">            <span class="comment">//直到dest.charAt(i) == dest.charAt(j)成立时，才退出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这是kmp算法的核心</span></span><br><span class="line">            <span class="comment">//加入这句话之前：[0, 0, 0, 0, 1, 2, 2]</span></span><br><span class="line">            <span class="comment">//加入这句话之后：[0, 0, 0, 0, 1, 2, 0]</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;<span class="comment">//当j&gt;0时，并且后续的值不相等</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//回溯到与当前值相等的前缀下标</span></span><br><span class="line">                <span class="comment">//&quot;A  B  C  D  A  B  D  A  B  C  C&quot;;</span></span><br><span class="line">                <span class="comment">//[0, 0, 0, 0, 1, 2, 0, 1, 2, 3, 0]</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当dest.charAt(i) == dest.charAt(j)成立时，部分匹配值就是++</span></span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i) == dest.charAt(j)) &#123;<span class="comment">//值相等时</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ol>
<li>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法（<strong>局部最优解</strong>）</li>
<li>贪婪算法所得到的结果<strong>不一定是最优的结果</strong>(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</li>
</ol>
<h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><h4 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h4><p><strong>集合覆盖问题</strong></p>
<p>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何<strong>选择最少的广播台，让所有的地区都可以接收到信号</strong>。</p>
<table>
<thead>
<tr>
<th>广播台</th>
<th>覆盖地区</th>
</tr>
</thead>
<tbody><tr>
<td>K1</td>
<td>“北京”, “上海”, “天津”</td>
</tr>
<tr>
<td>K2</td>
<td>“广州”, “北京”, “深圳”</td>
</tr>
<tr>
<td>K3</td>
<td>“成都”, “上海”, “杭州”</td>
</tr>
<tr>
<td>K4</td>
<td>“上海”, “天津”</td>
</tr>
<tr>
<td>K5</td>
<td>“杭州”, “大连”</td>
</tr>
</tbody></table>
<h4 id="思路分析-33"><a href="#思路分析-33" class="headerlink" title="思路分析"></a>思路分析</h4><h5 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h5><p>如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有2<sup>n</sup> -1 个,假设每秒可以计算10个子集， 如图：</p>
<table>
<thead>
<tr>
<th>广播台数量n</th>
<th>子集总数2<sup>n</sup></th>
<th>需要的时间</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>32</td>
<td>3.2秒</td>
</tr>
<tr>
<td>10</td>
<td>1024</td>
<td>102.4秒</td>
</tr>
<tr>
<td>32</td>
<td>4294967296</td>
<td>13.6年</td>
</tr>
<tr>
<td>100</td>
<td>1.26*100<sup>30</sup></td>
<td>4x10<sup>23</sup>年</td>
</tr>
</tbody></table>
<p>这种方法，效率低下</p>
<h5 id="贪心算法-1"><a href="#贪心算法-1" class="headerlink" title="贪心算法"></a>贪心算法</h5><p>使用贪婪算法，效率高:</p>
<p>目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合:</p>
<ol>
<li>遍历所有的广播电台, 找到一个覆盖了最多<strong>未覆盖的地区</strong>的电台(此电台可能包含一些已覆盖的地区，但没有关系） </li>
<li>将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</li>
<li>重复第1步直到覆盖了全部的地区。</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211222164102489.png" alt="image-20211222164102489"></p>
<h4 id="代码实现-39"><a href="#代码实现-39" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreedyAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GreedyAlgorithm</span> <span class="variable">ga</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GreedyAlgorithm</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建广播电台,放入到Map中</span></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Set&lt;String&gt;&gt;();</span><br><span class="line">        <span class="comment">//将各个电台放入broadcasts</span></span><br><span class="line">        Set&lt;String&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        set1.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        set1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        set1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        set1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        set2.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        set2.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        set2.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        set2.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set3 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        set3.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        set3.add(<span class="string">&quot;武汉&quot;</span>);</span><br><span class="line">        set3.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set4 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        set4.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        set4.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set5 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        set5.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        set5.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        set5.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入到map中</span></span><br><span class="line">        broadcasts.put(<span class="string">&quot;K1&quot;</span>, set1);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K2&quot;</span>, set2);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K3&quot;</span>, set3);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K4&quot;</span>, set4);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K5&quot;</span>, set5);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; selects = ga.greedy(broadcasts);</span><br><span class="line"></span><br><span class="line">        System.out.println(selects);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> broadcasts 输入进来的电台信息列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">greedy</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; broadcasts)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历存储所有地区到allAreas中</span></span><br><span class="line">        Set&lt;String&gt; allAreas = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : broadcasts.entrySet()) &#123;</span><br><span class="line">            Set&lt;String&gt; area = entry.getValue();</span><br><span class="line">            Iterator&lt;String&gt; itArea = area.iterator();</span><br><span class="line">            <span class="keyword">while</span> (itArea.hasNext()) &#123;</span><br><span class="line">                allAreas.add(itArea.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(allAreas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ArrayList集合,用来存放每一轮maxKey所指电台覆盖的地区</span></span><br><span class="line">        <span class="comment">// 当前选择的电台的集合</span></span><br><span class="line">        List&lt;String&gt; selects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个临时的集合,在遍历过程中，用来存储遍历过程中当前电台所覆盖地区和当前allAreas集合中所剩的电台覆盖的所有地区的交集</span></span><br><span class="line">        Set&lt;String&gt; tempSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个maxKey,用来保存一次遍历过程中,覆盖地区最多的key（占所有地区）</span></span><br><span class="line">        <span class="comment">//如果maxKey不为null,则加入到selects中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">maxKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个maxKey临时的集合,在遍历过程中,存放遍历过程中电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">        Set&lt;String&gt; tempMaxKeySet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!allAreas.isEmpty()) &#123;<span class="comment">//如果allAreas不为空,则表示还没有覆盖到所有地区</span></span><br><span class="line">            maxKey = <span class="literal">null</span>;<span class="comment">//每新的一轮开始，都要将maxKey置空</span></span><br><span class="line">            tempMaxKeySet.clear();<span class="comment">//并将存储maxKey的集合清空</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历broadcasts,取出对应的key</span></span><br><span class="line">            <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                tempSet.clear();<span class="comment">//每一次都需要清空临时集合</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前key所能覆盖的地区</span></span><br><span class="line">                Set&lt;String&gt; area = broadcasts.get(key);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//加入</span></span><br><span class="line">                tempSet.addAll(area);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//求出tempSet和allAreas的交集并赋给tempSet</span></span><br><span class="line">                tempSet.retainAll(allAreas);<span class="comment">// retainAll 求交集</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前这个集合包含未覆盖地区的数量比maxKey指向的集合包含未覆盖地区的数量还多</span></span><br><span class="line">                <span class="comment">// 就需要重置maxKey和它指向的集合包含未覆盖地区集合</span></span><br><span class="line">                <span class="comment">// tempSet.size() &gt; tempMaxKeySet.size()体现贪心算法的特点,每次都选择最优的</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size() &gt; <span class="number">0</span> &amp;&amp; (maxKey == <span class="literal">null</span> || tempSet.size() &gt; tempMaxKeySet.size())) &#123;</span><br><span class="line">                    <span class="comment">//清空,防止数据间影响</span></span><br><span class="line">                    tempMaxKeySet.clear();</span><br><span class="line"></span><br><span class="line">                    maxKey = key;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//maxKey覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">                    Set&lt;String&gt; area2 = broadcasts.get(maxKey);<span class="comment">//获取当前集合中广播覆盖的城市</span></span><br><span class="line">                    tempMaxKeySet.addAll(area2);<span class="comment">//加入</span></span><br><span class="line">                    tempMaxKeySet.retainAll(allAreas);<span class="comment">//求交集</span></span><br><span class="line">                    <span class="comment">//此时tempMaxKeySet中存放的这就这一轮的maxkey所代表的广播包含的城市</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//maxKey != null,就应该将maxKey加入selects中</span></span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="literal">null</span>) &#123;</span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                <span class="comment">//将maxKey指向的广播电台覆盖的地区从allAreas中去掉</span></span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><strong>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</strong></li>
<li><strong>比如上题的算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区</strong>。</li>
<li>但是我们发现 K2, K3, K4, K5 也可以覆盖全部地区，如果K2 的使用成本低于K1，那么我们上题的 K1, K2, K3, K5 虽然是满足条件，但是并不是最优的。</li>
</ol>
<h2 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h2><ol>
<li>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图</li>
<li>普利姆的算法如下:<ol>
<li>设G&#x3D;(V,E)是连通网，T&#x3D;(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 </li>
<li>若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]&#x3D;1</li>
<li>若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]&#x3D;1</li>
<li>重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边</li>
<li>提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解.</li>
</ol>
</li>
</ol>
<h3 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211223113322234.png" alt="image-20211223113322234"></p>
<ol>
<li>有胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通</li>
<li>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里</li>
<li>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?<ul>
<li>思路: 将10条边，连接即可，但是总的里程数不是最小；</li>
<li>正确的思路：<strong>就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少。</strong></li>
</ul>
</li>
</ol>
<h3 id="思路分析-34"><a href="#思路分析-34" class="headerlink" title="思路分析"></a>思路分析</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>修路问题本质就是就是最小生成树问题， 先介绍一下<strong>最小生成树(Minimum Cost Spanning Tree)，简称MST。</strong></p>
<ol>
<li>给定一个带权的无向连通图,如何选取一棵生成树,使树上所有<strong>边上权的总和为最小，这叫最小生成树；</strong></li>
<li>N个顶点，一定有N-1条边；</li>
<li>包含全部顶点；</li>
<li>N-1条边都在图中；</li>
<li>举例说明，如图:<ul>
<li><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211223115752323.png" alt="image-20211223115752323"></li>
</ul>
</li>
<li>求最小生成树的算法主要是<strong>普里姆算法</strong>和<strong>克鲁斯卡尔算法</strong></li>
</ol>
<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211223113322234-16767118288362.png" alt="image-20211223113322234"></p>
<ol>
<li>从 &lt; A &gt; 顶点开始处理  &#x3D;》 &lt; A , G &gt; 2<ul>
<li>A-C [7]、A-G[2]、A-B[5]</li>
</ul>
</li>
<li>&lt; A , G &gt; 开始，将A 和 G 顶点和他们相邻的还没有访问的顶点进行处理 &#x3D;》&lt; A , G , B &gt;<ul>
<li>A-C[7]、A-B[5]、G-B[3]、G-E[4]、G-F[6]</li>
</ul>
</li>
<li>&lt; A , G , B &gt; 开始，将 A , G , B 顶点和他们相邻的还没有访问的顶点进行处理&#x3D;》 &lt; A , G , B , E &gt;<ul>
<li>A-C[7]、G-E[4]、G-F[6]、B-D[9]<br>…..</li>
</ul>
</li>
</ol>
<p><strong>完整步骤</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211223125331149.png" alt="image-20211223125331149"></p>
<ol>
<li>{A}-&gt;G &#x2F;&#x2F;第一 次大循环，对应边&lt;A,G&gt; 权值：2</li>
<li>{A, G}-&gt;B &#x2F;&#x2F;第2次大循环，确定{A,G}中的节点和没有走过的节点哪个时最近的，对应边&lt;G, B&gt;权值：3</li>
<li>{A, G, B}-&gt;E&#x2F;&#x2F;第3次大循环，对应，边&lt;G, E&gt;权值：4</li>
<li>{A, G, B, E}-&gt;F&#x2F;&#x2F;第4次大循环，对应边&lt;E,F&gt;权值：5</li>
<li>{A, G, B, E, F}-&gt;D&#x2F;&#x2F;第5次大循环，对应边&lt;F,D&gt;权值：4</li>
<li>{A, G, B, E, F, D}-&gt;C&#x2F;&#x2F;第6次大循环，对应 边&lt;A,C&gt;权值：7</li>
<li>{A, G, B, E, F, D, C}</li>
</ol>
<h3 id="代码实现-40"><a href="#代码实现-40" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimAlogrithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] data = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">verxs</span> <span class="operator">=</span> data.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通</span></span><br><span class="line">        <span class="type">int</span>[][] weight = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">9</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">8</span>, <span class="number">10000</span>, <span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">9</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">8</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10000</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10000</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建MGraph对象</span></span><br><span class="line">        <span class="type">MGraph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MGraph</span>(verxs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个MinTree对象</span></span><br><span class="line">        <span class="type">MinTree</span> <span class="variable">minTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinTree</span>();</span><br><span class="line">        minTree.createGraph(graph, verxs, data, weight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        minTree.show(graph);</span><br><span class="line"></span><br><span class="line">        minTree.prim(graph, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建最小生成树=》村庄的图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建图的邻接矩阵</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph  图对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verxs  图对应的顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data   图的各个顶点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 图的邻接矩阵——边</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createGraph</span><span class="params">(MGraph graph, <span class="type">int</span> verxs, <span class="type">char</span> data[], <span class="type">int</span>[][] weight)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; verxs; i++) &#123;</span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; verxs; j++) &#123;</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(MGraph graph)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link : graph.weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写prim算法，得到最小生成树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v     表示从图的第几个顶点开始生成“A”-&gt;0 &quot;B&quot;-&gt;1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prim</span><span class="params">(MGraph graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个一维数组，用来标记结点（顶点），是否被访问</span></span><br><span class="line">        <span class="type">int</span> visited[] = <span class="keyword">new</span> <span class="title class_">int</span>[graph.verxs];</span><br><span class="line">        <span class="comment">//默认元素的值都是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.verxs; i++) &#123;</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前这个结点标记为已访问</span></span><br><span class="line">        visited[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//用h1，h2记录两个顶点的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h1</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h2</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minWeight</span> <span class="operator">=</span> <span class="number">10000</span>;<span class="comment">//将minWeight初始成一个大数，后面在遍历过程中，会被替代</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; graph.verxs; k++) &#123;<span class="comment">//因为有graph.verxs顶点间就有graph.versx-1边</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这个是确定每一次生成的子图</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.verxs; i++) &#123;<span class="comment">//i结点表示被访问过的结点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph.verxs; j++) &#123;<span class="comment">//j表示还没有访问过的结点</span></span><br><span class="line">                    <span class="keyword">if</span> (visited[i] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span> &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123;</span><br><span class="line">                        <span class="comment">//替换minWeight；(寻找已经访问过的点和未访问过的节点间权值最小的边)</span></span><br><span class="line">                        minWeight = graph.weight[i][j];</span><br><span class="line">                        h1 = i;</span><br><span class="line">                        h2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到一条边是最小</span></span><br><span class="line">            System.out.println(<span class="string">&quot;边&lt;&quot;</span> + graph.data[h1] + <span class="string">&quot;,&quot;</span> + graph.data[h2] + <span class="string">&quot;&gt;权值：&quot;</span> + minWeight);</span><br><span class="line">            <span class="comment">//将当前这个结点标记为已经访问</span></span><br><span class="line">            visited[h2] = <span class="number">1</span>;<span class="comment">//h2=j;</span></span><br><span class="line">            <span class="comment">//将minWeight重新设置为最大值</span></span><br><span class="line">            minWeight = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MGraph</span> &#123;</span><br><span class="line">    <span class="type">int</span> verxs;<span class="comment">//表示图的节点</span></span><br><span class="line">    <span class="type">char</span>[] data;<span class="comment">//存放结点的数据</span></span><br><span class="line">    <span class="type">int</span>[][] weight;<span class="comment">//存放边，就是我们的邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MGraph</span><span class="params">(<span class="type">int</span> verxs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.verxs = verxs;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">char</span>[verxs];</span><br><span class="line">        weight = <span class="keyword">new</span> <span class="title class_">int</span>[verxs][verxs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h2><ol>
<li>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</li>
<li><strong>基本思想</strong>：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路</li>
<li><strong>具体做法</strong>：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。</li>
</ol>
<h3 id="问题-9"><a href="#问题-9" class="headerlink" title="问题"></a>问题</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211223152654756.png" alt="image-20211223152654756"></p>
<ol>
<li>某城市新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通；</li>
<li>各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里；</li>
<li>问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短？</li>
</ol>
<h3 id="思路分析-35"><a href="#思路分析-35" class="headerlink" title="思路分析"></a>思路分析</h3><p>在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。 </p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211223153518021.png" alt="image-20211223153518021"></p>
<p>例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211223153559502.png" alt="image-20211223153559502"></p>
<h4 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h4><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211223153802302.png" alt="image-20211223153802302"></p>
<h4 id="文字描述"><a href="#文字描述" class="headerlink" title="文字描述"></a>文字描述</h4><ol>
<li>将边&lt;E,F&gt;加入R中。 <ul>
<li>边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果R中。</li>
</ul>
</li>
<li>将边&lt;C,D&gt;加入R中。 <ul>
<li>上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果R中。</li>
</ul>
</li>
<li>将边&lt;D,E&gt;加入R中。 <ul>
<li>上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果R中。</li>
</ul>
</li>
<li>将边&lt;B,F&gt;加入R中。 <ul>
<li>上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果R中。</li>
</ul>
</li>
<li>将边&lt;E,G&gt;加入R中。 <ul>
<li>上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果R中。</li>
</ul>
</li>
<li>将边&lt;A,B&gt;加入R中。 <ul>
<li>上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果R中。</li>
</ul>
</li>
</ol>
<p>**此时，最小生成树构造完成！它包括的边依次是：&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;**。</p>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题： </p>
<ul>
<li><p><strong>问题一</strong>：对图的所有边按照权值大小进行排序。 </p>
<ul>
<li>解决方法：很好解决，采用排序算法进行排序即可。</li>
</ul>
</li>
<li><p><strong>问题二</strong>：将边添加到最小生成树中时，怎么样判断是否形成了回路。</p>
<ul>
<li>解决方法：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</li>
</ul>
</li>
</ul>
<h5 id="重合判断思路"><a href="#重合判断思路" class="headerlink" title="重合判断思路"></a>重合判断思路</h5><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211223155437910.png" alt="image-20211223155437910"></p>
<p>在将&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt;加入到最小生成树R中之后，这几条边的顶点就都有了终点：</p>
<ol>
<li>C的终点是F。 </li>
<li>D的终点是F。 </li>
<li>E的终点是F。 </li>
<li>F的终点是F。</li>
</ol>
<p>关于终点的说明：</p>
<ol>
<li>就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”。 </li>
<li>因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是C和E的终点都是F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，&#x3D;&#x3D;我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路。&#x3D;&#x3D;【后面有代码说明】</li>
</ol>
<h3 id="代码实现-41"><a href="#代码实现-41" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KruskalAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> edgeNum;<span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] verstexs;<span class="comment">//顶点数组——顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;<span class="comment">//邻接矩阵——边</span></span><br><span class="line">    <span class="comment">//使用INF表示两个顶点不能连通</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] vertexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//克鲁斯卡尔算法的邻接矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> matrix[][] = &#123;</span><br><span class="line">                <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line">                <span class="comment">/*A*/</span> &#123;<span class="number">0</span>, <span class="number">12</span>, INF, INF, INF, <span class="number">16</span>, <span class="number">14</span>&#125;,</span><br><span class="line">                <span class="comment">/*B*/</span> &#123;<span class="number">12</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/*C*/</span> &#123;INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/*D*/</span> &#123;INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">                <span class="comment">/*E*/</span> &#123;INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                <span class="comment">/*F*/</span> &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                <span class="comment">/*G*/</span> &#123;<span class="number">14</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">KruskalAlgorithm</span> <span class="variable">kruskalAlgorithm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KruskalAlgorithm</span>(vertexs, matrix);</span><br><span class="line">        kruskalAlgorithm.show();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span>);<span class="comment">//没有排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; kruskalAlgorithm.getEdges().length; i++) &#123;</span><br><span class="line">            System.out.println(kruskalAlgorithm.getEdges()[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span>);<span class="comment">//没有排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; kruskalAlgorithm.getEdges().length; i++) &#123;</span><br><span class="line">            System.out.println(kruskalAlgorithm.sortEdges(kruskalAlgorithm.getEdges())[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kruskalAlgorithm.kruskal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KruskalAlgorithm</span><span class="params">(<span class="type">char</span>[] verstexs, <span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化定点数和边的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vlen</span> <span class="operator">=</span> verstexs.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化顶点</span></span><br><span class="line">        <span class="built_in">this</span>.verstexs = <span class="keyword">new</span> <span class="title class_">char</span>[vlen];<span class="comment">//新建数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; verstexs.length; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.verstexs[i] = verstexs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化边</span></span><br><span class="line">        <span class="built_in">this</span>.matrix = <span class="keyword">new</span> <span class="title class_">int</span>[vlen][vlen];<span class="comment">//新建数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.matrix[i][j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.matrix[i][j] != INF) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印邻接矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; verstexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; verstexs.length; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%-12d&quot;</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：对边进行排序处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> edges 边的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EData[] sortEdges(EData[] edges) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; edges.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[j].weight &gt; edges[j + <span class="number">1</span>].weight) &#123;<span class="comment">//交换</span></span><br><span class="line">                    <span class="type">EData</span> <span class="variable">tmp</span> <span class="operator">=</span> edges[j];</span><br><span class="line">                    edges[j] = edges[j + <span class="number">1</span>];</span><br><span class="line">                    edges[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队形下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch 顶点的值，比如&#x27;A&#x27;,&#x27;B&#x27;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回ch对应的下标，如果找不到，返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; verstexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verstexs[i] == ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找不到，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中的边，放到EData[]数组中，后面我们需要遍历该数组</span></span><br><span class="line"><span class="comment">     * 是通过matrix邻接矩阵来获取</span></span><br><span class="line"><span class="comment">     * EData[] 形式[[&#x27;A&#x27;,&#x27;B&#x27;,12],[&#x27;B&#x27;,&#x27;F&#x27;,7],……]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EData[] getEdges() &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        EData[] edges = <span class="keyword">new</span> <span class="title class_">EData</span>[edgeNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; verstexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; verstexs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != INF) &#123;</span><br><span class="line">                    edges[index++] = <span class="keyword">new</span> <span class="title class_">EData</span>(verstexs[i], verstexs[j], matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下标为i的顶点的终点,用于后面判断两个顶点的终点是否相同</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends 数组记录了各个顶点对应的终点是哪个，ends 数组是在遍历过程中逐步判断形成的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i    传入的顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是下表为i这个顶点对应的重点的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEnd</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (ends[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示最后结果数组的索引</span></span><br><span class="line">        <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[edgeNum];<span class="comment">//用于保存已有的最小生成树中每一个顶点在最小生成树中的终点</span></span><br><span class="line">        <span class="comment">//创建结果数组，保存最后的最小生成树</span></span><br><span class="line">        EData[] rets = <span class="keyword">new</span> <span class="title class_">EData</span>[edgeNum];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取图中所有的边的集合，一共有十二条边</span></span><br><span class="line">        EData[] edges = getEdges();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;图的边的集合如下，共&quot;</span> + edges.length + <span class="string">&quot;条&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            System.out.println(edges[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照边的权值大小进行排序（从小到大）</span></span><br><span class="line">        sortEdges(edges);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历edges数组，将边添加到最小生成树中是，判断准备加入的边是否生成了回路，如果没有，就加入rets，否则不能加入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            <span class="comment">//获取到第i条边的第一个顶点（起点）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getPosition(edges[i].start);</span><br><span class="line">            <span class="comment">//获取到第i跳变的第2个顶点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getPosition(edges[i].end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取p1顶点在已有最小生成树中的终点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> getEnd(ends, p1);</span><br><span class="line">            <span class="comment">//获取p1顶点在已有最小生成树中的终点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> getEnd(ends, p2);</span><br><span class="line">            <span class="comment">//是否构成回路</span></span><br><span class="line">            <span class="keyword">if</span> (m != n) &#123;<span class="comment">//没有构成回路</span></span><br><span class="line">                ends[m] = n;<span class="comment">//设置m在已有最小生成树中的终点</span></span><br><span class="line">                rets[index++] = edges[i];<span class="comment">//有一条边加入到rets数组</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;ends:&quot;</span> + Arrays.toString(ends));</span><br><span class="line">            <span class="comment">//ends:[A，B, C, D, E, F, G, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[0, 0, 3, 5, 5, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[0, 0, 3, 5, 5, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[0, 0, 3, 5, 5, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[0, 5, 3, 5, 5, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[0, 5, 3, 5, 5, 6, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[0, 5, 3, 5, 5, 6, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[0, 5, 3, 5, 5, 6, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[6, 5, 3, 5, 5, 6, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[6, 5, 3, 5, 5, 6, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">            <span class="comment">//ends:[6, 5, 3, 5, 5, 6, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计并打印“最小生成树”，输出rest数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            System.out.println(rets[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个Data，他的对象实例就表示一条边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EData</span> &#123;</span><br><span class="line">    <span class="type">char</span> start;<span class="comment">//边的一个点</span></span><br><span class="line">    <span class="type">char</span> end;<span class="comment">//边的另外一个点</span></span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EData</span><span class="params">(<span class="type">char</span> start, <span class="type">char</span> end, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写toSstring，便于输出边的信息</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EDATA [&lt;&quot;</span> + start + <span class="string">&quot;,&quot;</span> + end + <span class="string">&quot;&gt;=&quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">邻接矩阵为：</span><br><span class="line"><span class="number">0</span>           <span class="number">12</span>          <span class="number">2147483647</span>  <span class="number">2147483647</span>  <span class="number">2147483647</span>  <span class="number">16</span>          <span class="number">14</span>          </span><br><span class="line"><span class="number">12</span>          <span class="number">0</span>           <span class="number">10</span>          <span class="number">2147483647</span>  <span class="number">2147483647</span>  <span class="number">7</span>           <span class="number">2147483647</span>  </span><br><span class="line"><span class="number">2147483647</span>  <span class="number">10</span>          <span class="number">0</span>           <span class="number">3</span>           <span class="number">5</span>           <span class="number">6</span>           <span class="number">2147483647</span>  </span><br><span class="line"><span class="number">2147483647</span>  <span class="number">2147483647</span>  <span class="number">3</span>           <span class="number">0</span>           <span class="number">4</span>           <span class="number">2147483647</span>  <span class="number">2147483647</span>  </span><br><span class="line"><span class="number">2147483647</span>  <span class="number">2147483647</span>  <span class="number">5</span>           <span class="number">4</span>           <span class="number">0</span>           <span class="number">2</span>           <span class="number">8</span>           </span><br><span class="line"><span class="number">16</span>          <span class="number">7</span>           <span class="number">6</span>           <span class="number">2147483647</span>  <span class="number">2</span>           <span class="number">0</span>           <span class="number">9</span>           </span><br><span class="line"><span class="number">14</span>          <span class="number">2147483647</span>  <span class="number">2147483647</span>  <span class="number">2147483647</span>  <span class="number">8</span>           <span class="number">9</span>           <span class="number">0</span>           </span><br><span class="line"></span><br><span class="line">排序前:</span><br><span class="line">EDATA [&lt;A,B&gt;=<span class="number">12</span>]</span><br><span class="line">EDATA [&lt;A,F&gt;=<span class="number">16</span>]</span><br><span class="line">EDATA [&lt;A,G&gt;=<span class="number">14</span>]</span><br><span class="line">EDATA [&lt;B,C&gt;=<span class="number">10</span>]</span><br><span class="line">EDATA [&lt;B,F&gt;=<span class="number">7</span>]</span><br><span class="line">EDATA [&lt;C,D&gt;=<span class="number">3</span>]</span><br><span class="line">EDATA [&lt;C,E&gt;=<span class="number">5</span>]</span><br><span class="line">EDATA [&lt;C,F&gt;=<span class="number">6</span>]</span><br><span class="line">EDATA [&lt;D,E&gt;=<span class="number">4</span>]</span><br><span class="line">EDATA [&lt;E,F&gt;=<span class="number">2</span>]</span><br><span class="line">EDATA [&lt;E,G&gt;=<span class="number">8</span>]</span><br><span class="line">EDATA [&lt;F,G&gt;=<span class="number">9</span>]</span><br><span class="line">    </span><br><span class="line">排序后:</span><br><span class="line">EDATA [&lt;E,F&gt;=<span class="number">2</span>]</span><br><span class="line">EDATA [&lt;C,D&gt;=<span class="number">3</span>]</span><br><span class="line">EDATA [&lt;D,E&gt;=<span class="number">4</span>]</span><br><span class="line">EDATA [&lt;C,E&gt;=<span class="number">5</span>]</span><br><span class="line">EDATA [&lt;C,F&gt;=<span class="number">6</span>]</span><br><span class="line">EDATA [&lt;B,F&gt;=<span class="number">7</span>]</span><br><span class="line">EDATA [&lt;E,G&gt;=<span class="number">8</span>]</span><br><span class="line">EDATA [&lt;F,G&gt;=<span class="number">9</span>]</span><br><span class="line">EDATA [&lt;B,C&gt;=<span class="number">10</span>]</span><br><span class="line">EDATA [&lt;A,B&gt;=<span class="number">12</span>]</span><br><span class="line">EDATA [&lt;A,G&gt;=<span class="number">14</span>]</span><br><span class="line">EDATA [&lt;A,F&gt;=<span class="number">16</span>]</span><br><span class="line">    </span><br><span class="line">图的边的集合如下，共<span class="number">12</span>条</span><br><span class="line">EDATA [&lt;A,B&gt;=<span class="number">12</span>]</span><br><span class="line">EDATA [&lt;A,F&gt;=<span class="number">16</span>]</span><br><span class="line">EDATA [&lt;A,G&gt;=<span class="number">14</span>]</span><br><span class="line">EDATA [&lt;B,C&gt;=<span class="number">10</span>]</span><br><span class="line">EDATA [&lt;B,F&gt;=<span class="number">7</span>]</span><br><span class="line">EDATA [&lt;C,D&gt;=<span class="number">3</span>]</span><br><span class="line">EDATA [&lt;C,E&gt;=<span class="number">5</span>]</span><br><span class="line">EDATA [&lt;C,F&gt;=<span class="number">6</span>]</span><br><span class="line">EDATA [&lt;D,E&gt;=<span class="number">4</span>]</span><br><span class="line">EDATA [&lt;E,F&gt;=<span class="number">2</span>]</span><br><span class="line">EDATA [&lt;E,G&gt;=<span class="number">8</span>]</span><br><span class="line">EDATA [&lt;F,G&gt;=<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">ends:</span><br><span class="line">ends:[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ends:[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ends:[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ends:[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ends:[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ends:[<span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ends:[<span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ends:[<span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ends:[<span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ends:[<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ends:[<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ends:[<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">最小生成树为：</span><br><span class="line">EDATA [&lt;E,F&gt;=<span class="number">2</span>]</span><br><span class="line">EDATA [&lt;C,D&gt;=<span class="number">3</span>]</span><br><span class="line">EDATA [&lt;D,E&gt;=<span class="number">4</span>]</span><br><span class="line">EDATA [&lt;B,F&gt;=<span class="number">7</span>]</span><br><span class="line">EDATA [&lt;E,G&gt;=<span class="number">8</span>]</span><br><span class="line">EDATA [&lt;A,B&gt;=<span class="number">12</span>]</span><br></pre></td></tr></table></figure>

<h2 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h2><p>迪杰斯特拉(Dijkstra)算法是<strong>典型最短路径算法</strong>，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展**(广度优先搜索思想**)，直到扩展到终点为止。</p>
<h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p>设置出发顶点为v，顶点集合V{v1,v2,v<sub>i</sub>…}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,d<sub>i</sub>…}，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到v<sub>i </sub> 距离对应为d<sub>i</sub> )</p>
<ol>
<li>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi。此时被移出的部分，v到vi即为最短路径。</li>
<li>更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)。</li>
<li>重复执行两步骤，直到最短路径顶点为目标顶点即可结束。</li>
</ol>
<h3 id="问题-10"><a href="#问题-10" class="headerlink" title="问题"></a>问题</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211224085815011.png" alt="image-20211224085815011"></p>
<ol>
<li>战争时期，胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄</li>
<li>各个村庄的距离用边线表示(权) ，比如 A – B 距离是5公里</li>
<li>问：如何计算出G村庄到其它各个村庄的最短距离？</li>
<li>如果从其它点出发到各个点的最短距离又是多少？</li>
</ol>
<h3 id="思路分析-36"><a href="#思路分析-36" class="headerlink" title="思路分析"></a>思路分析</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211224105124038.png" alt="image-20211224105124038"></p>
<h3 id="代码实现-42"><a href="#代码实现-42" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迪杰特斯拉算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] vertexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[][] martex = <span class="keyword">new</span> <span class="title class_">int</span>[vertexs.length][vertexs.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line">        martex[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;N, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span>&#125;;</span><br><span class="line">        martex[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>, N, N, <span class="number">9</span>, N, N, <span class="number">3</span>&#125;;</span><br><span class="line">        martex[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">7</span>, N, N, N, <span class="number">8</span>, N, N&#125;;</span><br><span class="line">        martex[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;N, <span class="number">9</span>, N, N, N, <span class="number">4</span>, N&#125;;</span><br><span class="line">        martex[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;N, N, <span class="number">8</span>, N, N, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        martex[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;N, N, N, <span class="number">4</span>, <span class="number">5</span>, N, <span class="number">6</span>&#125;;</span><br><span class="line">        martex[<span class="number">6</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, N&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个图对象</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(vertexs, martex);</span><br><span class="line">        graph.show();</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        graph.dijkstra(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        graph.showDijkstra();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已访问的顶点结合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VisitedVertex</span> &#123;</span><br><span class="line">    <span class="comment">//记录这个顶点是否被访问过，1表示访问过、0表示没访问过，动态更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] already_arr;</span><br><span class="line">    <span class="comment">//每个下标对应的值为前一个顶点下标，会动态更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] pre_visited;</span><br><span class="line">    <span class="comment">//记录出发顶点到其他顶点的距离</span></span><br><span class="line">    <span class="comment">//以G为出发点为例，会记录G到其他顶点的距离，并动态更新，求出最端距离时就会放到dis</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VisitedVertex</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.already_arr = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="built_in">this</span>.pre_visited = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="built_in">this</span>.dis = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化dis数组</span></span><br><span class="line">        Arrays.fill(dis, <span class="number">65535</span>);</span><br><span class="line">        <span class="built_in">this</span>.already_arr[index] = <span class="number">1</span>;<span class="comment">//设置出发顶点为被访问</span></span><br><span class="line">        <span class="built_in">this</span>.dis[index] = <span class="number">0</span>;<span class="comment">//出发顶点到自己的距离为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断index顶点是否被访问过</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 当前结点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果访问过就返回true, 否则就返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">in</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> already_arr[index] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新出发顶点到结点index结点的距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDis</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        dis[index] = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新顶点pre的前驱结点为index结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePre</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        pre_visited[pre] = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDis</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateArr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">65535</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; already_arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (already_arr[i] == <span class="number">0</span> &amp;&amp; dis[i] &lt; min) &#123;<span class="comment">//未访问、求出最短路径</span></span><br><span class="line">                min = dis[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新index顶点 被访问过</span></span><br><span class="line">        already_arr[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示最后的结果，即，输出三个数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;already_arr:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : already_arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;pre_visited:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : pre_visited) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;dis:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : dis) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] vertexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : dis) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">65535</span>) &#123;</span><br><span class="line">                System.out.print(vertexs[count] + <span class="string">&quot;(&quot;</span> + i + <span class="string">&quot;)&quot;</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;N&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertex;<span class="comment">//顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;<span class="comment">//邻接矩阵——边</span></span><br><span class="line">    <span class="keyword">private</span> VisitedVertex visitedVertex;<span class="comment">//已经访问的顶点的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">char</span>[] vertex, <span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex = vertex;</span><br><span class="line">        <span class="built_in">this</span>.matrix = matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link : matrix) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迪杰斯特拉算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 出发顶点对应的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        visitedVertex = <span class="keyword">new</span> <span class="title class_">VisitedVertex</span>(vertex.length, index);</span><br><span class="line">        update(index);<span class="comment">//更新index顶点到周围顶点的距离和前驱结点</span></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            index = visitedVertex.updateArr();<span class="comment">//选择并返回新的访问顶点</span></span><br><span class="line">            update(index);<span class="comment">//更新index顶点到周围顶点的 距离和前置结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新index下标顶点到周围顶点的距离 和 周围顶点的前驱结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//距离</span></span><br><span class="line">        <span class="comment">//遍历邻接矩阵的 matrix[index] 行 ,遍历当前顶点到周围顶点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix[index].length; i++) &#123;</span><br><span class="line">            <span class="comment">//len :出发顶点到index顶点的距离 + 从index结点到i结点距离</span></span><br><span class="line">            len = visitedVertex.getDis(index) + matrix[index][i];</span><br><span class="line">            <span class="comment">//如果i顶点没有被访问过，并且len小于出发顶点到i顶点的距离，就需要更新</span></span><br><span class="line">            <span class="keyword">if</span> (!visitedVertex.in(i) &amp;&amp; len &lt; visitedVertex.getDis(i)) &#123;</span><br><span class="line">                visitedVertex.updatePre(i, index);<span class="comment">//更新i结点的前置结点为index结点</span></span><br><span class="line">                visitedVertex.updateDis(i, len);<span class="comment">//更新出发点到i结点的距离</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showDijkstra</span><span class="params">()</span> &#123;</span><br><span class="line">        visitedVertex.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">65535</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">65535</span>, <span class="number">65535</span>, <span class="number">65535</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">65535</span>, <span class="number">65535</span>, <span class="number">9</span>, <span class="number">65535</span>, <span class="number">65535</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">65535</span>, <span class="number">65535</span>, <span class="number">65535</span>, <span class="number">8</span>, <span class="number">65535</span>, <span class="number">65535</span>]</span><br><span class="line">[<span class="number">65535</span>, <span class="number">9</span>, <span class="number">65535</span>, <span class="number">65535</span>, <span class="number">65535</span>, <span class="number">4</span>, <span class="number">65535</span>]</span><br><span class="line">[<span class="number">65535</span>, <span class="number">65535</span>, <span class="number">8</span>, <span class="number">65535</span>, <span class="number">65535</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">65535</span>, <span class="number">65535</span>, <span class="number">65535</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">65535</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">65535</span>, <span class="number">65535</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">65535</span>]</span><br><span class="line"></span><br><span class="line">already_arr:</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">pre_visited:</span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">0</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">dis:</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">9</span> <span class="number">10</span> <span class="number">4</span> <span class="number">6</span> <span class="number">0</span> </span><br><span class="line">A(<span class="number">2</span>) A(<span class="number">3</span>) A(<span class="number">9</span>) A(<span class="number">10</span>) A(<span class="number">4</span>) A(<span class="number">6</span>) A(<span class="number">0</span>) </span><br></pre></td></tr></table></figure>

<h4 id="部分代码解释"><a href="#部分代码解释" class="headerlink" title="部分代码解释"></a>部分代码解释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新index下标顶点到周围顶点的距离 和 周围顶点的前驱结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//距离</span></span><br><span class="line">    <span class="comment">//遍历邻接矩阵的 matrix[index] 行 ,遍历当前顶点到周围顶点的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix[index].length; i++) &#123;</span><br><span class="line">        <span class="comment">//len :出发顶点到index顶点的距离 + 从index结点到i结点距离</span></span><br><span class="line">        len = visitedVertex.getDis(index) + matrix[index][i];</span><br><span class="line">        <span class="comment">//如果i顶点没有被访问过，并且len小于出发顶点到i顶点的距离，就需要更新</span></span><br><span class="line">        <span class="keyword">if</span> (!visitedVertex.in(i) &amp;&amp; len &lt; visitedVertex.getDis(i)) &#123;</span><br><span class="line">            visitedVertex.updatePre(i, index);<span class="comment">//更新i结点的前置结点为index结点</span></span><br><span class="line">            visitedVertex.updateDis(i, len);<span class="comment">//更新出发点到i结点的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改前：</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211224133658663.png" alt="image-20211224133658663"></p>
<p><strong>修改后：</strong></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211224133724677.png" alt="image-20211224133724677"></p>
<h2 id="佛洛伊德算法"><a href="#佛洛伊德算法" class="headerlink" title="佛洛伊德算法"></a>佛洛伊德算法</h2><h3 id="概述-18"><a href="#概述-18" class="headerlink" title="概述"></a>概述</h3><ol>
<li>和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名</li>
<li>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</li>
<li>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</li>
<li><strong>弗洛伊德算法</strong> VS <strong>迪杰斯特拉算法</strong>：迪杰斯特拉算法通过<strong>选定的被访问顶点</strong>，求出从出发访问顶点到其他顶点的<strong>最短路径</strong>；弗洛伊德算法中<strong>每一个顶点都是出发访问点</strong>，所以需要将每一个顶点看做被访问顶点，求出从<strong>每一个顶点到其他顶点的最短路径</strong>。</li>
</ol>
<h3 id="问题-11"><a href="#问题-11" class="headerlink" title="问题"></a>问题</h3><p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211224152540451.png" alt="image-20211224152540451"></p>
<ol>
<li>胜利乡有7个村庄(A, B, C, D, E, F, G)</li>
<li>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里</li>
<li>问：如何计算出各村庄到 其它各村庄的最短距离?</li>
</ol>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ol>
<li><p>设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径</p>
</li>
<li><p>至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得</p>
</li>
<li><p>弗洛伊德(Floyd)算法图解分析-举例说明</p>
</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211224154232820.png" alt="image-20211224154232820"></p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211224154244995.png" alt="image-20211224154244995"></p>
<p>佛洛依德算法的步骤：</p>
<p>第一轮循环中，以A(下标为：0)作为中间顶点，距离表和前驱关系更新为：</p>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211224154259783.png" alt="image-20211224154259783"></p>
<p>分析如下：</p>
<ol>
<li>以A顶点作为中间顶点是，B-&gt;A-&gt;C的距离由N-&gt;9，同理C到B；C-&gt;A-&gt;G的距离由N-&gt;12，同理G到C</li>
<li>更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束</li>
</ol>
<p><img src="/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211224161713506.png" alt="image-20211224161713506"></p>
<blockquote>
<p>A A A F G G A<br>(A到A的最短路径是0) (A到B的最短路径是5) (A到C的最短路径是7) (A到D的最短路径是12) (A到E的最短路径是6) (A到F的最短路径是8) (A到G的最短路径是2) </p>
<p>B B A B G G B<br>(B到A的最短路径是5) (B到B的最短路径是0) (B到C的最短路径是12) (B到D的最短路径是9) (B到E的最短路径是7) (B到F的最短路径是9) (B到G的最短路径是3) </p>
<p>C A C F C E A<br>(C到A的最短路径是7) (C到B的最短路径是12) (C到C的最短路径是0) (C到D的最短路径是17) (C到E的最短路径是8) (C到F的最短路径是13) (C到G的最短路径是9) </p>
<p>G D E D F D F<br>(D到A的最短路径是12) (D到B的最短路径是9) (D到C的最短路径是17) (D到D的最短路径是0) (D到E的最短路径是9) (D到F的最短路径是4) (D到G的最短路径是10) </p>
<p>G G E F E E E<br>(E到A的最短路径是6) (E到B的最短路径是7) (E到C的最短路径是8) (E到D的最短路径是9) (E到E的最短路径是0) (E到F的最短路径是5) (E到G的最短路径是4) </p>
<p>G G E F F F F<br>(F到A的最短路径是8) (F到B的最短路径是9) (F到C的最短路径是13) (F到D的最短路径是4) (F到E的最短路径是5) (F到F的最短路径是0) (F到G的最短路径是6) </p>
<p>G G A F G G G<br>(G到A的最短路径是2) (G到B的最短路径是3) (G到C的最短路径是9) (G到D的最短路径是10) (G到E的最短路径是4) (G到F的最短路径是6) (G到G的最短路径是0) </p>
</blockquote>
<h3 id="代码实现-43"><a href="#代码实现-43" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FloydAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试看看图是否创建成功</span></span><br><span class="line">        <span class="type">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建邻接矩阵</span></span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(<span class="number">7</span>, matrix, vertex);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;佛洛依德算法执行前：&quot;</span>);</span><br><span class="line">        graph.show();</span><br><span class="line"></span><br><span class="line">        graph.floyd();</span><br><span class="line">        System.out.println(<span class="string">&quot;佛洛依德算法执行后：&quot;</span>);</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertex;<span class="comment">//存放顶点的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dis;<span class="comment">//存放从各个顶点出发到其他顶点的距离(最后的结果也保留在该数组中)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] pre;<span class="comment">//存放各个顶点的前驱结点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 邻接矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span>[][] matrix, <span class="type">char</span>[] vertex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex = vertex;</span><br><span class="line">        <span class="built_in">this</span>.dis = matrix;</span><br><span class="line">        <span class="built_in">this</span>.pre = <span class="keyword">new</span> <span class="title class_">int</span>[length][length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对pre数组进行初始化,存放前驱结点的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            Arrays.fill(pre[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//pre</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">            <span class="comment">//先输出pre数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; pre.length; j++) &#123;</span><br><span class="line">                System.out.print(vertex[pre[i][j]] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">//再输出dis数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dis.length; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;（&quot;</span> + vertex[i] + <span class="string">&quot;—&gt;&quot;</span> + vertex[j] + <span class="string">&quot;,min：&quot;</span> + dis[i][j] + <span class="string">&quot;） &quot;</span>);<span class="comment">//i到j的最短路径是dis</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弗洛伊德算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弗洛伊德算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//变量保存距离</span></span><br><span class="line">        <span class="comment">//i 通过 k中间节点 到 j</span></span><br><span class="line">        <span class="comment">//对中间顶点的遍历，k就是中间顶点的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; dis.length; k++) &#123;</span><br><span class="line">            <span class="comment">//从i顶点开始出发：[A,B,C,D,E,F,G]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                <span class="comment">//到达j顶点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dis.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k != i &amp;&amp; k != j &amp;&amp; dis[i][k] != N &amp;&amp; dis[k][j] != N) &#123;</span><br><span class="line">                        len = dis[i][k] + dis[k][j];<span class="comment">//=&gt;求出从i顶点出发，经过k中间顶点，到达j顶点的距离</span></span><br><span class="line">                        <span class="keyword">if</span> (len &lt; dis[i][j]) &#123;</span><br><span class="line">                            <span class="comment">//如果len小于dis[i][j]</span></span><br><span class="line">                            dis[i][j] = len;<span class="comment">//更新距离</span></span><br><span class="line">                            pre[i][j] = pre[k][j];<span class="comment">//更新前驱顶点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">佛洛依德算法执行前：</span><br><span class="line">A A A A A A A </span><br><span class="line">（A—&gt;A,min：<span class="number">0</span>） （A—&gt;B,min：<span class="number">5</span>） （A—&gt;C,min：<span class="number">7</span>） （A—&gt;D,min：<span class="number">65535</span>） （A—&gt;E,min：<span class="number">65535</span>） （A—&gt;F,min：<span class="number">65535</span>） （A—&gt;G,min：<span class="number">2</span>） </span><br><span class="line"></span><br><span class="line">B B B B B B B </span><br><span class="line">（B—&gt;A,min：<span class="number">5</span>） （B—&gt;B,min：<span class="number">0</span>） （B—&gt;C,min：<span class="number">65535</span>） （B—&gt;D,min：<span class="number">9</span>） （B—&gt;E,min：<span class="number">65535</span>） （B—&gt;F,min：<span class="number">65535</span>） （B—&gt;G,min：<span class="number">3</span>） </span><br><span class="line"></span><br><span class="line">C C C C C C C </span><br><span class="line">（C—&gt;A,min：<span class="number">7</span>） （C—&gt;B,min：<span class="number">65535</span>） （C—&gt;C,min：<span class="number">0</span>） （C—&gt;D,min：<span class="number">65535</span>） （C—&gt;E,min：<span class="number">8</span>） （C—&gt;F,min：<span class="number">65535</span>） （C—&gt;G,min：<span class="number">65535</span>） </span><br><span class="line"></span><br><span class="line">D D D D D D D </span><br><span class="line">（D—&gt;A,min：<span class="number">65535</span>） （D—&gt;B,min：<span class="number">9</span>） （D—&gt;C,min：<span class="number">65535</span>） （D—&gt;D,min：<span class="number">0</span>） （D—&gt;E,min：<span class="number">65535</span>） （D—&gt;F,min：<span class="number">4</span>） （D—&gt;G,min：<span class="number">65535</span>） </span><br><span class="line"></span><br><span class="line">E E E E E E E </span><br><span class="line">（E—&gt;A,min：<span class="number">65535</span>） （E—&gt;B,min：<span class="number">65535</span>） （E—&gt;C,min：<span class="number">8</span>） （E—&gt;D,min：<span class="number">65535</span>） （E—&gt;E,min：<span class="number">0</span>） （E—&gt;F,min：<span class="number">5</span>） （E—&gt;G,min：<span class="number">4</span>） </span><br><span class="line"></span><br><span class="line">F F F F F F F </span><br><span class="line">（F—&gt;A,min：<span class="number">65535</span>） （F—&gt;B,min：<span class="number">65535</span>） （F—&gt;C,min：<span class="number">65535</span>） （F—&gt;D,min：<span class="number">4</span>） （F—&gt;E,min：<span class="number">5</span>） （F—&gt;F,min：<span class="number">0</span>） （F—&gt;G,min：<span class="number">6</span>） </span><br><span class="line"></span><br><span class="line">G G G G G G G </span><br><span class="line">（G—&gt;A,min：<span class="number">2</span>） （G—&gt;B,min：<span class="number">3</span>） （G—&gt;C,min：<span class="number">65535</span>） （G—&gt;D,min：<span class="number">65535</span>） （G—&gt;E,min：<span class="number">4</span>） （G—&gt;F,min：<span class="number">6</span>） （G—&gt;G,min：<span class="number">0</span>） </span><br><span class="line"></span><br><span class="line">佛洛依德算法执行后：</span><br><span class="line">A A A F G G A </span><br><span class="line">（A—&gt;A,min：<span class="number">0</span>） （A—&gt;B,min：<span class="number">5</span>） （A—&gt;C,min：<span class="number">7</span>） （A—&gt;D,min：<span class="number">12</span>） （A—&gt;E,min：<span class="number">6</span>） （A—&gt;F,min：<span class="number">8</span>） （A—&gt;G,min：<span class="number">2</span>） </span><br><span class="line"></span><br><span class="line">B B A B G G B </span><br><span class="line">（B—&gt;A,min：<span class="number">5</span>） （B—&gt;B,min：<span class="number">0</span>） （B—&gt;C,min：<span class="number">12</span>） （B—&gt;D,min：<span class="number">9</span>） （B—&gt;E,min：<span class="number">7</span>） （B—&gt;F,min：<span class="number">9</span>） （B—&gt;G,min：<span class="number">3</span>） </span><br><span class="line"></span><br><span class="line">C A C F C E A </span><br><span class="line">（C—&gt;A,min：<span class="number">7</span>） （C—&gt;B,min：<span class="number">12</span>） （C—&gt;C,min：<span class="number">0</span>） （C—&gt;D,min：<span class="number">17</span>） （C—&gt;E,min：<span class="number">8</span>） （C—&gt;F,min：<span class="number">13</span>） （C—&gt;G,min：<span class="number">9</span>） </span><br><span class="line"></span><br><span class="line">G D E D F D F </span><br><span class="line">（D—&gt;A,min：<span class="number">12</span>） （D—&gt;B,min：<span class="number">9</span>） （D—&gt;C,min：<span class="number">17</span>） （D—&gt;D,min：<span class="number">0</span>） （D—&gt;E,min：<span class="number">9</span>） （D—&gt;F,min：<span class="number">4</span>） （D—&gt;G,min：<span class="number">10</span>） </span><br><span class="line"></span><br><span class="line">G G E F E E E </span><br><span class="line">（E—&gt;A,min：<span class="number">6</span>） （E—&gt;B,min：<span class="number">7</span>） （E—&gt;C,min：<span class="number">8</span>） （E—&gt;D,min：<span class="number">9</span>） （E—&gt;E,min：<span class="number">0</span>） （E—&gt;F,min：<span class="number">5</span>） （E—&gt;G,min：<span class="number">4</span>） </span><br><span class="line"></span><br><span class="line">G G E F F F F </span><br><span class="line">（F—&gt;A,min：<span class="number">8</span>） （F—&gt;B,min：<span class="number">9</span>） （F—&gt;C,min：<span class="number">13</span>） （F—&gt;D,min：<span class="number">4</span>） （F—&gt;E,min：<span class="number">5</span>） （F—&gt;F,min：<span class="number">0</span>） （F—&gt;G,min：<span class="number">6</span>） </span><br><span class="line"></span><br><span class="line">G G A F G G G </span><br><span class="line">（G—&gt;A,min：<span class="number">2</span>） （G—&gt;B,min：<span class="number">3</span>） （G—&gt;C,min：<span class="number">9</span>） （G—&gt;D,min：<span class="number">10</span>） （G—&gt;E,min：<span class="number">4</span>） （G—&gt;F,min：<span class="number">6</span>） （G—&gt;G,min：<span class="number">0</span>） </span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://water001-maker.github.io">Xue_Water</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://water001-maker.github.io/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://water001-maker.github.io/2023/02/18/算法与数据结构/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://water001-maker.github.io" target="_blank">幻想家的秘密基地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/cover5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/18/HTTP/" title="HTTP详解"><img class="cover" src="/img/cover5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTTP详解</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/17/fast-fail/" title="list的Fast-Fail机制"><img class="cover" src="/img/cover9.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">list的Fast-Fail机制</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xue_Water</div><div class="author-info__description">学而不思则罔，思而不学则殆</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Water001-maker"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一个努力学习的小白，会不定期将自己的学习笔记整理到这里，仅供大家学习和参考。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">算法与数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">线性结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">非线性结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">稀疏数组和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">2.1.</span> <span class="toc-text">稀疏矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">2.2.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">2.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1"><span class="toc-number">2.2.2.</span> <span class="toc-text">实例1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-1"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2"><span class="toc-number">2.2.3.</span> <span class="toc-text">实例2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-2"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">单向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">实例1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-3"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%951"><span class="toc-number">3.2.2.</span> <span class="toc-text">面试1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%952"><span class="toc-number">3.2.3.</span> <span class="toc-text">面试2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%953"><span class="toc-number">3.2.4.</span> <span class="toc-text">面试3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%954"><span class="toc-number">3.2.5.</span> <span class="toc-text">面试4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%955"><span class="toc-number">3.2.6.</span> <span class="toc-text">面试5</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">3.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-4"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">约瑟夫问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-number">3.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">3.4.2.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-5"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">4.2.</span> <span class="toc-text">快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-6"><span class="toc-number">4.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">4.2.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%88%E4%B8%AD%E7%BC%80%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">综合计算器（中缀）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-7"><span class="toc-number">4.3.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">4.3.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">前缀、中缀、后缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89"><span class="toc-number">4.4.1.</span> <span class="toc-text">前缀表达式（波兰表达式）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-7"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text">中缀表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.4.3.</span> <span class="toc-text">后缀表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">逆波兰计算器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-8"><span class="toc-number">4.5.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.5.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">中缀表达式转换为后缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-9"><span class="toc-number">4.6.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.6.2.</span> <span class="toc-text">核心方法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">4.6.3.</span> <span class="toc-text">完整代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">5.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%B7%E5%AE%AB%E5%9B%9E%E6%BA%AF"><span class="toc-number">5.1.</span> <span class="toc-text">迷宫回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-10"><span class="toc-number">5.1.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">5.1.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">八皇后问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-11"><span class="toc-number">5.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">5.2.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">6.1.</span> <span class="toc-text">算法的时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E9%A2%91%E5%BA%A6"><span class="toc-number">6.1.1.</span> <span class="toc-text">时间频度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">6.1.2.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BE%E4%BE%8B"><span class="toc-number">6.1.3.</span> <span class="toc-text">时间复杂度举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0%E9%98%B6O-1"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">常数阶O(1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E9%98%B6O-log2n"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">对数阶O(log2n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E9%98%B6O-n"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">线性阶O(n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%AF%B9%E6%95%B0%E9%98%B60-nlog2n"><span class="toc-number">6.1.3.4.</span> <span class="toc-text">线性对数阶0(nlog2n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E9%98%B6O-n2"><span class="toc-number">6.1.3.5.</span> <span class="toc-text">平方阶O(n2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E6%96%B9%E9%98%B6O-n3-%E3%80%81k%E6%AC%A1%E6%96%B9%E9%98%B6O-nk"><span class="toc-number">6.1.3.6.</span> <span class="toc-text">立方阶O(n3)、k次方阶O(nk)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E9%98%B60-2n"><span class="toc-number">6.1.3.7.</span> <span class="toc-text">指数阶0(2n)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">6.1.4.</span> <span class="toc-text">算法的空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">6.2.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="toc-number">6.2.1.</span> <span class="toc-text">排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-number">6.2.2.</span> <span class="toc-text">排序规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8"><span class="toc-number">6.2.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">6.3.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3-1"><span class="toc-number">6.3.1.</span> <span class="toc-text">排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99-1"><span class="toc-number">6.3.2.</span> <span class="toc-text">排序规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-9"><span class="toc-number">6.3.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">6.4.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3-2"><span class="toc-number">6.4.1.</span> <span class="toc-text">排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-10"><span class="toc-number">6.4.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">6.5.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3-3"><span class="toc-number">6.5.1.</span> <span class="toc-text">排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E6%B3%95"><span class="toc-number">6.5.2.</span> <span class="toc-text">代码实现——交换法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E4%BD%8D%E7%A7%BB%E6%B3%95%EF%BC%88%E6%94%B9%E8%BF%9B%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BA%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">6.5.3.</span> <span class="toc-text">代码实现——位移法（改进，引入了插入排序）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">6.6.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3-4"><span class="toc-number">6.6.1.</span> <span class="toc-text">排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99-2"><span class="toc-number">6.6.2.</span> <span class="toc-text">排序规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B01"><span class="toc-number">6.6.3.</span> <span class="toc-text">代码实现1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B02"><span class="toc-number">6.6.4.</span> <span class="toc-text">代码实现2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">6.7.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3-5"><span class="toc-number">6.7.1.</span> <span class="toc-text">排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-11"><span class="toc-number">6.7.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">6.8.</span> <span class="toc-text">基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3-6"><span class="toc-number">6.8.1.</span> <span class="toc-text">排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-12"><span class="toc-number">6.8.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">6.8.3.</span> <span class="toc-text">基数排序的说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%92%8C%E5%AF%B9%E6%AF%94"><span class="toc-number">6.9.</span> <span class="toc-text">总结和对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="toc-number">7.1.</span> <span class="toc-text">线性查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-13"><span class="toc-number">7.1.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">7.2.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-12"><span class="toc-number">7.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-14"><span class="toc-number">7.2.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">7.3.</span> <span class="toc-text">插值查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-13"><span class="toc-number">7.3.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-15"><span class="toc-number">7.3.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">7.3.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="toc-number">7.4.</span> <span class="toc-text">斐波那契查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">7.4.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-16"><span class="toc-number">7.4.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">8.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-8"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-14"><span class="toc-number">8.2.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-17"><span class="toc-number">8.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">9.</span> <span class="toc-text">树结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-9"><span class="toc-number">9.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">9.1.1.</span> <span class="toc-text">数组存储方式的分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E9%9B%86%E5%90%88%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">ArrayList集合的扩容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">9.1.2.</span> <span class="toc-text">链式存储方式的分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">9.1.3.</span> <span class="toc-text">树存储方式的分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="toc-number">9.2.</span> <span class="toc-text">基础部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.2.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-10"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">9.2.1.2.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-15"><span class="toc-number">9.2.1.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.1.2.2.</span> <span class="toc-text">核心代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">9.2.1.3.</span> <span class="toc-text">二叉树的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-16"><span class="toc-number">9.2.1.3.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">9.2.1.3.2.</span> <span class="toc-text">核心代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">9.2.1.4.</span> <span class="toc-text">二叉树的删除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-17"><span class="toc-number">9.2.1.4.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">9.2.1.4.2.</span> <span class="toc-text">核心代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-1"><span class="toc-number">9.2.1.5.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.2.2.</span> <span class="toc-text">顺序存储二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-18"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-18"><span class="toc-number">9.2.2.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.2.3.</span> <span class="toc-text">线索化二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-11"><span class="toc-number">9.2.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-3"><span class="toc-number">9.2.3.2.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-19"><span class="toc-number">9.2.3.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-19"><span class="toc-number">9.2.3.2.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.2.3.2.3.</span> <span class="toc-text">遍历线索化二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">9.2.3.2.4.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-2"><span class="toc-number">9.2.3.2.5.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%EF%BC%9A%E5%A4%9A%E7%A7%8D%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">9.2.3.3.</span> <span class="toc-text">作业：多种线索化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E5%8C%96%E6%AF%94%E8%BE%83"><span class="toc-number">9.2.3.3.1.</span> <span class="toc-text">线索化比较</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">实际应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.1.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-12"><span class="toc-number">9.3.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%80%9D%E8%B7%AF"><span class="toc-number">9.3.1.2.</span> <span class="toc-text">排序思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99-3"><span class="toc-number">9.3.1.3.</span> <span class="toc-text">排序规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-20"><span class="toc-number">9.3.1.4.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">9.3.2.</span> <span class="toc-text">优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">9.3.2.1.</span> <span class="toc-text">最大优先队列（大顶堆实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-21"><span class="toc-number">9.3.2.1.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%B0%8F%E9%A1%B6%E5%A0%86%EF%BC%89"><span class="toc-number">9.3.2.2.</span> <span class="toc-text">最小优先队列（小顶堆）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-22"><span class="toc-number">9.3.2.2.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">9.3.2.3.</span> <span class="toc-text">索引优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-13"><span class="toc-number">9.3.2.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-20"><span class="toc-number">9.3.2.3.2.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-23"><span class="toc-number">9.3.2.3.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%B0%94%E6%9B%BC%E6%A0%91"><span class="toc-number">9.3.3.</span> <span class="toc-text">赫尔曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-14"><span class="toc-number">9.3.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-number">9.3.3.2.</span> <span class="toc-text">重要概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-4"><span class="toc-number">9.3.3.3.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E6%88%90%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.3.3.3.1.</span> <span class="toc-text">构成赫夫曼树的四个步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-24"><span class="toc-number">9.3.3.3.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%B0%94%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">9.3.4.</span> <span class="toc-text">赫尔曼编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.5.</span> <span class="toc-text">二叉树排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-15"><span class="toc-number">9.3.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-21"><span class="toc-number">9.3.5.2.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-25"><span class="toc-number">9.3.5.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%E6%A0%91%EF%BC%89"><span class="toc-number">9.3.6.</span> <span class="toc-text">平衡二叉树（AVL树）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.6.1.</span> <span class="toc-text">引出问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">9.3.6.2.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC"><span class="toc-number">9.3.6.3.</span> <span class="toc-text">左旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%81%E6%B1%82"><span class="toc-number">9.3.6.3.1.</span> <span class="toc-text">要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-22"><span class="toc-number">9.3.6.3.2.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-26"><span class="toc-number">9.3.6.3.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E6%97%8B%E8%BD%AC"><span class="toc-number">9.3.6.4.</span> <span class="toc-text">右旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%81%E6%B1%82-1"><span class="toc-number">9.3.6.4.1.</span> <span class="toc-text">要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-23"><span class="toc-number">9.3.6.4.2.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-27"><span class="toc-number">9.3.6.4.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%97%8B%E6%A0%91"><span class="toc-number">9.3.6.5.</span> <span class="toc-text">双旋树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.6.5.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">9.3.6.5.2.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-24"><span class="toc-number">9.3.6.5.3.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-28"><span class="toc-number">9.3.6.5.4.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.3.6.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">10.</span> <span class="toc-text">多路查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8EB%E6%A0%91"><span class="toc-number">10.1.</span> <span class="toc-text">二叉树与B树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="toc-number">10.1.1.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%8F%89%E6%A0%91"><span class="toc-number">10.1.2.</span> <span class="toc-text">多叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%95%B0"><span class="toc-number">10.1.3.</span> <span class="toc-text">B数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E6%A0%91"><span class="toc-number">10.2.</span> <span class="toc-text">2-3树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">10.2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">10.2.2.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">10.2.3.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%912-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">10.2.3.1.</span> <span class="toc-text">1.向2-结点中插入新键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%91%E4%B8%80%E6%A3%B5%E5%8F%AA%E5%90%AB%E6%9C%89%E4%B8%80%E4%B8%AA3-%E7%BB%93%E7%82%B9%E7%9A%84%E6%A0%91%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">10.2.3.2.</span> <span class="toc-text">2.向一棵只含有一个3-结点的树中插入新键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%91%E4%B8%80%E4%B8%AA%E7%88%B6%E8%8A%82%E7%82%B9%E4%B8%BA2-%E7%BB%93%E7%82%B9%E7%9A%843-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">10.2.3.3.</span> <span class="toc-text">3.向一个父节点为2-结点的3-结点中插入新键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%90%91%E4%B8%80%E4%B8%AA%E7%88%B6%E8%8A%82%E7%82%B9%E4%B8%BA3-%E7%BB%93%E7%82%B9%E7%9A%843-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">10.2.3.4.</span> <span class="toc-text">4.向一个父节点为3-结点的3-结点中插入新键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%88%86%E8%A7%A3%E6%A0%B9%E8%8A%82%E7%82%B9"><span class="toc-number">10.2.3.5.</span> <span class="toc-text">5.分解根节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">10.2.4.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">10.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">10.3.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-16"><span class="toc-number">10.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">10.3.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-25"><span class="toc-number">10.3.3.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">10.3.4.</span> <span class="toc-text">树的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E5%8C%96"><span class="toc-number">10.3.4.1.</span> <span class="toc-text">平衡化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B"><span class="toc-number">10.3.4.1.1.</span> <span class="toc-text">左旋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%B3%E6%97%8B"><span class="toc-number">10.3.4.1.2.</span> <span class="toc-text">右旋</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-1"><span class="toc-number">10.3.4.2.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%90%91%E5%8D%95%E4%B8%AA2-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">10.3.4.2.1.</span> <span class="toc-text">1.向单个2-结点中插入新键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%90%91%E5%BA%95%E9%83%A8%E7%9A%842-%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">10.3.4.2.2.</span> <span class="toc-text">2.向底部的2-结点插入新键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%A2%9C%E8%89%B2%E5%8F%8D%E8%BD%AC"><span class="toc-number">10.3.4.2.3.</span> <span class="toc-text">3.颜色反转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%90%91%E4%B8%80%E4%B8%AA%E5%8F%8C%E9%94%AE%E6%A0%91%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">10.3.4.2.4.</span> <span class="toc-text">4.向一个双键树中插入新键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%A0%B9%E7%BB%93%E7%82%B9%E7%9A%84%E9%A2%9C%E8%89%B2%E6%80%BB%E6%98%AF%E9%BB%91%E8%89%B2"><span class="toc-number">10.3.4.2.5.</span> <span class="toc-text">5.根结点的颜色总是黑色</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%90%91%E6%A0%91%E5%BA%95%E9%83%A8%E7%9A%843-%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">10.3.4.2.6.</span> <span class="toc-text">6.向树底部的3-结点插入新键</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-29"><span class="toc-number">10.3.4.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-number">10.4.</span> <span class="toc-text">B树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">10.4.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">10.4.2.</span> <span class="toc-text">存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">10.4.3.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98"><span class="toc-number">10.4.3.1.</span> <span class="toc-text">磁盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98IO"><span class="toc-number">10.4.3.2.</span> <span class="toc-text">磁盘IO</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%95%B0"><span class="toc-number">10.5.</span> <span class="toc-text">B+数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8-1"><span class="toc-number">10.5.1.</span> <span class="toc-text">存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">10.5.2.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E5%BB%BA%E7%AB%8B%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">10.5.2.1.</span> <span class="toc-text">未建立主键索引的查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">10.5.2.2.</span> <span class="toc-text">建立主键索引的查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">10.5.2.3.</span> <span class="toc-text">区间查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">10.6.</span> <span class="toc-text">B树和B+树的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">10.7.</span> <span class="toc-text">B*树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">10.8.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%BB%93%E6%9E%84"><span class="toc-number">10.8.1.</span> <span class="toc-text">并查集结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-30"><span class="toc-number">10.8.2.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">10.8.2.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%96%B9%E6%B3%95"><span class="toc-number">10.8.2.2.</span> <span class="toc-text">合并方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">10.8.2.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-2"><span class="toc-number">10.8.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YF-Tree%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">10.8.4.</span> <span class="toc-text">YF_Tree算法优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">10.8.4.1.</span> <span class="toc-text">查询方法优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">10.8.4.2.</span> <span class="toc-text">合并方法优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">10.8.4.3.</span> <span class="toc-text">优化后的性能分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96"><span class="toc-number">10.8.5.</span> <span class="toc-text">路径压缩优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-31"><span class="toc-number">10.8.5.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E2%80%94%E2%80%94%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B"><span class="toc-number">10.8.6.</span> <span class="toc-text">案例——畅通工程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1"><span class="toc-number">10.8.6.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">10.8.6.2.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-32"><span class="toc-number">10.8.6.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">11.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">11.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">11.2.</span> <span class="toc-text">表示方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">11.2.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">11.2.2.</span> <span class="toc-text">邻接表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">11.3.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-26"><span class="toc-number">11.3.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-33"><span class="toc-number">11.3.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">11.4.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">11.4.1.</span> <span class="toc-text">深度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-27"><span class="toc-number">11.4.1.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">11.4.1.2.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">11.4.1.3.</span> <span class="toc-text">核心代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">11.4.2.</span> <span class="toc-text">广度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-28"><span class="toc-number">11.4.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">11.4.2.2.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">11.4.2.3.</span> <span class="toc-text">核心代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB"><span class="toc-number">11.5.</span> <span class="toc-text">代码汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88"><span class="toc-number">11.5.1.</span> <span class="toc-text">深度优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88"><span class="toc-number">11.5.2.</span> <span class="toc-text">广度优先</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88"><span class="toc-number">11.6.</span> <span class="toc-text">深度优先和广度优先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-5"><span class="toc-number">11.6.1.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88-1"><span class="toc-number">11.6.2.</span> <span class="toc-text">深度优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88-1"><span class="toc-number">11.6.3.</span> <span class="toc-text">广度优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-34"><span class="toc-number">11.6.4.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">常用算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">二分查找（非递归）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-6"><span class="toc-number">12.1.1.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-2"><span class="toc-number">12.1.1.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-35"><span class="toc-number">12.1.1.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">分治算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-17"><span class="toc-number">12.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.2.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.2.3.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-7"><span class="toc-number">12.2.4.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-3"><span class="toc-number">12.2.4.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-29"><span class="toc-number">12.2.4.2.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-36"><span class="toc-number">12.2.4.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">12.3.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-8"><span class="toc-number">12.3.1.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-4"><span class="toc-number">12.3.1.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-30"><span class="toc-number">12.3.1.2.</span> <span class="toc-text">思路分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number">12.4.</span> <span class="toc-text">KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.4.1.</span> <span class="toc-text">暴力匹配算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-5"><span class="toc-number">12.4.1.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-31"><span class="toc-number">12.4.1.2.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-37"><span class="toc-number">12.4.1.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.4.2.</span> <span class="toc-text">KMP算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-6"><span class="toc-number">12.4.2.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-32"><span class="toc-number">12.4.2.2.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-38"><span class="toc-number">12.4.2.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">12.5.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-9"><span class="toc-number">12.5.1.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-7"><span class="toc-number">12.5.1.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-33"><span class="toc-number">12.5.1.2.</span> <span class="toc-text">思路分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%B7%E4%B8%BE%E6%B3%95"><span class="toc-number">12.5.1.2.1.</span> <span class="toc-text">穷举法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-1"><span class="toc-number">12.5.1.2.2.</span> <span class="toc-text">贪心算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-39"><span class="toc-number">12.5.1.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">12.5.1.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95"><span class="toc-number">12.6.</span> <span class="toc-text">普里姆算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-8"><span class="toc-number">12.6.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-34"><span class="toc-number">12.6.2.</span> <span class="toc-text">思路分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">12.6.2.1.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3"><span class="toc-number">12.6.2.2.</span> <span class="toc-text">图解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-40"><span class="toc-number">12.6.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="toc-number">12.7.</span> <span class="toc-text">克鲁斯卡尔算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-9"><span class="toc-number">12.7.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-35"><span class="toc-number">12.7.2.</span> <span class="toc-text">思路分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3-1"><span class="toc-number">12.7.2.1.</span> <span class="toc-text">图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E6%8F%8F%E8%BF%B0"><span class="toc-number">12.7.2.2.</span> <span class="toc-text">文字描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">12.7.2.3.</span> <span class="toc-text">算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%90%88%E5%88%A4%E6%96%AD%E6%80%9D%E8%B7%AF"><span class="toc-number">12.7.2.3.1.</span> <span class="toc-text">重合判断思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-41"><span class="toc-number">12.7.3.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-1"><span class="toc-number">12.7.3.1.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="toc-number">12.8.</span> <span class="toc-text">迪杰斯特拉算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-number">12.8.1.</span> <span class="toc-text">算法过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-10"><span class="toc-number">12.8.2.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-36"><span class="toc-number">12.8.3.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-42"><span class="toc-number">12.8.4.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-3"><span class="toc-number">12.8.4.1.</span> <span class="toc-text">完整代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">12.8.4.2.</span> <span class="toc-text">部分代码解释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9B%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95"><span class="toc-number">12.9.</span> <span class="toc-text">佛洛伊德算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-18"><span class="toc-number">12.9.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-11"><span class="toc-number">12.9.2.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="toc-number">12.9.3.</span> <span class="toc-text">算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-43"><span class="toc-number">12.9.4.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/25/JPA%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" title="JPA的命名规范"><img src="/img/cover9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JPA的命名规范"/></a><div class="content"><a class="title" href="/2023/03/25/JPA%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" title="JPA的命名规范">JPA的命名规范</a><time datetime="2023-03-24T16:00:00.000Z" title="发表于 2023-03-25 00:00:00">2023-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/Stream%E6%B5%81%E6%97%A0%E6%B3%95%E7%BB%99%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC/" title="Stream流无法赋值给外部属性"><img src="/img/cover1.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Stream流无法赋值给外部属性"/></a><div class="content"><a class="title" href="/2023/03/22/Stream%E6%B5%81%E6%97%A0%E6%B3%95%E7%BB%99%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC/" title="Stream流无法赋值给外部属性">Stream流无法赋值给外部属性</a><time datetime="2023-03-21T16:00:00.000Z" title="发表于 2023-03-22 00:00:00">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/Dubbo%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Dubbo源码——消费者"><img src="/img/cover6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dubbo源码——消费者"/></a><div class="content"><a class="title" href="/2023/03/20/Dubbo%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Dubbo源码——消费者">Dubbo源码——消费者</a><time datetime="2023-03-19T16:00:00.000Z" title="发表于 2023-03-20 00:00:00">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/13/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%BB%A3%E7%A0%81%E8%A7%84%E7%BA%A6(%E4%B8%80)/" title="阿里巴巴代码规范（一）"><img src="/img/cover2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里巴巴代码规范（一）"/></a><div class="content"><a class="title" href="/2023/03/13/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%BB%A3%E7%A0%81%E8%A7%84%E7%BA%A6(%E4%B8%80)/" title="阿里巴巴代码规范（一）">阿里巴巴代码规范（一）</a><time datetime="2023-03-12T16:00:00.000Z" title="发表于 2023-03-13 00:00:00">2023-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/13/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%BB%A3%E7%A0%81%E8%A7%84%E7%BA%A6(%E4%BA%8C)/" title="阿里巴巴代码规范（二）"><img src="/img/cover5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里巴巴代码规范（二）"/></a><div class="content"><a class="title" href="/2023/03/13/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%BB%A3%E7%A0%81%E8%A7%84%E7%BA%A6(%E4%BA%8C)/" title="阿里巴巴代码规范（二）">阿里巴巴代码规范（二）</a><time datetime="2023-03-12T16:00:00.000Z" title="发表于 2023-03-13 00:00:00">2023-03-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/cover5.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xue_Water</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://water001-maker.github.io/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/'
    this.page.identifier = '/2023/02/18/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/'
    this.page.title = '算法与数据结构'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="JVM,JDK,JRE,Mysql,Redis,Spring,MQ,ES,Oracle,Jva" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>