<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Lambda&amp;Stream | 幻想家的秘密基地</title><meta name="author" content="Xue_Water"><meta name="copyright" content="Xue_Water"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lambda表达式Java8新引入的新特性 Lambda表达式。Lambda表达式是一种用于取代匿名类，把函数行为表述为函数式编程风格的一种匿名函数。Lambda表达式的执行结果是函数式接口的一个匿名对象。 是一套关于函数（f(x)）定义、输入量、输出量的计算方案 语法格式概述(parameters) -&gt; &amp;#123; statements; &amp;#125;&#x2F;&#x2F;实例(int a, int b">
<meta property="og:type" content="article">
<meta property="og:title" content="Lambda&amp;Stream">
<meta property="og:url" content="https://water001-maker.github.io/2023/02/26/Lambda&Stream/index.html">
<meta property="og:site_name" content="幻想家的秘密基地">
<meta property="og:description" content="Lambda表达式Java8新引入的新特性 Lambda表达式。Lambda表达式是一种用于取代匿名类，把函数行为表述为函数式编程风格的一种匿名函数。Lambda表达式的执行结果是函数式接口的一个匿名对象。 是一套关于函数（f(x)）定义、输入量、输出量的计算方案 语法格式概述(parameters) -&gt; &amp;#123; statements; &amp;#125;&#x2F;&#x2F;实例(int a, int b">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://water001-maker.github.io/img/cover12.jpg">
<meta property="article:published_time" content="2023-02-25T16:00:00.000Z">
<meta property="article:modified_time" content="2023-02-26T15:31:58.893Z">
<meta property="article:author" content="Xue_Water">
<meta property="article:tag" content="Stream">
<meta property="article:tag" content="Lambda">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://water001-maker.github.io/img/cover12.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://water001-maker.github.io/2023/02/26/Lambda&amp;Stream/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lambda&Stream',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-26 23:31:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover12.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="幻想家的秘密基地"><span class="site-name">幻想家的秘密基地</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Lambda&amp;Stream</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-25T16:00:00.000Z" title="发表于 2023-02-26 00:00:00">2023-02-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-26T15:31:58.893Z" title="更新于 2023-02-26 23:31:58">2023-02-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Lambda&amp;Stream"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Java8新引入的新特性 Lambda表达式。Lambda表达式是一种用于取代匿名类，把函数行为表述为函数式编程风格的一种匿名函数。<strong>Lambda表达式的执行结果是函数式接口的一个匿名对象</strong>。</p>
<p>是一套关于函数（f(x)）定义、输入量、输出量的计算方案</p>
<h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br><span class="line">//实例</span><br><span class="line">(int a, int b) -&gt; &#123;return a + b;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>parameters	：函数的参数列表</p>
<p>statements;	：执行语句</p>
<p>-&gt;		：使用指定参数去完成某个功能</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">//实例</span><br><span class="line">(int a, int b) -&gt; a + b</span><br></pre></td></tr></table></figure>

<blockquote>
<p>parameters	：函数的参数列表</p>
<p>expression	：表达式</p>
<p>-&gt;		：使用指定参数去完成某个功能</p>
</blockquote>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>可选的大括号{}</p>
<p>函数体只包含一个语句，不需要大括号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.函数体只有一个语句，省略大括号</span><br><span class="line">(String msg) -&gt; System.out.println(&quot;hello&quot;+ msg);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可选的参数圆括号()</p>
<p>只有一个参数，省略圆括号，同时省略类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 2.只有一个参数，省略圆括号，同时省略类型</span><br><span class="line">msg -&gt; System.out.println(&quot;hello “ + msg);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可选的返回关键字return</p>
<p>函数体只有一个表达式，且运算结果匹配返回类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 3.函数体只有一个表达式，省略return</span><br><span class="line">(int a, int b) -&gt; a + b</span><br></pre></td></tr></table></figure>
</li>
<li><p>可选的类型声明</p>
<p>不需要参数类型，编译器可以根据参数值进行推断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 4. 省略参数类型，编译器可以进行推断</span><br><span class="line">(a, b) -&gt; a + b</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常见的函数式接口"><a href="#常见的函数式接口" class="headerlink" title="常见的函数式接口"></a>常见的函数式接口</h2><p>函数式接口必须有一个前提，有且只有一个抽象方法的接口，并且有@FunctionnalInterface注解</p>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMathOperation</span> &#123;    <span class="type">int</span> <span class="title function_">operation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGreeting</span> &#123;    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String message)</span>;&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;    T <span class="title function_">get</span><span class="params">()</span>;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Runnable-x2F-Callable"><a href="#Runnable-x2F-Callable" class="headerlink" title="Runnable &#x2F; Callable"></a>Runnable &#x2F; Callable</h3><p><strong>创建线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类的方式,实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">&quot; 线程已启动&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式,实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name + <span class="string">&quot; 线程已启动&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化省略Lambda</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程已启动&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Supplier-x2F-Consumer"><a href="#Supplier-x2F-Consumer" class="headerlink" title="Supplier &#x2F; Consumer"></a>Supplier &#x2F; Consumer</h3><p><strong>Supplier（消费者）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SupplierLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">52</span>, <span class="number">333</span>, <span class="number">23</span>&#125;;</span><br><span class="line">        <span class="comment">// 调用getMax方法，参数传递Lambda</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> getMax(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 查找数组的最大值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; max) &#123;</span><br><span class="line">                    max = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(maxNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定一个方法方法的参数传递Supplier泛型使用Integer</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Consumer（消费者）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        consumerString(s -&gt; System.out.println(s));</span></span><br><span class="line">        consumerString(</span><br><span class="line">                s -&gt; System.out.println(s.toLowerCase()),</span><br><span class="line">                s -&gt; System.out.println(s.toUpperCase())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumerString</span><span class="params">(Consumer&lt;String&gt; function)</span> &#123;</span><br><span class="line">        function.accept(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumerString</span><span class="params">(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two)</span> &#123;</span><br><span class="line">        one.andThen(two).accept(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p><strong>比较器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparatorLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;dedeyidede&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;de&quot;</span>, <span class="string">&quot;fghi&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 使用匿名内部类的方式，实现比较器</span></span><br><span class="line">        Comparator&lt;String&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.length() - o2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//        Arrays.sort(strs, comparator);</span></span><br><span class="line">        <span class="comment">// TODO 使用Lambda表达式实现</span></span><br><span class="line">        Arrays.sort(strs, (s1, s2) -&gt; s1.length() - s2.length());</span><br><span class="line">        System.out.println(Arrays.toString(strs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p><strong>判断逻辑关系</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateLambda</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        andMethod(s -&gt; s.contains(<span class="string">&quot;H&quot;</span>), s -&gt; s.contains(<span class="string">&quot;W&quot;</span>));</span><br><span class="line">        orMethod(s -&gt; s.contains(<span class="string">&quot;H&quot;</span>), s -&gt; s.contains(<span class="string">&quot;w&quot;</span>));</span><br><span class="line">        negateMethod(s -&gt; s.length() &lt; <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">andMethod</span><span class="params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> one.and(two).test(<span class="string">&quot;Helloworld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串符合要求吗：&quot;</span> + isValid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">orMethod</span><span class="params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> one.or(two).test(<span class="string">&quot;Helloworld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串符合要求吗：&quot;</span> + isValid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">negateMethod</span><span class="params">(Predicate&lt;String&gt; predicate)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">veryLong</span> <span class="operator">=</span> predicate.negate().test(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串很长吗：&quot;</span> + veryLong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><strong>方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(str -&gt; Integer.parseInt(str) + <span class="number">10</span>, i -&gt; i *= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;张三,3&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> getAgeNum(str, s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>],</span><br><span class="line">                s -&gt; Integer.parseInt(s),</span><br><span class="line">                n -&gt; n += <span class="number">100</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String输入的类型，Integer输出的类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> one.andThen(two).apply(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        System.out.println(num + <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getAgeNum</span><span class="params">(String str, Function&lt;String, String&gt; one,</span></span><br><span class="line"><span class="params">                         Function&lt;String, Integer&gt; two,</span></span><br><span class="line"><span class="params">                         Function&lt;Integer, Integer&gt; three)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> one.andThen(two).andThen(three).apply(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda的底层实现"><a href="#Lambda的底层实现" class="headerlink" title="Lambda的底层实现"></a>Lambda的底层实现</h2><p>&#x3D;&#x3D;<strong>其本质就是匿名子类的匿名对象</strong>&#x3D;&#x3D;</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>需求：遍历List集合</p>
<h4 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; strList = Arrays.asList(<span class="string">&quot;L&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        strList.forEach(s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h4><p>那么，我们可以使用匿名内部类的形式来实现上述lambda表达式的功能，以下代码的功能一致的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; strList = Arrays.asList(<span class="string">&quot;L&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="comment">//通过匿名内部类来代替lambda表达式</span></span><br><span class="line">        strList.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例代码分析"><a href="#示例代码分析" class="headerlink" title="示例代码分析"></a>示例代码分析</h3><p><code>forEach()</code>是<code>Iterable</code>接口的一个默认方法，它需要一个<code>Consumer</code>类型的参数，方法体中是一个for循环，对迭代器的每一个对象进行遍历，处理方法就是调用参数对象的<code>accept()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续查看<code>Consumer</code>的<code>accept(T)</code>方法，可以看到<code>Consumer</code>是一个函数式接口（只有一个抽象方法的接口，java8中称之为函数式接口），只有一个抽象方法<code>accept(T)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对照一下示例代码：</p>
<p><code>strList.forEach(s -&gt; &#123;System.out.println(s);&#125;);</code></p>
<p>可以大胆的猜测，Lambda表达式</p>
<p><code>s -&gt; &#123;System.out.println(s);&#125;</code>相当于是实现了<code>Consumer</code>接口的一个匿名（内部类）对象，</p>
<p>而大括号里面的内容：<code>System.out.println(s);</code>相当于重写了<code>accept()</code>的方法体。</p>
<h3 id="反编译lambda表达式代码"><a href="#反编译lambda表达式代码" class="headerlink" title="反编译lambda表达式代码"></a>反编译lambda表达式代码</h3><blockquote>
<p>对包含lambda表达式的class文件进行反编译时需要注意：</p>
<p>jad系列的反编译工具不支持jdk1.8，所以这里使用CFR进行反编译。</p>
<p><a target="_blank" rel="noopener" href="http://www.benf.org/other/cfr/">cfr下载地址</a>:<a target="_blank" rel="noopener" href="http://www.benf.org/other/cfr/">http://www.benf.org/other/cfr/</a></p>
<p>语法：<code>java -jar cfr-0.145.jar LambdaTest.class --decodelambdas false</code></p>
</blockquote>
<p>反编译后可以得到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.LambdaMetafactory;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; strList = Arrays.asList(<span class="string">&quot;L&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(</span><br><span class="line">            <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, </span><br><span class="line">            (Ljava/lang/Object;)V, </span><br><span class="line">            lambda$main$<span class="number">0</span>(java.lang.String ),</span><br><span class="line">            (Ljava/lang/String;)V)());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译结果可以看出，lambda表达式就是一个对象实例，使用什么函数式接口接收的，就是什么对象实例，例如上面的Consumer。</p>
<p>在<code>forEach()</code>方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory()</code>方法，该方法的第5个参数<code>implMethod</code>指定了方法实现。可以看到这里其实是调用<code>lambda$main$0()</code>方法进行输出。跟踪<code>metafactory()</code>方法（参数较多，可以跳过）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//lambda的原工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title function_">metafactory</span><span class="params">(</span></span><br><span class="line"><span class="params">       // 调用者（LambdaTest）可访问权限的上下文对象，JVM自动填充</span></span><br><span class="line"><span class="params">       MethodHandles.Lookup caller, </span></span><br><span class="line"><span class="params">       // 要执行的方法名，即Consumer.accept()</span>，JVM自动填充</span><br><span class="line">       String invokedName,</span><br><span class="line">       <span class="comment">// 调用点预期的签名（包含目标方法参数类型String和Lambda返回类型Consumer），JVM自动填充</span></span><br><span class="line">       MethodType invokedType,</span><br><span class="line">       <span class="comment">// 函数式接口抽象方法的签名， (Object)void，泛型String被擦出，所以是Object</span></span><br><span class="line">       MethodType samMethodType,</span><br><span class="line">       <span class="comment">// 直接方法句柄，真正被调用的方法，即lambda$main$0，签名为MethodHandle(String)void</span></span><br><span class="line">       MethodHandle implMethod,</span><br><span class="line">       <span class="comment">// 实例化的方法签名，即调用时动态执行的方法签名，</span></span><br><span class="line">       <span class="comment">// 可能与samMethodType相同，也可能包含了泛型的具体类型，比如(String)void</span></span><br><span class="line">       MethodType instantiatedMethodType) <span class="keyword">throws</span> LambdaConversionException &#123;</span><br><span class="line">       </span><br><span class="line">       AbstractValidatingLambdaMetafactory mf;</span><br><span class="line">       mf = <span class="keyword">new</span> <span class="title class_">InnerClassLambdaMetafactory</span>(caller, invokedType,</span><br><span class="line">                                            invokedName, samMethodType,</span><br><span class="line">                                            implMethod, instantiatedMethodType,</span><br><span class="line">                                            <span class="literal">false</span>, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);</span><br><span class="line">       mf.validateMetafactoryArgs();</span><br><span class="line">       <span class="keyword">return</span> mf.buildCallSite();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>new InnerClassLambdaMetafactory</code>看起来是创建了一个Lambda相关的<strong>内部类</strong>，继续跟踪下去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InnerClassLambdaMetafactory</span><span class="params">(...)</span></span><br><span class="line">            <span class="keyword">throws</span> LambdaConversionException &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">        lambdaClassName = targetClass.getName().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;$$Lambda$&quot;</span> + counter.incrementAndGet();</span><br><span class="line">        cw = <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">       <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（省略了一部分代码。）</p>
<p>一看到<code>lambdaClassName</code>这样的变量名就知道它代表的什么意思——Lambda表达式对应的类名，而<code>ClassWriter</code>对象<code>cw</code>，暴露了Lambda表达式的底层实现机制：ASM技术（Assembly，<a target="_blank" rel="noopener" href="https://asm.ow2.io/">Java字节码操作和分析框架</a>，用于在程序运行时动态生成和操作字节码文件）。在这个构造方法里，初始化了大量的ASM技术需要的成员变量，为后续生成字节码的相关操作完成了一系列的初始化动作。现在大致可以猜测：<strong>Lambda表达式底层是通过一个内部类来实现的，这个类由ASM技术在程序运行时动态生成，它实现了函数式接口（例如Consumer等），并重写了对应的抽象方法（如accept）。</strong></p>
<h3 id="验证猜想"><a href="#验证猜想" class="headerlink" title="验证猜想"></a>验证猜想</h3><p>回到<code>metafactory()</code>方法中，跟踪方法结尾的返回语句<code>mf.buildCallSite();</code>——创建调用点，这才是重点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Build the CallSite. Generate a class file which implements the functional</span></span><br><span class="line"><span class="comment">    * interface, define the class, if ...</span></span><br><span class="line"><span class="comment">    * 创建调用点。定义一个实现了函数式接口的类并生成它的类文件，</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a CallSite, which, when invoked, will return an instance of the</span></span><br><span class="line"><span class="comment">    * functional interface</span></span><br><span class="line"><span class="comment">    * 返回一个调用点，当它执行的时候，将会返回一个函数式接口（Consumer）的实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   CallSite <span class="title function_">buildCallSite</span><span class="params">()</span> <span class="keyword">throws</span> LambdaConversionException &#123;</span><br><span class="line">       <span class="keyword">final</span> Class&lt;?&gt; innerClass = spinInnerClass();</span><br><span class="line">       <span class="comment">// 省略部分代码...</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="type">Object</span> <span class="variable">inst</span> <span class="operator">=</span> ctrs[<span class="number">0</span>].newInstance();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstantCallSite</span>(MethodHandles.constant(samBase, inst));</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方法的注释非常清晰的告诉我们，这个方法在<strong>运行期</strong>会返回一个函数式接口的实例，也就是<code>Consumer</code>接口的匿名对象。 </p>
<p>方法体的第一行<code>spinInnerClass()</code>，就使用ASM技术生成了一个Class文件，然后使用<code>sun.misc.Unsafe</code>将该类加载到JVM（创建并返回该类的Class对象）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> ClassWriter cw;                    <span class="comment">// ASM class writer</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Generate a class file which implements the functional</span></span><br><span class="line"><span class="comment">    * interface, define and return the class.</span></span><br><span class="line"><span class="comment">    * 生成一个实现函数式接口的类文件，定义并返回该类的Class实例</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a Class which implements the functional interface</span></span><br><span class="line"><span class="comment">    * 返回一个实现函数式接口的Class实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Class&lt;?&gt; spinInnerClass() <span class="keyword">throws</span> LambdaConversionException &#123;</span><br><span class="line">       <span class="comment">// ....</span></span><br><span class="line">       <span class="comment">// ClassWriter通过visit方法动态构造类的字节码</span></span><br><span class="line">       cw.visit(, , lambdaClassName, <span class="literal">null</span>, , interfaces); <span class="comment">// 生成接口字节码</span></span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">       <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">           cw.visitField( , , , <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// 生成域的字节码</span></span><br><span class="line">       &#125;</span><br><span class="line">       generateConstructor(); <span class="comment">// 生成构造器字节码</span></span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">       cw.visitMethod( ,  , , <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// 生成普通方法字节码</span></span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">       cw.visitEnd(); <span class="comment">// end</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// Define the generated class in this VM.</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="type">byte</span>[] classBytes = cw.toByteArray();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// If requested, dump out to a file for debugging purposes</span></span><br><span class="line">       <span class="keyword">if</span> (dumper != <span class="literal">null</span>) &#123; <span class="comment">// 转储对象</span></span><br><span class="line">           AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                   dumper.dumpClass(lambdaClassName, classBytes);</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, <span class="literal">null</span>,</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">FilePermission</span>(<span class="string">&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;</span>, <span class="string">&quot;read, write&quot;</span>),</span><br><span class="line">           <span class="comment">// createDirectories may need it</span></span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">PropertyPermission</span>(<span class="string">&quot;user.dir&quot;</span>, <span class="string">&quot;read&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 使用Unsafe对象定义并返回该内部类字节码文件对象（Class）</span></span><br><span class="line">       <span class="keyword">return</span> UNSAFE.defineAnonymousClass(targetClass, classBytes, <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的后半部分，<code>if (dumper != null)</code> 代码块给我们提供了将该内部类转储到本地磁盘用以调试的可能，在<code>LambdaTest</code>的<code>main</code>方法里里添加一行代码，将Lambda表达式对应的内部类转储到指定目录（IDEA）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;jdk.internal.lambda.dumpProxyClasses&quot;</span>, <span class="string">&quot;out/production/&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>程序运行之后</strong>，会将Lambda表达式对应的内部类文件生成出来<code>com.boxuegu.intermediate.language.sugar.lambda.LambdaTest$$Lambda$1</code>：</p>
<p>反编译这个类，代码如下：</p>
<p>可以理解为lambda表达式最终的结果就是生成了以下代码，一个实现了函数式接口的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.LambdaForm;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LambdaTest$$Lambda$1</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span> &#123; <span class="comment">// 实现函数式接口</span></span><br><span class="line">    <span class="keyword">private</span> LambdaTest$$Lambda$<span class="number">1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LambdaForm</span>.Hidden</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object object)</span> &#123; <span class="comment">// 重写抽象方法</span></span><br><span class="line">        LambdaTest.lambda$main$<span class="number">0</span>((String)object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们初步得到了一些结论：</p>
<blockquote>
<ol>
<li>Lambda表达式底层是用内部类来实现的 </li>
<li>该内部类实现了<strong>某个（根据Lambda所属的代码指定）</strong>函数式接口，并重写了该接口的抽象方法</li>
<li>该内部类是在程序运行时使用ASM技术动态生成的，所以编译期没有对应的.class文件，但是我们可以通过设置系统属性将该内部类文件转储出来</li>
</ol>
</blockquote>
<h3 id="Lambda表达式编译和运行过程"><a href="#Lambda表达式编译和运行过程" class="headerlink" title="Lambda表达式编译和运行过程"></a>Lambda表达式编译和运行过程</h3><p>至此，我们只窥视了Lambda表达式底层实现的冰山一角。接下来会有一堆概念和过程！</p>
<p><img src="/2023/02/26/Lambda&Stream/image-20230226174745303.png" alt="image-20230226174745303"></p>
<ol>
<li>Java7在<a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=292">JSR（Java Specification Requests，Java 规范提案） 292</a>中增加了对动态类型语言的支持，使得Java也可以像<em>C语言</em>那样将方法作为参数传递，其实现在<code>java.lang.invoke</code>包中。它的核心就是<code>invokedynamic</code>指令，为后面<strong>函数式编程</strong>和<strong>响应式编程</strong>提供了前置支持。</li>
<li><code>invokedynamic</code>指令对应的执行方法会关联到一个<em>动态</em>调用点对象（<code>java.lang.invoke.CallSite</code>），一个调用点（call site）是一个方法句柄（method handle，调用点的目标）的持有者，这个调用点对象会指向一个具体的引导方法（bootstrap method，比如<code>metafactory()</code>），引导方法成功调用之后，调用点的目标将会与它持有的方法句柄的引用永久绑定，最终得到一个实现了函数式接口（比如Consumer）的对象。</li>
<li>Lambda表达式在编译期进行脱糖（desugar），它的主体部分会被转换成一个脱糖方法（desugared method，即<code>lambda$main$0</code>），这是一个合成方法，如果Lambda没有用到外部变量，则是一个私有的静态方法，否则将是个私有的实例方法——synthetic 表示不在源码中显示，并在Lambda所属的方法（比如main方法）中生成<code>invokedynamic</code>指令。</li>
<li><strong>进入运行期</strong>，<code>invokedynamic</code>指令会调用引导方法<code>metafactory()</code>初始化ASM生成内部类所需的各项属性，然后由<code>spinInnerClass()</code>方法组装内部类并用Unsafe加载到JVM，通过构造方法实例化内部类的实例（Lambda的实现内部类的构造是私有的，需要手动设置可访问属性为true），最后绑定到方法句柄，完成调用点的创建。</li>
<li>你可以把调用点看成是函数式接口（例如Consumer等）的匿名对象，当然，内部类是确实存在的——比如<code>final class LambdaTest$$Lambda$1 implements Consumer</code>。值得注意的是，内部类的实现方法里并没有Lambda表达式的任何操作，它不过是调用了脱糖后定义在调用点目标类（<code>targetClass</code>，即<code>LambdaTest</code>类）中的合成方法（即<code>lambda$main$0</code>）而已，这样做使得内部类的代码量尽可能的减少，降低内存占用，对效率的提升更加稳定和可控。</li>
</ol>
<h3 id="Lambda表达式的语法糖结论"><a href="#Lambda表达式的语法糖结论" class="headerlink" title="Lambda表达式的语法糖结论"></a>Lambda表达式的语法糖结论</h3><p>Lambda表达式在编译期脱去糖衣语法，生成了一个“合成方法”，在运行期，<code>invokedynamic</code>指令通过引导方法创建调用点，过程中生成一个实现了函数式接口的内部类并返回它的对象，最终通过调用点所持有的方法句柄完成对合成方法的调用，实现具体的功能。</p>
<p><strong>Lambda表达式是一个语法糖，但远远不止是一个语法糖。</strong></p>
<p>Lambda表达式并不是JVM原生的语法，底层是通过一个内部类来实现的，这个类由ASM技术在程序运行时动态生成，它实现了函数式接口（例如Consumer等），并重写了对应的抽象方法（如accept）。</p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？</p>
<h2 id="冗余的Lambda场景"><a href="#冗余的Lambda场景" class="headerlink" title="冗余的Lambda场景"></a>冗余的Lambda场景</h2><p>来看一个简单的函数式接口以应用Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span>&#123;</span><br><span class="line">    voidprint(Stringstr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Printable</code>接口当中唯一的抽象方法<code>print</code>接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01PrintSimple</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable data)</span> &#123;</span><br><span class="line">    	data.print(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	printString(s ‐&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>printString</code> 方法只管调用 <code>Printable</code> 接口的 <code>print</code> 方法，而并不管 print 方法的具体实现逻辑会将字符串打印到什么地方去。而 <code>main</code> 方法通过Lambda表达式指定了函数式接口 <code>Printable</code> 的具体操作方案为：<strong>拿到</strong><code>String</code>（类型可推导，所以可省略）数据后，在控制台中输出它。 </p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 <code>System.out</code>对象中的 <code>println(String)</code> 方法。既然Lambda希望做的事情就是调用 <code>println(String)</code> 方法，那何必自己手动调用呢？</p>
<h3 id="用方法引用改进代码"><a href="#用方法引用改进代码" class="headerlink" title="用方法引用改进代码"></a>用方法引用改进代码</h3><p>能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02PrintRef</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable data)</span> &#123;</span><br><span class="line">    	data.print(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	printString(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意其中的<code>双冒号 ::</code> 写法，这被称为“方法引用”，而双冒号是一种新的语法。</p>
<p>当Lambda表达式所要完成的业务逻辑已经存在（已经有函数实现了），就直接引用该方法即可。</p>
<h2 id="方法引用符"><a href="#方法引用符" class="headerlink" title="方法引用符"></a>方法引用符</h2><p>双冒号 <code>::</code> 为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>例如上例中， <code>System.out</code> 对象中有一个重载的 <code>println(String)</code> 方法恰好就是我们所需要的。那么对于<code>printString</code> 方法的函数式接口参数，对比下面两种写法，完全等效：</p>
<ul>
<li>Lambda表达式写法： <code>s -&gt; System.out.println(s);</code></li>
<li>方法引用写法： <code>System.out::println</code></li>
</ul>
<p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给 <code>System.out.println</code> 方法去处理。</p>
<p>第二种等效写法的语义是指：直接让 <code>System.out</code> 中的 <code>println</code> 方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。</p>
<blockquote>
<p>注:Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p>
</blockquote>
<h3 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a>推导与省略</h3><p>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。</p>
<p>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。</p>
<p>下面这段代码将会调用 <code>println</code> 方法的不同重载形式，将函数式接口改为int类型的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PrintableInteger</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03PrintOverload</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInteger</span><span class="params">(PrintableInteger data)</span> &#123;</span><br><span class="line">    	data.print(<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	printInteger(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次方法引用将会自动匹配到 <code>println(int)</code> 的重载形式。</p>
<h2 id="方法引用的底层实现"><a href="#方法引用的底层实现" class="headerlink" title="方法引用的底层实现"></a>方法引用的底层实现</h2><p><strong>反编译以下代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	printString(s -&gt; &#123;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;);</span><br><span class="line">	printString(System.out::println);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable p)</span> &#123;</span><br><span class="line">	p.print(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lambda表达式的编译结果：</strong></p>
<p>生成一个方法，将函数体放到该方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Demo01Printable.printString((Printable)LambdaMetafactory</span><br><span class="line">	.metafactory(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line">                 (Ljava/lang/String;)V,</span><br><span class="line">                 lambda$main$<span class="number">0</span>(java.lang.String ),</span><br><span class="line">                 (Ljava/lang/String;)V)());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>(String s)</span><br><span class="line">	p.print(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lambda方法引用的编译结果：</strong></p>
<p>原本的<code>lambda$main$</code>被替换为了println函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">printStream</span> <span class="operator">=</span> System.out;</span><br><span class="line">    Objects.requireNonNull(printStream);</span><br><span class="line">    Demo01Printable.printString((Printable)LambdaMetafactory</span><br><span class="line">	.metafactory(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line">                 (Ljava/lang/String;)V,</span><br><span class="line">                 println(java.lang.String ),</span><br><span class="line">                 (Ljava/lang/String;)V)((PrintStream)printStream));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法实体：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法引用基于Lambda实现，二者本质相同，都是使用匿名内部类。</p>
<h2 id="方法引用语法格式"><a href="#方法引用语法格式" class="headerlink" title="方法引用语法格式"></a>方法引用语法格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">双冒号  ::</span><br></pre></td></tr></table></figure>

<p>所有的方法都可以被引用，除了抽象方法，因为抽象方法没有方法体。</p>
<table>
<thead>
<tr>
<th></th>
<th>格式</th>
<th>范例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>类方法</strong></td>
<td>类名 :: 静态方法</td>
<td>Integer :: parseInt</td>
</tr>
<tr>
<td><strong>构造方法</strong></td>
<td>类名 :: new</td>
<td>Student :: new</td>
</tr>
<tr>
<td><strong>实例方法</strong></td>
<td>对象 :: 成员方法</td>
<td></td>
</tr>
</tbody></table>
<h3 id="通过对象名引用成员方法"><a href="#通过对象名引用成员方法" class="headerlink" title="通过对象名引用成员方法"></a>通过对象名引用成员方法</h3><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodRefObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printUpperCase</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    	System.out.println(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式接口仍然定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当需要使用这个 <code>printUpperCase</code> 成员方法来替代 <code>Printable</code> 接口的Lambda的时候，已经具有了<br><code>MethodRefObject</code> 类的对象实例，则可以通过对象名引用成员方法，代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04MethodRef</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable lambda)</span> &#123;</span><br><span class="line">    	lambda.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MethodRefObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodRefObject</span>();</span><br><span class="line">        printString(obj::printUpperCase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过类名称引用静态方法"><a href="#通过类名称引用静态方法" class="headerlink" title="通过类名称引用静态方法"></a>通过类名称引用静态方法</h3><p>由于在 <code>java.lang.Math</code> 类中已经存在了静态方法 <code>abs</code> ，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calcable</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>第一种写法是使用Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05Lambda</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> num, Calcable lambda)</span> &#123;</span><br><span class="line">    	System.out.println(lambda.calc(num));</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	method(‐<span class="number">10</span>, n ‐&gt; Math.abs(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是使用方法引用的更好写法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06MethodRef</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> num, Calcable lambda)</span> &#123;</span><br><span class="line">    	System.out.println(lambda.calc(num));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	method(‐<span class="number">10</span>, Math::abs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： <code>n -&gt; Math.abs(n)</code></li>
<li>方法引用： <code>Math::abs</code></li>
</ul>
<h3 id="通过super引用成员方法"><a href="#通过super引用成员方法" class="headerlink" title="通过super引用成员方法"></a>通过super引用成员方法</h3><p>如果存在继承关系，当Lambda中需要出现<code>super</code>调用时，也可以使用方法引用进行替代。首先是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Greetable</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后是父类 Human 的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是子类 <code>Man</code> 的内容，其中使用了Lambda的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;大家好,我是Man!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 定义方法method,参数传递Greetable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Greetable g)</span>&#123;</span><br><span class="line">    	g.greet();</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 调用method方法,使用Lambda表达式</span></span><br><span class="line">        method(()‐&gt;&#123;</span><br><span class="line">        <span class="comment">// 创建Human对象,调用sayHello方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Human</span>().sayHello();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 简化Lambda</span></span><br><span class="line">        method(()‐&gt;<span class="keyword">new</span> <span class="title class_">Human</span>().sayHello());</span><br><span class="line">        <span class="comment">// 使用super关键字代替父类对象</span></span><br><span class="line">        method(()‐&gt;<span class="built_in">super</span>.sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>但是如果使用方法引用来调用父类中的 <code>sayHello</code> 方法会更好，例如另一个子类 <code>Woman</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;大家好,我是Man!&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义方法method,参数传递Greetable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Greetable g)</span>&#123;</span><br><span class="line">    	g.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    	method(<span class="built_in">super</span>::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： <code>() -&gt; super.sayHello()</code></li>
<li>方法引用： <code>super::sayHello</code></li>
</ul>
<h3 id="通过this引用成员方法"><a href="#通过this引用成员方法" class="headerlink" title="通过this引用成员方法"></a>通过this引用成员方法</h3><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用 <code>this::成员方法</code> 的格式来使用方法引用。首先是简单的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Richable</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>下面是一个丈夫 Husband 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123;</span><br><span class="line">        lambda.buy();</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123;</span><br><span class="line">        marry(() ‐&gt; System.out.println(<span class="string">&quot;买套房子&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>开心方法 <code>beHappy</code> 调用了结婚方法 <code>marry</code> ，后者的参数为函数式接口 <code>Richable</code> ，所以需要一个Lambda表达式。但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 <code>Husband</code> 丈夫类进行修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;买套房子&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123;</span><br><span class="line">    	lambda.buy();</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123;</span><br><span class="line">    	marry(() ‐&gt; <span class="built_in">this</span>.buyHouse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;买套房子&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123;</span><br><span class="line">    	lambda.buy();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123;</span><br><span class="line">    	marry(<span class="built_in">this</span>::buyHouse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： <code>() -&gt; this.buyHouse()</code></li>
<li>方法引用： <code>this::buyHouse</code></li>
</ul>
<h3 id="类的构造器引用"><a href="#类的构造器引用" class="headerlink" title="类的构造器引用"></a>类的构造器引用</h3><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 <code>类名称::new</code> 的格式表示。首先是一个简单<br>的 <code>Person</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后是用来创建 <code>Person</code> 对象的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonBuilder</span> &#123;</span><br><span class="line">	Person <span class="title function_">buildPerson</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用这个函数式接口，可以通过Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09Lambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(String name, PersonBuilder builder)</span> &#123;</span><br><span class="line">    	System.out.println(builder.buildPerson(name).getName());</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	printName(<span class="string">&quot;赵丽颖&quot;</span>, name ‐&gt; <span class="keyword">new</span> <span class="title class_">Person</span>(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p>但是通过构造器引用，有更好的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10ConstructorRef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(String name, PersonBuilder builder)</span> &#123;</span><br><span class="line">    	System.out.println(builder.buildPerson(name).getName());</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	printName(<span class="string">&quot;赵丽颖&quot;</span>, Person::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： <code>name -&gt; new Person(name)</code></li>
<li>方法引用： <code>Person::new</code></li>
</ul>
<h3 id="数组的构造器引用"><a href="#数组的构造器引用" class="headerlink" title="数组的构造器引用"></a>数组的构造器引用</h3><p>数组也是 <code>Object</code> 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，<br>需要一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ArrayBuilder</span> &#123;</span><br><span class="line">	<span class="type">int</span>[] buildArray(<span class="type">int</span> length);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在应用该接口的时候，可以通过Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11ArrayInitRef</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] initArray(<span class="type">int</span> length, ArrayBuilder builder) &#123;</span><br><span class="line">    	<span class="keyword">return</span> builder.buildArray(length);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="type">int</span>[] array = initArray(<span class="number">10</span>, length ‐&gt; <span class="keyword">new</span> <span class="title class_">int</span>[length]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是更好的写法是使用数组的构造器引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12ArrayInitRef</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] initArray(<span class="type">int</span> length, ArrayBuilder builder) &#123;</span><br><span class="line">    	<span class="keyword">return</span> builder.buildArray(length);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="type">int</span>[] array = initArray(<span class="number">10</span>, <span class="type">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的：</p>
<p>Lambda表达式： <code>length -&gt; new int[length]</code></p>
<p>方法引用： <code>int[]::new</code></p>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>说到Stream便容易想到I&#x2F;O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的<strong>Stream</strong>概念，用于解决已有集合类库既有的弊端。</p>
<p>传统集合的多步遍历代码几乎所有的集合（如 <code>Collection</code> 接口或 <code>Map</code> 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01ForEach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">        	System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。</p>
<h3 id="循环遍历的弊端"><a href="#循环遍历的弊端" class="headerlink" title="循环遍历的弊端"></a>循环遍历的弊端</h3><p>Java 8的Lambda让我们可以更加专注于<strong>做什么</strong>（What），而不是<strong>怎么做</strong>（How），这点此前已经结合内部类进行了对比说明。现在，我们仔细体会一下上例代码，可以发现：</p>
<ul>
<li>for循环的语法就是“<strong>怎么做</strong>”</li>
<li>for循环的循环体才是“<strong>做什么</strong>”</li>
</ul>
<p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，<strong>而并不是从第一个到最后一个顺次处理的循环</strong>。前者是目的，后者是方式。</p>
<p>试想一下，如果希望对集合中的元素进行筛选过滤：</p>
<ol>
<li>将集合A根据条件一过滤为<strong>子集B</strong>；</li>
<li>然后再根据条件二过滤为<strong>子集C</strong>。</li>
</ol>
<p>那怎么办？在Java 8之前的做法可能为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02NormalFilter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        List&lt;String&gt; zhangList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">                zhangList.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; shortList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : zhangList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                shortList.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : shortList) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这段代码中含有三个循环，每一个作用不同：</p>
<ol>
<li>首先筛选所有姓张的人；</li>
<li>然后筛选名字有三个字的人；</li>
<li>最后进行对结果进行打印输出。</li>
</ol>
<p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？<strong>不是。</strong>循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。</p>
<p>那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？</p>
<h3 id="Stream的更优写法"><a href="#Stream的更优写法" class="headerlink" title="Stream的更优写法"></a>Stream的更优写法</h3><p>下面来看一下借助Java 8的Stream API，什么才叫优雅：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03StreamFilter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">            .filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>))<span class="comment">//这里的stream和下面的stream不是同一个。filter会返回一个stream。</span></span><br><span class="line">            .filter(s ‐&gt; s.length() == <span class="number">3</span>)</span><br><span class="line">            .forEach(System.out::println);<span class="comment">//同上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p>
<h2 id="流式思想"><a href="#流式思想" class="headerlink" title="流式思想"></a>流式思想</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>注意：请暂时忘记对传统IO流的固有印象！</p>
<p><strong>整体来看，流式思想类似于工厂车间的“</strong>生产流水线”。</p>
<p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤    方案，然后再按照方案去执行它。这是一种集合元素的处理方案，而方案就是一种“函数模型”。</p>
<p>这里的 <code>filter 、 map 、 skip</code> 都是在对函数模型进行操作，集合元素<strong>并没有真正被处理</strong>。只有当终结方法 count执行的时候，整个模型才会按照指定策略执行操作。而这得益于<strong>Lambda的延迟执行特性</strong>。</p>
<blockquote>
<p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p>
</blockquote>
<p>Stream（流）是一个来自数据源的元素队列</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li><strong>数据源</strong> 流的来源。 可以是集合，数组 等。</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如**延迟执行(laziness)和短路( short-circuiting)**。</li>
<li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li>
</ul>
<p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>专注于对容器对象的<strong>聚合操作</strong></p>
<p>提供<strong>串行&#x2F;并行</strong>两种模式</p>
<p>使用<strong>Fork&#x2F;Join框架</strong>拆分任务</p>
<p><strong>提高编程效率、可读性</strong></p>
<p><strong>获取流 -&gt; 中间操作 -&gt; 终结操作</strong></p>
<h2 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h2><p><code>java.util.stream.Stream&lt;T&gt;</code> 是Java 8新加入的最常用的流接口（这并不是一个函数式接口）。获取一个流非常简单，有以下几种常用的方式：</p>
<ul>
<li><p>所有的 Collection 集合都可以通过 stream 默认方法获取流；</p>
</li>
<li><p>Stream 接口的静态方法 of 可以获取数组对应的流。</p>
</li>
</ul>
<h3 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h3><p>首先， <code>java.util.Collection</code> 接口中加入了default方法 <code>stream</code> 用来获取流，所以其所有实现类均可获取流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04GetStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream3 = vector.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据<strong>Map获取流</strong></h3><p><code>java.util.Map</code> 接口不是 <code>Collection</code> 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05GetStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">        Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a><strong>根据数组获取流</strong></h3><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法of ，使用很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06GetStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] array = &#123; <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张一元&quot;</span> &#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注： <strong>of</strong> 方法的参数其实是一个可变参数，所以支持数组。</p>
</blockquote>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p>
<ul>
<li><p><strong>延迟方法</strong>：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。）</p>
</li>
<li><p><strong>终结方法</strong>：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调用。本小节中，终结方法包括 count 和 forEach 方法。</p>
</li>
<li><p>中间操作（Intermediate）</p>
<p><strong>map</strong> (mapToInt, flatMap 等)、 <strong>filter</strong>、 distinct、 sorted、 peek、 <strong>limit</strong>、 <strong>skip</strong>、 parallel、 sequential、 unordered、concat</p>
</li>
<li><p>终结操作（Terminal）</p>
<p><strong>forEach</strong>、 forEachOrdered、 <strong>toArray</strong>、 reduce、 <strong>collect</strong>、 min、 max、 <strong>count</strong>、 iterator、anyMatch、 allMatch、 noneMatch、 findFirst、 findAny</p>
</li>
</ul>
<h3 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：<strong>forEach</strong></h3><p>虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure>

<p>该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。</p>
<h4 id="复习Consumer接口"><a href="#复习Consumer接口" class="headerlink" title="复习Consumer接口"></a><strong>复习Consumer接口</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。</span><br><span class="line"></span><br><span class="line">Consumer接口中包含抽象方法<span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>，意为消费一个指定泛型的数据。</span><br></pre></td></tr></table></figure>

<h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a><strong>基本使用：</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12StreamForEach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        stream.forEach(name‐&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h3><p>可以通过 filter 方法将一个流转换成另一个子集流。方法签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>

<p>该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p>
<h4 id="复习Predicate接口"><a href="#复习Predicate接口" class="headerlink" title="复习Predicate接口"></a>复习Predicate接口</h4><p>此前我们已经学习过 <code>java.util.stream.Predicate</code> 函数式接口，其中唯一的抽象方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br></pre></td></tr></table></figure>

<p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>Stream流中的 filter 方法基本使用的代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07StreamFilter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。</p>
<h3 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h3><p>如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>

<p>该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p>
<h4 id="复习Function接口"><a href="#复习Function接口" class="headerlink" title="复习Function接口"></a>复习Function接口</h4><p>此前我们已经学习过 <code>java.util.stream.Function</code> 函数式接口，其中唯一的抽象方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br></pre></td></tr></table></figure>

<p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。</p>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>Stream流中的 map 方法基本使用的代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08StreamMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line">        Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这段代码中， map 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对象）。</p>
<h3 id="统计个数：count"><a href="#统计个数：count" class="headerlink" title="统计个数：count"></a>统计个数：count</h3><p>正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09StreamCount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">        System.out.println(result.count()); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h3><p>limit 方法可以对流进行截取，只取用前n个。方法签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br></pre></td></tr></table></figure>

<p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10StreamLimit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.limit(<span class="number">2</span>);</span><br><span class="line">        System.out.println(result.count()); <span class="comment">//&quot;张无忌&quot;, &quot;张三丰&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h3><p>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11StreamSkip</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.skip(<span class="number">2</span>);</span><br><span class="line">        System.out.println(result.count()); <span class="comment">//周芷若</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h3><p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。</p>
</blockquote>
<p>该方法的基本使用代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12StreamConcat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;张翠山&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="收集器：collect"><a href="#收集器：collect" class="headerlink" title="收集器：collect"></a>收集器：collect</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    Stream流的收集方法</span></span><br><span class="line"><span class="comment">        R collect(Collector collector)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    它是通过工具类Collectors提供了具体的收集方式</span></span><br><span class="line"><span class="comment">        public static &lt;T&gt; Collector toList()：把元素收集到List集合中</span></span><br><span class="line"><span class="comment">        public static &lt;T&gt; Collector toSet()：把元素收集到Set集合中</span></span><br><span class="line"><span class="comment">        public static Collector toMap(Function keyMapper,Function valueMapper)：把元素收集到Map集合中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06Stream_collect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建List集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求1：得到名字为3个字的流</span></span><br><span class="line">        Stream&lt;String&gt; listStream = list.stream().filter(s -&gt; s.length() == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历</span></span><br><span class="line">        List&lt;String&gt; names = listStream.collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Set集合对象</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">30</span>);</span><br><span class="line">        set.add(<span class="number">33</span>);</span><br><span class="line">        set.add(<span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求3：得到年龄大于25的流</span></span><br><span class="line">        Stream&lt;Integer&gt; setStream = set.stream().filter(age -&gt; age &gt; <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历</span></span><br><span class="line">        Set&lt;Integer&gt; ages = setStream.collect(Collectors.toSet());</span><br><span class="line">        <span class="keyword">for</span> (Integer age : ages) &#123;</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成</span></span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;王祖贤,33&quot;</span>, <span class="string">&quot;柳岩,25&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求5：得到字符串中年龄数据大于28的流</span></span><br><span class="line">        Stream&lt;String&gt; arrayStream = Stream.of(strArray).filter(</span><br><span class="line">                s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = arrayStream.collect(Collectors.toMap(</span><br><span class="line">                s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>],</span><br><span class="line">                s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">        ));</span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;,,&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://water001-maker.github.io">Xue_Water</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://water001-maker.github.io/2023/02/26/Lambda&amp;Stream/">https://water001-maker.github.io/2023/02/26/Lambda&amp;Stream/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://water001-maker.github.io" target="_blank">幻想家的秘密基地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Stream/">Stream</a><a class="post-meta__tags" href="/tags/Lambda/">Lambda</a></div><div class="post_share"><div class="social-share" data-image="/img/cover12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/27/%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95/" title="进程之间的通信方法"><img class="cover" src="/img/cover2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">进程之间的通信方法</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/23/MQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="MQ常见问题"><img class="cover" src="/img/cover3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MQ常见问题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xue_Water</div><div class="author-info__description">学而不思则罔，思而不学则殆</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Water001-maker"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一个努力学习的小白，会不定期将自己的学习笔记整理到这里，仅供大家学习和参考。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">语法格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">常见的函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Runnable-x2F-Callable"><span class="toc-number">1.2.1.</span> <span class="toc-text">Runnable &#x2F; Callable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Supplier-x2F-Consumer"><span class="toc-number">1.2.2.</span> <span class="toc-text">Supplier &#x2F; Consumer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparator"><span class="toc-number">1.2.3.</span> <span class="toc-text">Comparator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicate"><span class="toc-number">1.2.4.</span> <span class="toc-text">Predicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Function"><span class="toc-number">1.2.5.</span> <span class="toc-text">Function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">Lambda的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">使用Lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">使用匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.2.</span> <span class="toc-text">示例代码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">反编译lambda表达式代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E7%8C%9C%E6%83%B3"><span class="toc-number">1.3.4.</span> <span class="toc-text">验证猜想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">Lambda表达式编译和运行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%E7%BB%93%E8%AE%BA"><span class="toc-number">1.3.6.</span> <span class="toc-text">Lambda表达式的语法糖结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E7%9A%84Lambda%E5%9C%BA%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">冗余的Lambda场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E6%94%B9%E8%BF%9B%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">用方法引用改进代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">方法引用符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">语义分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E4%B8%8E%E7%9C%81%E7%95%A5"><span class="toc-number">2.2.2.</span> <span class="toc-text">推导与省略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">方法引用的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">方法引用语法格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E5%90%8D%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">通过对象名引用成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E7%A7%B0%E5%BC%95%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">通过类名称引用静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87super%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.3.</span> <span class="toc-text">通过super引用成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87this%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.4.</span> <span class="toc-text">通过this引用成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.5.</span> <span class="toc-text">类的构造器引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.6.</span> <span class="toc-text">数组的构造器引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stream%E6%B5%81"><span class="toc-number">3.</span> <span class="toc-text">Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">3.1.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">3.1.1.</span> <span class="toc-text">循环遍历的弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E7%9A%84%E6%9B%B4%E4%BC%98%E5%86%99%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">Stream的更优写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E6%80%9D%E6%83%B3"><span class="toc-number">3.2.</span> <span class="toc-text">流式思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B5%81"><span class="toc-number">3.3.</span> <span class="toc-text">获取流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AECollection%E8%8E%B7%E5%8F%96%E6%B5%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">根据Collection获取流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AEMap%E8%8E%B7%E5%8F%96%E6%B5%81"><span class="toc-number">3.3.2.</span> <span class="toc-text">根据Map获取流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%95%B0%E7%BB%84%E8%8E%B7%E5%8F%96%E6%B5%81"><span class="toc-number">3.3.3.</span> <span class="toc-text">根据数组获取流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E4%B8%80%E5%A4%84%E7%90%86%EF%BC%9AforEach"><span class="toc-number">3.4.1.</span> <span class="toc-text">逐一处理：forEach</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0Consumer%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">复习Consumer接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">基本使用：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%EF%BC%9Afilter"><span class="toc-number">3.4.2.</span> <span class="toc-text">过滤：filter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0Predicate%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">复习Predicate接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">基本使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%EF%BC%9Amap"><span class="toc-number">3.4.3.</span> <span class="toc-text">映射：map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0Function%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">复习Function接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-1"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">基本使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%B8%AA%E6%95%B0%EF%BC%9Acount"><span class="toc-number">3.4.4.</span> <span class="toc-text">统计个数：count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E7%94%A8%E5%89%8D%E5%87%A0%E4%B8%AA%EF%BC%9Alimit"><span class="toc-number">3.4.5.</span> <span class="toc-text">取用前几个：limit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BF%87%E5%89%8D%E5%87%A0%E4%B8%AA%EF%BC%9Askip"><span class="toc-number">3.4.6.</span> <span class="toc-text">跳过前几个：skip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%EF%BC%9Aconcat"><span class="toc-number">3.4.7.</span> <span class="toc-text">组合：concat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9Acollect"><span class="toc-number">3.4.8.</span> <span class="toc-text">收集器：collect</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/29/%E5%85%8D%E8%B4%B9%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BBTypora/" title="永久激活Typora"><img src="/img/cover4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="永久激活Typora"/></a><div class="content"><a class="title" href="/2023/03/29/%E5%85%8D%E8%B4%B9%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BBTypora/" title="永久激活Typora">永久激活Typora</a><time datetime="2023-03-28T16:00:00.000Z" title="发表于 2023-03-29 00:00:00">2023-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/26/ChatGPT/" title="chatGPT"><img src="/img/cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="chatGPT"/></a><div class="content"><a class="title" href="/2023/03/26/ChatGPT/" title="chatGPT">chatGPT</a><time datetime="2023-03-25T16:00:00.000Z" title="发表于 2023-03-26 00:00:00">2023-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/25/JPA%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" title="JPA的命名规范"><img src="/img/cover5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JPA的命名规范"/></a><div class="content"><a class="title" href="/2023/03/25/JPA%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" title="JPA的命名规范">JPA的命名规范</a><time datetime="2023-03-24T16:00:00.000Z" title="发表于 2023-03-25 00:00:00">2023-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/Stream%E6%B5%81%E6%97%A0%E6%B3%95%E7%BB%99%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC/" title="Stream流无法赋值给外部属性"><img src="/img/cover3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Stream流无法赋值给外部属性"/></a><div class="content"><a class="title" href="/2023/03/22/Stream%E6%B5%81%E6%97%A0%E6%B3%95%E7%BB%99%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC/" title="Stream流无法赋值给外部属性">Stream流无法赋值给外部属性</a><time datetime="2023-03-21T16:00:00.000Z" title="发表于 2023-03-22 00:00:00">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/Dubbo%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Dubbo源码——消费者"><img src="/img/cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dubbo源码——消费者"/></a><div class="content"><a class="title" href="/2023/03/20/Dubbo%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Dubbo源码——消费者">Dubbo源码——消费者</a><time datetime="2023-03-19T16:00:00.000Z" title="发表于 2023-03-20 00:00:00">2023-03-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/cover12.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xue_Water</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://water001-maker.github.io/2023/02/26/Lambda&Stream/'
    this.page.identifier = '/2023/02/26/Lambda&Stream/'
    this.page.title = 'Lambda&Stream'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="JVM,JDK,JRE,Mysql,Redis,Spring,MQ,ES,Oracle,Jva" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>